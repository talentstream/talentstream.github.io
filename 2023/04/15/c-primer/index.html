<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="前言由于面试被狠狠拷打，决定恶补c++。有些概念太长会以图片显示 变量和基本类型基本类型 一些类型选择的建议：  数值不可能为负时，选用无符号类型 使用int执行整数运算，如果超过int范围，选用longlong 算术表达式中不要使用char或bool,只有在存放字符或bool值才使用它们。因为char在有些机器是有符号的，而在一些机器上又是无符号的。 执行浮点数运算用double，float常常">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ primer">
<meta property="og:url" content="http://example.com/2023/04/15/c-primer/index.html">
<meta property="og:site_name" content="TALENTSTREAM">
<meta property="og:description" content="前言由于面试被狠狠拷打，决定恶补c++。有些概念太长会以图片显示 变量和基本类型基本类型 一些类型选择的建议：  数值不可能为负时，选用无符号类型 使用int执行整数运算，如果超过int范围，选用longlong 算术表达式中不要使用char或bool,只有在存放字符或bool值才使用它们。因为char在有些机器是有符号的，而在一些机器上又是无符号的。 执行浮点数运算用double，float常常">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418202838.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418203722.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418204711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418204946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205302.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205426.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205542.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205841.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211425.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211747.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211809.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211905.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212135.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212340.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212627.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418213248.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418213820.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214147.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214232.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214516.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214614.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418215607.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220655.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220844.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418221240.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418221458.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418222613.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418222654.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419093955.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094201.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094228.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094312.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094545.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094557.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094706.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095331.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095540.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095813.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095939.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419100130.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419100642.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419104556.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132259.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132320.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132236.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419105145.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419110344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132434.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132459.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132655.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132730.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421105708.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110256.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110618.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110649.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110735.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110825.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110855.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111054.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111845.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111856.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111906.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421112312.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421112244.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125221.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125231.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125357.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421130122.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422204832.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211706.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211751.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211833.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422212543.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211331.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422213444.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425195814.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200215.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200629.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200725.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200822.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200902.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201049.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201329.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201416.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201920.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202108.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202245.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202408.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202449.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202540.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202609.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202654.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202727.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202750.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205348.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205429.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205447.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425211551.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425211902.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501202449.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501205622.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501205711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210052.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210525.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210603.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210639.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210650.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210929.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506195211.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506200110.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506200857.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506201821.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203014.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203438.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203413.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203743.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204218.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204605.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204742.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211340.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211509.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211603.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211803.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211925.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506212016.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506231308.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507001946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507002510.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507002957.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507003227.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507003912.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507004102.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507004122.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507144244.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507152318.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507152800.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507153006.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507154155.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507155227.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507161237.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507164433.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507164558.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507165048.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507165828.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507211827.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507212141.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507213936.png">
<meta property="article:published_time" content="2023-04-15T13:19:35.000Z">
<meta property="article:modified_time" content="2024-01-07T07:46:01.440Z">
<meta property="article:author" content="TALENTSTREAM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418202838.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>c++ primer</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="TALENTSTREAM" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Blog</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/05/02/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/02/04/Sortings/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/04/15/c-primer/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/04/15/c-primer/&text=c++ primer"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/04/15/c-primer/&is_video=false&description=c++ primer"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=c++ primer&body=Check out this article: http://example.com/2023/04/15/c-primer/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/04/15/c-primer/&name=c++ primer&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/04/15/c-primer/&t=c++ primer"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">字面值常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">2.5.</span> <span class="toc-text">声明与定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text">指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">4.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">const与引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">4.2.</span> <span class="toc-text">const与指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E4%B8%8E%E5%BA%95%E5%B1%82const"><span class="toc-number">4.3.</span> <span class="toc-text">顶层与底层const</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#constexpr-%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">constexpr 和常量表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">5.1.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">5.2.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype"><span class="toc-number">5.3.</span> <span class="toc-text">decltype</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text">左值右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">求值顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E4%BD%99"><span class="toc-number">7.3.</span> <span class="toc-text">取余</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i-%E8%BF%98%E6%98%AF-i"><span class="toc-number">7.4.</span> <span class="toc-text">++i 还是 i++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.5.</span> <span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.6.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.7.</span> <span class="toc-text">sizeof 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.8.</span> <span class="toc-text">显式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTTI-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">7.9.</span> <span class="toc-text">RTTI 运行时类型识别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.</span> <span class="toc-text">局部对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">传值参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">8.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">8.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr-%E5%87%BD%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">constexpr 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.7.</span> <span class="toc-text">实参类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">8.8.</span> <span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">初步探索类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">9.3.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84inline"><span class="toc-number">9.4.</span> <span class="toc-text">类的inline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">9.5.</span> <span class="toc-text">可变数据成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">9.6.</span> <span class="toc-text">类的静态成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">10.</span> <span class="toc-text">c++标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">顺序容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">容器迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">10.3.</span> <span class="toc-text">容器定义和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%92%8Cswap"><span class="toc-number">10.4.</span> <span class="toc-text">赋值和swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%AF%94%E8%BE%83"><span class="toc-number">10.5.</span> <span class="toc-text">容器比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">10.6.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">10.7.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">10.8.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">10.9.</span> <span class="toc-text">改变容器大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-%E6%93%8D%E4%BD%9C"><span class="toc-number">10.10.</span> <span class="toc-text">string 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">10.11.</span> <span class="toc-text">容器适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">lambada表达式与泛型算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambada-%E6%8D%95%E8%8E%B7"><span class="toc-number">11.2.</span> <span class="toc-text">lambada 捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">12.</span> <span class="toc-text">动态内存和智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-number">12.1.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">12.2.</span> <span class="toc-text">直接管理内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr"><span class="toc-number">12.3.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-number">12.4.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">13.</span> <span class="toc-text">拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">13.2.</span> <span class="toc-text">拷贝赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-default"><span class="toc-number">13.4.</span> <span class="toc-text">&#x3D;default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-delete"><span class="toc-number">13.5.</span> <span class="toc-text">&#x3D;delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">13.6.</span> <span class="toc-text">拷贝控制和资源管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">13.7.</span> <span class="toc-text">交换操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-number">14.</span> <span class="toc-text">对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">14.1.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">移动构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.3.</span> <span class="toc-text">移动赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">14.4.</span> <span class="toc-text">合成移动操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">15.</span> <span class="toc-text">面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">15.1.</span> <span class="toc-text">数据抽象、继承、动态绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">基类和派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">15.4.</span> <span class="toc-text">抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">15.5.</span> <span class="toc-text">访问控制与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">15.6.</span> <span class="toc-text">继承的类作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">15.7.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.</span> <span class="toc-text">合成拷贝控制与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">15.9.</span> <span class="toc-text">继承的构造函数</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        c++ primer
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">TALENTSTREAM</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-15T13:19:35.000Z" class="dt-published" itemprop="datePublished">2023-04-15</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于面试被狠狠拷打，决定恶补c++。有些概念太长会以图片显示</p>
<h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418202838.png"></p>
<p>一些类型选择的建议：</p>
<ul>
<li>数值不可能为负时，选用无符号类型</li>
<li>使用int执行整数运算，如果超过int范围，选用longlong</li>
<li>算术表达式中不要使用char或bool,只有在存放字符或bool值才使用它们。因为char在有些机器是有符号的，而在一些机器上又是无符号的。</li>
<li>执行浮点数运算用double，float常常精度不够，而且双精度和单精度的计算代价相差无几。</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418203722.png"></p>
<ul>
<li>将非bool型算术值赋给bool时，为0则结果为false，否则为true</li>
<li>当bool值给非bool型，为false则结果为0，true 为 1</li>
<li>当浮点数赋给整数类型时，砍掉小数点后面的</li>
<li>当整数赋给浮点时，小数部分为0</li>
<li>当给unsigned赋给一个超出范围的值时，结果是初始值加表示数值总数取模后的余数，在这里就是(-1+256)%256</li>
<li>当给一个有符号类型一个超出范围的值时，结果时未定义的。程序可能继续工作、可能崩溃，也可能产生垃圾数据。</li>
</ul>
<p>当一个算数表达式既有unsigned又有int时，int就会转化为unsigned</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418204711.png"></p>
<p>当 u &#x3D; 0 时，迭代输出0，然后执行–u，此时 u &#x3D; -1 被自动转化为4294967295，此时会无限循环</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418204946.png"></p>
<h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><p>以0开头代表八进制数，0x或0X开头代表十六进制，比如：<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205302.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205426.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205542.png"></p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>当对象在创建时获得了一个特定值，我们说这个对象被初始化了。如果定义变量时没有指定初值，则变量被默认初始化，此时被赋予了“默认值”。定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置变量将不被初始化，由于是未被定义的，试图拷贝或以其他形式访问此值将引发错误。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205841.png"></p>
<h4 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h4><p>c++将声明和定义区分开来，声明使得名字为程序所知，定义负责创建与名字关联的实体。</p>
<p>变量声明规定变量的类型和名字，在这一点上定义与之相同，但除此之外，定义还申请存储空间，也可能为变量赋一个初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// 如果想声明一个变量而非定义它，在变量名前添加关键字extern</span></span><br><span class="line"><span class="type">int</span> j;<span class="comment">// 声明并定义 j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>; <span class="comment">// extern语句如果包含初始值就不再是声明，而变成定义了。</span></span><br><span class="line"><span class="comment">// 如果在函数体这样写，将会引发错误。</span></span><br></pre></td></tr></table></figure>

<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211425.png"></p>
<ul>
<li>引用即别名。</li>
<li>引用本身并不是一个对象，不能定义引用的引用。</li>
<li>引用类型要与之绑定的对象严格匹配。</li>
<li>引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</li>
</ul>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211747.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211809.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211905.png"></p>
<p>指针的值（地址）应属于下列4种状态之一：</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针，意味着指针没有指向任何对象</li>
<li>无效指针，也就是上述情况之外的其他值，试图拷贝或以其他形式访问无效指针都将引发错误</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212135.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212340.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212627.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">// 从右往左读，离变量名最近的符号对变量的类型有最直接的影响，因此r是一个引用。*说明r引用的是一个指针。</span></span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>默认状态下，const对象仅在一个文件内有效，如果程序包含多个文件，同名的const变量其实等同于在不同文件中分别定义了独立的变量。解决的方法便是在const变量前加extern</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="const与引用"><a href="#const与引用" class="headerlink" title="const与引用"></a>const与引用</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418213248.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418213820.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214147.png"></p>
<p>由于const引用也经常被称为常量引用，所以在正常引用中不能做的——使用字面值或者表达式作为初始值，类型不一致，在const引用中都可以做</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214232.png"></p>
<h4 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214516.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214614.png"></p>
<h4 id="顶层与底层const"><a href="#顶层与底层const" class="headerlink" title="顶层与底层const"></a>顶层与底层const</h4><p>顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量，也就是说，顶层const表示的对象是常量，无法改变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418215607.png"></p>
<h5 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h5><p>常量表达式指值不会改变且在编译过程就能得到计算结果的表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>; <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;<span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;<span class="comment">// 不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();<span class="comment">// 不是常量表达式</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220303.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220655.png"></p>
<h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220844.png"></p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418221240.png"></p>
<h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype 作用是选择并返回操作数的数据类型。编译器只分析表达式得到类型，却不实际计算表达式的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418221458.png"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418222613.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418222654.png"></p>
<p>使用数组下标时，通常将其定义为size_t类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419093955.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094201.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094228.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094312.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094545.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094557.png"></p>
<p>严格来说，c++没有多维数组，通常说的多维数组其实是数组的数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094706.png"></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h4><p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p>
<h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095331.png"></p>
<h4 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095540.png"></p>
<h4 id="i-还是-i"><a href="#i-还是-i" class="headerlink" title="++i 还是 i++"></a>++i 还是 i++</h4><p>前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095813.png"></p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095939.png"></p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419100130.png"></p>
<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p>sizeof 返回一条表达式或一个类型名字所占的字节数。其所得值是一个size_t类型的常量表达式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419100642.png"></p>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><ul>
<li><p>static_cast: 只要不包含底层const，就可以用。当需要把一个较大的算数类型复制给较小的类型时，同时我们不在乎潜在的精度损失，static_cast就非常有用。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419104556.png"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132259.png"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132320.png"></p>
</li>
<li><p>dynamic_cast:运行时类型识别的运算符，用于将基类的指针或引用安全地转化为派生类的指针或引用。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132236.png"></p>
</li>
<li><p>const_cast: 它只能改变运算对象的底层const，一般称其为“去掉const性质”，一旦去掉，编译器就不再组织我们对该对象进行写操作了。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419105145.png"></p>
</li>
<li><p>reinterpret_cast: 通常为运算对象的位模式提供较低层次的重新解释。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419110344.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">65</span>);</span><br><span class="line"><span class="type">char</span>* ch = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt; (p);</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 65</span></span><br><span class="line">cout &lt;&lt; *ch &lt;&lt; endl; <span class="comment">// A</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl; <span class="comment">// 地址00000249CE417930</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl; <span class="comment">// A</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>举个例子，32位系统，int是32位，指针也是32位，我既可以把一个32位的值解释成一个整数，也可以解释成一个指针。至于究竟能不能这样解释，由程序员负责。而reinterpret_cast就是干这个事的。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33040213">C++类型转换之reinterpret_cast</a></p>
</blockquote>
</li>
</ul>
<h4 id="RTTI-运行时类型识别"><a href="#RTTI-运行时类型识别" class="headerlink" title="RTTI 运行时类型识别"></a>RTTI 运行时类型识别</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132434.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132459.png"></p>
<p>typeid 作用于对象，我们应该用*bp而非bp</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132655.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132730.png"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h4><p>名字有作用域、对象有生命周期。</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间</li>
</ul>
<p>自动对象：我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。</p>
<p>形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。</p>
<p>局部静态对象：在程序的第一次执行初始化，直到程序终止才销毁。在此期间，即使对象所在的函数结束执行也不会对它有所影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421105708.png"></p>
<h4 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h4><p>形参初始化的原理与变量初始化一样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110256.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110522.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110618.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110649.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110735.png"></p>
<p><strong>含有可变形参的函数</strong> ： </p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110825.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110855.png"></p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>不要返回局部对象的引用或指针：函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111054.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111845.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111856.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111906.png"></p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421112312.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421112244.png"></p>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数可避免函数调用的开销，一般来说，内联机制用于优化规模较小，流程直接，频繁调用的函数。就比如说，调用函数比函数执行时间长，用内联函数就行了。</p>
<h4 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125221.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125231.png"></p>
<h4 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125357.png"></p>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>感觉类似于c#的委托，像是给一个函数的别名</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421130122.png"></p>
<h3 id="初步探索类"><a href="#初步探索类" class="headerlink" title="初步探索类"></a>初步探索类</h3><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>常量对象、以及常量对象的引用或指针都只能调用常量成员函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422204832.png"></p>
<p>简单来说，就是让该函数的权限为只读，也就是说没法去改变成员函数的值。<br>同时，如果一个对象为const，它只有权力调用const函数，因为成员变量不能改变。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>不同于其他函数，构造函数不能被声明成const。</p>
<p>如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。又称为合成默认构造函数，按照一下规则初始化类地数据成员</p>
<ul>
<li>如果存在类内的初始值，就用它来初始化成员</li>
<li>否则，默认初始化该成员。</li>
</ul>
<p>某些类不能依赖于合成的默认构造函数，原因如下：</p>
<ul>
<li>对于一个普通的类来说，必须定义它自己的默认构造函数。只有类不包含任何构造函数的情况下才会自动生成默认构造函数。</li>
<li>对于某些类来说，合成的默认构造函数可能执行错误的操作。如果定义在块中的内置类型或复合类型（数组和指针）被默认初始化，则它们的值将是未定义的。</li>
<li>如果类中包含一个其他类类型的成员且这个成员没有默认构造函数，那么编译器将无法初始化该成员。</li>
</ul>
<p>&#x3D; default，即要求编译器生成默认构造函数，如果在类的内部，默认是内联的，如果在类的外部，默认不是内联的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211706.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211751.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211833.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422212543.png"></p>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。</p>
<p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。一般来说，最好定义在类开始的位置或者结束的位置。</p>
<p>友元仅仅指定了访问权限，如果希望类能够调用某个友元函数，那么必须在友元声明之外在专门对函数定义一次。</p>
<h4 id="类的inline"><a href="#类的inline" class="headerlink" title="类的inline"></a>类的inline</h4><p>在类中，常有一些规模较小的函数适合被声明内联函数，定义在类内部的成员函数是自动inline的。</p>
<h4 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211331.png"></p>
<h4 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h4><p>类的静态成员存在任何对象之外，对象中不包含任何于静态数据成员有关的数据。静态成员函数也不予任何对象绑定在一起，它们不包含this指针。同时，静态成员函数不能声明成const，也不能在里面调用this指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422213444.png"></p>
<h3 id="c-标准库"><a href="#c-标准库" class="headerlink" title="c++标准库"></a>c++标准库</h3><h4 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425195814.png"></p>
<p>顺序容器的选择：</p>
<ul>
<li>通常选择vector</li>
<li>有很多小元素，空间额外开销很重要，不要用list或forward_list</li>
<li>随机访问元素，用vector 或 deque</li>
<li>在中间插入或删除元素，应使用list或forward_list</li>
<li>头尾插入或删除元素，用deque</li>
<li>如果只有在输入时踩在中间位置插入元素，随后需要随机访问：考虑输入阶段用list，输入完成后拷贝到vector</li>
<li>又要随机访问，又要在中间位置插入元素，看访问操作多还是插入&#x2F;删除元素操作多</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200215.png"></p>
<h4 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h4><p>begin指向第一个元素，end指向最后一个元素之后的位置通常称为左闭右合区间。即[begin,end)</p>
<ul>
<li>如果begin &#x3D;&#x3D; end 说明该范围为空</li>
<li>如果begin !&#x3D; end 说明至少包含一个元素，且begin指向该范围中的第一个元素</li>
<li>begin可以递增，使得begin &#x3D;&#x3D; end</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(begin!=end)&#123;</span><br><span class="line">  *begin = val;</span><br><span class="line">  ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200629.png"></p>
<p>当不需要写访问的时候，应该使用cbegin和cend</p>
<h4 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200725.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200822.png"></p>
<h4 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200902.png"></p>
<p>assign 相对于赋值运算符(&#x3D;)允许从以一个不同但相容的类型赋值（比如char* 和 string），或者从容器的一个子序列赋值。assign操作用所指定的元素的拷贝替换容器中的所有元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201049.png"></p>
<p>swap操作交换两个相同类型的内容，保证操作很快，元素本身未被交换，只是交换了两个容器的内部数据结构。<br>元素不会被移动意味着，除string外指向容器的迭代器、引用指针在swap后都不会失效，除了string。<br>与其他容器不同，swap两个array会真正地交换元素。</p>
<h4 id="容器比较"><a href="#容器比较" class="headerlink" title="容器比较"></a>容器比较</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201329.png"></p>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201416.png"></p>
<ul>
<li>push_back、push_front、insert:放入到容器中的元素时对象值地一个拷贝而不是对象本身。</li>
<li>emplace操作:则是将参数传递给元素类型的构造函数，直接在容器管理的内存空间中直接构造元素，参数必须与元素类型的构造函数相匹配。</li>
</ul>
<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201920.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202108.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202245.png"></p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202408.png"></p>
<h4 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202449.png"></p>
<h4 id="string-操作"><a href="#string-操作" class="headerlink" title="string 操作"></a>string 操作</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202540.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202609.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202654.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202711.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202727.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202750.png"></p>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>也就是让容器看起来像一种不同的类型，比如说queue是基于deque实现的。比较常见的时stack，queue,priority_queue。</p>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><p>算法永远不会改变底层容器的大小，可能改变值，可能移动元素，但永远不会添加或删除元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读算法</span></span><br><span class="line"><span class="type">int</span> *result = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),val);<span class="comment">//查找算法</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">count</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),val);<span class="comment">// 统计个数</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),<span class="number">0</span>);<span class="comment">// 求和、和的初值设置为0</span></span><br><span class="line">string result = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),<span class="string">&quot;&quot;</span>); <span class="comment">// 将vec的每个元素连起来</span></span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">equal</span>(vec.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),other.<span class="built_in">cbegin</span>());<span class="comment">// 比较算法，确定两个序列是否保存相同的值，基于两个序列相等的假设。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写算法</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());<span class="comment">// 将元素重置为0</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">begin</span>() + vec.<span class="built_in">size</span>()/<span class="number">2</span>,<span class="number">10</span>);<span class="comment">//将子序列都赋为10</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">size</span>(),<span class="number">0</span>); <span class="comment">// 与fill稍微不同，是从vec.begin开始将vec.size()个元素变为0。</span></span><br><span class="line"><span class="comment">// 要注意的是，fill_n假定begin指定一个元素，从begin开始的序列至少包含vec.size()个元素，容易犯的错误就是在空容器调用fill_n</span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),vec2);<span class="comment">// 将vec拷贝到vec2中，返回目的位置迭代器即vec2为元素之后的位置</span></span><br><span class="line"><span class="built_in">replace</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//将0变为42</span></span><br><span class="line"><span class="built_in">replace_copy</span>(a.<span class="built_in">cbegin</span>(),a.<span class="built_in">cend</span>(),<span class="built_in">back_inserter</span>(b),<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//将a拷贝到b但是拷贝时0都编程42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排元素算法</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());<span class="comment">// 从小到大排序</span></span><br><span class="line"><span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());<span class="comment">//排列范围的元素，指向不重复区域之后一个位置的迭代器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="lambada表达式与泛型算法"><a href="#lambada表达式与泛型算法" class="headerlink" title="lambada表达式与泛型算法"></a>lambada表达式与泛型算法</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205348.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205429.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205447.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words.vector&lt;string&gt;::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">elimDups</span>(words);<span class="comment">//将words按字典序排序，删除重复单词</span></span><br><span class="line">  <span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[](<span class="type">const</span> string &amp;a,<span class="type">const</span> string &amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()&#125;);</span><br><span class="line">  <span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string &amp;a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz&#125;);</span><br><span class="line">  <span class="keyword">auto</span> count = words.<span class="built_in">end</span>() - wc;</span><br><span class="line">  for_each(wc,words.<span class="built_in">end</span>(),[](<span class="type">const</span> string &amp;s)&#123;cout&lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lambada-捕获"><a href="#lambada-捕获" class="headerlink" title="lambada 捕获"></a>lambada 捕获</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425211551.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425211902.png"></p>
<h3 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h3><p>程序使用动态内存的原因：1.程序不知道自己需要使用多少对象。 2.程序不知道所需对象的准确类型。 3.程序需要在多个对象间共享数据。<br>动态内存很难使用，有时候会忘记释放内存，这时会产生内存泄漏；有时指针引用内存的情况下指针已经被释放这时会产生引用非法内存的指针。</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501202449.png"></p>
<p>默认初始化的智能指针保存一个空指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;<span class="comment">// 初始化方式与vector一样</span></span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;<span class="built_in">empty</span>())</span><br><span class="line">  *p1 = <span class="string">&quot;hi&quot;</span></span><br><span class="line"><span class="comment">// 如果p1不为空，检查它是否指向一个空string</span></span><br></pre></td></tr></table></figure>

<p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为42的int的shared_ptr</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 指向一个值为&quot;9999999999&quot;的string</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// 指向一个值初始化的int，即为0</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于vector的emplace，传递参数类型必须相对应，不传递的话就会进行值初始化，通常用auto来保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p6 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。<br>每个shared_ptr都有一个关联的计数器，通常称为<strong>引用计数</strong>。当我们用一个shared_ptr去初始化另一个shared_ptr，或者作为参数传递给函数，或者作为函数返回值，所关联的计数器都会<strong>递增</strong>。赋予一个新值，或者shared_ptr销毁（比如离开作用域）计数器递减。一旦一个shared_ptr计数器变为0，会自动释放自己所管理的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q;<span class="comment">// 给 r 赋值让它指向另一个地址</span></span><br><span class="line"><span class="comment">// 递增 q 指向对象的引用计数</span></span><br><span class="line"><span class="comment">// 递减 r 原来指向对象的引用计数</span></span><br><span class="line"><span class="comment">// r 原来指向的对象没有引用者，自动释放</span></span><br></pre></td></tr></table></figure>

<h4 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h4><p>new 分配内存，delete释放new分配的内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 默认初始化，*pi的值未定义</span></span><br><span class="line"><span class="type">int</span> *pi1 = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// 值初始化，*pi1为0</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); <span class="comment">// pi2指向的对象的值为1024</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);<span class="comment">// 分配并初始化一个const int</span></span><br><span class="line"><span class="type">const</span> string *pcs = <span class="keyword">new</span> <span class="type">const</span> string;<span class="comment">// 分配并默认初始化一个const 的空string</span></span><br><span class="line"><span class="comment">// 一个动态分配的const对象必须初始化</span></span><br><span class="line"><span class="comment">// 对于一个定义了默认构造函数的类类型</span></span><br><span class="line"><span class="comment">// 其const动态对象可以隐式初始化</span></span><br><span class="line"><span class="comment">// 而其他类型对象就必须显式初始化</span></span><br><span class="line"><span class="comment">// 由于分配对象是const，new返回的指针是一个指向const的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果内存不够用，内存分配失败</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// new抛出std::bad_alloc</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>;<span class="comment">// new 返回一个空指针</span></span><br></pre></td></tr></table></figure>

<p>delete做两步：销毁给定指针指向的对象;释放对应的内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *pi1 = &amp;i;</span><br><span class="line"><span class="type">int</span> *pi2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> *pd = <span class="keyword">new</span> <span class="built_in">double</span>(<span class="number">33</span>);</span><br><span class="line"><span class="type">double</span> *pd2 = pd;</span><br><span class="line"><span class="keyword">delete</span> i;<span class="comment">// 错误，i不是指针</span></span><br><span class="line"><span class="keyword">delete</span> pi1;<span class="comment">// 未定义,pi指向一个局部变量</span></span><br><span class="line"><span class="keyword">delete</span> pd;<span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">delete</span> pd2;<span class="comment">// 未定义，pd2指向的内存已经被释放了</span></span><br><span class="line"><span class="keyword">delete</span> pi2;<span class="comment">// 正确，释放一个空指针没有错误</span></span><br></pre></td></tr></table></figure>

<p>由内置指针管理的动态内存在被显式释放(delete)前一直都会存在</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501205622.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501205711.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210052.png"></p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210525.png"></p>
<ul>
<li>与shared_ptr不同，某个时刻<strong>只能有一个unique_ptr指向一个给定对象</strong>。当unique_ptr被销毁时，所指向的对象也被销毁。</li>
<li>与shared_ptr不同，没有类似make_shared的标准库函数，定义unique_ptr时，<strong>需要将其绑定到一个new返回的指针上</strong>。</li>
<li>由于一个unique_ptr拥有所指向的对象，所以<strong>不支持普通的拷贝或赋值操作</strong>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210603.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210639.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210650.png"></p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210929.png"></p>
<p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个weak_ptr时，要用一个shared_ptr来初始化它</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于对象可能不存在，不能使用weak_ptr直接访问对象</span></span><br><span class="line"><span class="comment">// 而必须调用lock，此函数检查weak_ptr所指对象是否仍然存在</span></span><br><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h3><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>如果一个<strong>构造函数</strong>的<strong>第一个参数</strong>是<strong>自身类类型</strong>的引用，且任何额外默认参数都有默认值，则为拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>();<span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);<span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们构造一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506195211.png"></p>
<p><strong>直接初始化</strong>：实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。</p>
<p><strong>拷贝初始化</strong>：我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。通常使用拷贝构造函数完成，如果有移动构造函数，则有时会使用移动构造函数。</p>
<p>拷贝初始化的发生情况：</p>
<ul>
<li>&#x3D;定义变量</li>
<li>将一个对象从实参传递给非引用的形参</li>
<li>返回类型为非引用类型的函数返回的对象</li>
<li>用花括号列表 初始化一个数组中的元素或一个聚合类的成员</li>
<li>标准库容器insert&#x2F;push，与之相对，用emplace创建的元素都进行直接初始化</li>
</ul>
<p>拷贝函数在这几种情况下都会被隐式地使用，因此，拷贝构造函数不应是explicit的</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506200110.png"></p>
<h4 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data trans,accum;</span><br><span class="line">trans = accum; <span class="comment">// 使用Sales_data 的拷贝赋值元素符</span></span><br></pre></td></tr></table></figure>

<p>与类控制对象如何初始化一样，类也可以控制其对象如何赋值。与拷贝构造函数一样，如果未定义，编译器会为它合成一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;);<span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值运算符通常返回一个指向其左侧运算对象的引用</span></span><br></pre></td></tr></table></figure>

<p>拷贝赋值元素运算符会将右侧对象的每个非static成员赋予左侧对象的对应成员</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506200857.png"></p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数释放对象使用的资源，并销毁对象的非static数据成员。析构函数<strong>没有返回值，也不接受参数，不能呗重载，一个给定类只有唯一一个析构函数</strong>。同时，析构函数自动运行，程序按需分配资源，通常无须当心何时释放这些资源</p>
<p>在析构函数中，先执行函数体，然后销毁成员。按初始化顺序的<strong>逆序</strong>销毁。释放对象在生存期分配的所有资源。<br>析构部分式隐式的，成员销毁时完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型成员没有析构函数，什么都不需要做。<br>隐式销毁内置指针类型的成员不会delete它所指地对象。</p>
<p>调用析构函数的时机：</p>
<ul>
<li>变量离开其作用域时</li>
<li>对象被销毁，成员被销毁</li>
<li>容器被销毁</li>
<li>动态分配的对象，对指向它的指针应用delete时</li>
<li>临时对象，创建它的完整表达式结束时被销毁</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506201821.png"></p>
<p>未定义时，编译器会为它定义一个合成析构函数，析构函数体自身不直接销毁成员，成员时在析构函数体执行后隐式销毁的。</p>
<p>如果一个类需要自定义析构函数，几乎肯定的是，也需要自定义拷贝赋值运算符和拷贝构造函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203014.png"></p>
<h4 id="x3D-default"><a href="#x3D-default" class="headerlink" title="&#x3D;default"></a>&#x3D;default</h4><p>使用&#x3D;default来显式地要求编译器生成合成的版本<br>当我们使用&#x3D;default时，合成的函数会被隐式地声明为inline</p>
<p>我们只能对具有合成版本的成员函数使用&#x3D;default</p>
<h4 id="x3D-delete"><a href="#x3D-delete" class="headerlink" title="&#x3D;delete"></a>&#x3D;delete</h4><p>我们可以为任何函数指定&#x3D;delete（除了析构函数）<br>&#x3D;delete函数：虽然我们声明了它们，但不能以任何方式使用它们。<br>&#x3D;delete主要用于禁止拷贝控制成员，如果希望引导函数匹配过程，删除函数有时也是有用的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203438.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203413.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203743.png"></p>
<p>尽可能使用&#x3D;delete来阻止拷贝，而不应该声明为private</p>
<h4 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204218.png"></p>
<p><strong>行为像值的类</strong>：每个类的对象都有自己的实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204605.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204742.png"></p>
<p><strong>行为像指针的类</strong>：所有类的对象共享类的资源，比如shared_ptr。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211340.png"></p>
<p>主要的不同体现在拷贝构造函数中，析构函数和拷贝赋值运算符依据引用计数有所改变</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211509.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211603.png"></p>
<h4 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h4><p>对于重拍元素顺序的算法，定义swap时非常重要的。<br>如果一个类定义了自己的swap，那么算法将使用自定义版本，否则将使用标准库的swap。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211803.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211925.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506212016.png"></p>
<h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>在某些情况下，对象拷贝后就立即被销毁了。这时候，移动而非拷贝对象会大幅度提升性能。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>通过&amp;&amp;来获得右值引用，只能绑定到<strong>一个将要销毁的对象</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506231308.png"></p>
<p>变量是左值，因此我们不能将右值引用绑定到变量上，即使是右值引用类型。</p>
<p>标准库move函数，可以显示地将一个左值转换为对应的右值引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br><span class="line"><span class="comment">// move告诉编译器，将rr1当作右值一样处理</span></span><br><span class="line"><span class="comment">// 除了对rr1赋值或销毁，我们不再使用它</span></span><br></pre></td></tr></table></figure>

<h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数的第一个参数是一个右值引用，保证移后元对象处于一个状态——销毁无害。一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权归属新创建的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//告诉标准库我们的构造函数不抛出任何异常</span></span><br><span class="line"><span class="comment">// 成员初始化接管s的资源</span></span><br><span class="line">:<span class="built_in">elements</span>(s.elements),<span class="built_in">first_free</span>(s.first_free),<span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">  s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 被接收后指针都置为nullptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507001946.png"></p>
<p>在这里，我们检查this 与 rhs的地址是否相同。相同不做任何事情。否则释放已有元素，然后接管右值引用的元素。再把rhs指针赋为nullptr</p>
<p><strong>在移动后，移后源对象必须可析构</strong>。</p>
<h4 id="合成移动操作"><a href="#合成移动操作" class="headerlink" title="合成移动操作"></a>合成移动操作</h4><p>如果一个类定义了拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。<br>只有当一个类<strong>没有定义任何自己版本的拷贝控制成员</strong>，且<strong>类的每个非static数据成员都可以移动</strong>时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507002510.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507002957.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507003227.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507003912.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507004102.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507004122.png"></p>
<h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><p>面向对象程序设计基于三个基本概念：数据抽象、继承、和动态绑定。</p>
<h4 id="数据抽象、继承、动态绑定"><a href="#数据抽象、继承、动态绑定" class="headerlink" title="数据抽象、继承、动态绑定"></a>数据抽象、继承、动态绑定</h4><p><strong>数据抽象</strong>：只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>
<p><strong>继承</strong>：通过继承联系在一起的类构成一种层次关系。通常根部叫做<strong>基类</strong>，直接或间接从基类继承而来叫<strong>派生类</strong>。</p>
<p><strong>动态绑定</strong>：当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。动态绑定即是在运行时选择函数的版本，在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<h4 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h4><p>基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作。</p>
<p>因为在派生类有与基类对应的部分，所以能把派生类的对象当作基类对象来使用，也能将基类指针或引用绑定到派生类对象中的基类部分上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;<span class="comment">// 基类</span></span><br><span class="line">Bulk_quote bulk;<span class="comment">// 派生类</span></span><br><span class="line">Quote *p = &amp;item;<span class="comment">// p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;<span class="comment">// p指向bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;<span class="comment">// r绑定到bulk的Quote部分</span></span><br></pre></td></tr></table></figure>

<p>派生类先初始化基类部分，然后按照声明顺序初始化派生类的成员。</p>
<p>不管从基类中派生出多少个派生类，对于每个<strong>静态成员</strong>来说都只存在<strong>唯一</strong>的实例。</p>
<p>静态成员遵循通用的访问控制规则</p>
<p><strong>防止继承</strong>，即在类名后跟一个关键字final</p>
<p>我们可以将<strong>基类的指针（内置或智能）或引用绑定到派生类对象</strong>上。例如，可以用Quote&amp;指向一个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给一个Quote*</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态类型在编译时就已知，是变量声明时的类型或表达式生成的类型</span></span><br><span class="line"><span class="comment">// 动态类型则是变量或表达式表示的内存中的对象的类型，运行时才知道</span></span><br><span class="line"><span class="type">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line"><span class="comment">// item的静态类型是Quote&amp;</span></span><br><span class="line"><span class="comment">// 它的动态类型依赖于item绑定的实参</span></span><br><span class="line"><span class="comment">// 如果传递一个Bulk_quote，则item动态类型则是Bulk_quote</span></span><br><span class="line"><span class="comment">// 如果表达式既不是引用也不是指针，动态类型和静态类型永远一致。</span></span><br><span class="line"><span class="comment">// 比如Quote类型变量永远是一个Quote对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在基类向派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生了对象上</span></span><br><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;</span><br><span class="line">Bulk_quote&amp; bulkRef = base;</span><br><span class="line"><span class="comment">// 以上都是错误的，不能将基类转化为派生类</span></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;<span class="comment">// 正确，动态类型是Bulk_quote</span></span><br><span class="line">Bulk_quote *bulkP = itemP;<span class="comment">// 错误，不能将基类转化成派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用dynamic_cast,如果在基类中含有一个或多个虚函数</span></span><br><span class="line"><span class="comment">// 如果已知某个基类转化派生类是安全的，可以用static_cast</span></span><br></pre></td></tr></table></figure>

<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分会被忽略，也就是被切掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507144244.png"></p>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>动态绑定<strong>只会在我们通过指针或引用调用虚函数</strong>时才会发生。如果通过一个普通类型（非引用非指针）的表达式调用虚函数，在编译时就会将表达式的把呢不能确定下来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507152318.png"></p>
<p>基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507152800.png"></p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507153006.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drived</span> : <span class="keyword">public</span> Base&#123;  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();<span class="comment">//递归调用自己</span></span><br><span class="line">    Base::<span class="built_in">foo</span>();<span class="comment">//明确告诉编译器，调用Base::foo而不是自己</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507154155.png"></p>
<p>含有纯虚函数的类是抽象基类，我们<strong>不能创建一个抽象基类的对象</strong>。可以定义它的派生类，前提是这些类覆盖了纯虚函数。</p>
<p>派生类只初始化它的直接基类</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507155227.png"></p>
<h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507161237.png"></p>
<p>上述表示，如果友元通过派生类来访问protected成员是可以的。但是友元直接访问protected成员就不可以</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37051531/answer/70216882">C++派生类的成员或友元只能通过派生类对象来访问基类的受保护成员? - 邱昊宇的回答 - 知乎</a></p>
<p>在类中用using声明改变访问级别，当然派生类只能为访问到的名字提供using</p>
<p>struct 默认public继承<br>class 默认private继承</p>
<h4 id="继承的类作用域"><a href="#继承的类作用域" class="headerlink" title="继承的类作用域"></a>继承的类作用域</h4><p>派生类的作用域位于基类作用域之内，如果一个名字在派生类中无法解析，则会在外层基类作用域中寻找该名字的定义。</p>
<p>在编译时进行<strong>名字查找</strong>，意味着能够使用哪些成员由静态类型决定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507164433.png"></p>
<p>派生类会覆盖基类的同名成员，我们可以通过作用域运算符来使用基类成员。</p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507164558.png"></p>
<p><strong>名字查找</strong>,假设调用obj-&gt;foo():</p>
<ul>
<li>首先确定obj的静态类型</li>
<li>然后在obj的静态类型对应的类中查找foo。找不到，就一直往继承链上找。如果一直找不到，就报错。</li>
<li>一旦找到foo，进行类型检查</li>
<li>如果合法，则会根据是否是虚函数进行调用：1.如果时虚函数，则依据obj的动态类型的版本;2.如果不是，直接调用</li>
</ul>
<p>我们可以看到<strong>名字查找先于类型检查,所以会有以下结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507165048.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507165828.png"></p>
<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507211827.png"></p>
<h4 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507212141.png"></p>
<p><strong>派生类中删除的拷贝控制与基类的关系</strong>：</p>
<ul>
<li>基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是delete或private，则派生类对应的是delete的。原因是编译器不能使用基类成员来执行这些操作</li>
<li>如果基类中有一个<strong>private或delete的析构函数</strong>，则派生类合成的默认和拷贝构造函数是delete，因为编译器无法销毁派生类对象的基类部分</li>
<li>编译器不会合成一个delete移动操作。当我们使用&#x3D;default，如果基类中对应是delete或private，则派生类中是delete，原因是派生类基类部分不可移动。同样，基类析构函数delete或private，则派生类移动构造函数也是delete</li>
</ul>
<p><strong>派生类拷贝或移动构造函数</strong>：</p>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中<strong>显式地使用</strong>基类的拷贝（或移动）构造函数</p>
<p><strong>派生类赋值运算符</strong>：同理，复制运算符也要显式地为基类部分赋值</p>
<p><strong>派生类析构函数</strong>：销毁顺序与创建顺序相反，先执行派生类析构函数，再执行基类的。</p>
<p>如果构造函数或析构函数调用了某个虚函数，则应该执行与类型相对应的虚函数版本。</p>
<h4 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507213936.png"></p>
<p>using声明不会改变构造函数的访问级别。<br>using声明不能指定explicit或constexpr，继承的构造函数如果有这些属性，那么也有。<br>构造函数的默认实参不会被继承。相反，会获得多个继承。比如，基类有一个接受两个形参的构造函数，第二个含有默认实参，则派生类获得两个构造函数，一个接受两个形参，一个只接受一个形参，对应没有默认值的形参。</p>
<p>如果基类含有几个构造函数，大多数派生类会继承这些构造函数。有两个例外情况：</p>
<ul>
<li>派生类继承一部分构造函数，为其他构造函数定义自己的版本。</li>
<li>默认、拷贝和移动构造函数不会被继承，会按照正常规则被合成。</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Blog</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">字面值常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">2.5.</span> <span class="toc-text">声明与定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text">指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">4.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">const与引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">4.2.</span> <span class="toc-text">const与指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E4%B8%8E%E5%BA%95%E5%B1%82const"><span class="toc-number">4.3.</span> <span class="toc-text">顶层与底层const</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#constexpr-%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">constexpr 和常量表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">5.1.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">5.2.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype"><span class="toc-number">5.3.</span> <span class="toc-text">decltype</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text">左值右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">求值顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E4%BD%99"><span class="toc-number">7.3.</span> <span class="toc-text">取余</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i-%E8%BF%98%E6%98%AF-i"><span class="toc-number">7.4.</span> <span class="toc-text">++i 还是 i++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.5.</span> <span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.6.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.7.</span> <span class="toc-text">sizeof 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.8.</span> <span class="toc-text">显式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTTI-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">7.9.</span> <span class="toc-text">RTTI 运行时类型识别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.</span> <span class="toc-text">局部对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">传值参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">8.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">8.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr-%E5%87%BD%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">constexpr 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.7.</span> <span class="toc-text">实参类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">8.8.</span> <span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">初步探索类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">9.3.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84inline"><span class="toc-number">9.4.</span> <span class="toc-text">类的inline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">9.5.</span> <span class="toc-text">可变数据成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">9.6.</span> <span class="toc-text">类的静态成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">10.</span> <span class="toc-text">c++标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">顺序容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">容器迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">10.3.</span> <span class="toc-text">容器定义和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%92%8Cswap"><span class="toc-number">10.4.</span> <span class="toc-text">赋值和swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%AF%94%E8%BE%83"><span class="toc-number">10.5.</span> <span class="toc-text">容器比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">10.6.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">10.7.</span> <span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">10.8.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">10.9.</span> <span class="toc-text">改变容器大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-%E6%93%8D%E4%BD%9C"><span class="toc-number">10.10.</span> <span class="toc-text">string 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">10.11.</span> <span class="toc-text">容器适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">lambada表达式与泛型算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambada-%E6%8D%95%E8%8E%B7"><span class="toc-number">11.2.</span> <span class="toc-text">lambada 捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">12.</span> <span class="toc-text">动态内存和智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-number">12.1.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">12.2.</span> <span class="toc-text">直接管理内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr"><span class="toc-number">12.3.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-number">12.4.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">13.</span> <span class="toc-text">拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">13.2.</span> <span class="toc-text">拷贝赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-default"><span class="toc-number">13.4.</span> <span class="toc-text">&#x3D;default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-delete"><span class="toc-number">13.5.</span> <span class="toc-text">&#x3D;delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">13.6.</span> <span class="toc-text">拷贝控制和资源管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">13.7.</span> <span class="toc-text">交换操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-number">14.</span> <span class="toc-text">对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">14.1.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">移动构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.3.</span> <span class="toc-text">移动赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">14.4.</span> <span class="toc-text">合成移动操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">15.</span> <span class="toc-text">面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">15.1.</span> <span class="toc-text">数据抽象、继承、动态绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">基类和派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">15.4.</span> <span class="toc-text">抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">15.5.</span> <span class="toc-text">访问控制与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">15.6.</span> <span class="toc-text">继承的类作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">15.7.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">15.8.</span> <span class="toc-text">合成拷贝控制与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">15.9.</span> <span class="toc-text">继承的构造函数</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/04/15/c-primer/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/04/15/c-primer/&text=c++ primer"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/04/15/c-primer/&is_video=false&description=c++ primer"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=c++ primer&body=Check out this article: http://example.com/2023/04/15/c-primer/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/04/15/c-primer/&title=c++ primer"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/04/15/c-primer/&name=c++ primer&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/04/15/c-primer/&t=c++ primer"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    TALENTSTREAM
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Blog</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
