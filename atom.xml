<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TALENTSTREAM</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-07T08:51:44.779Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TALENTSTREAM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Moving From Next to Cactus</title>
    <link href="http://example.com/2024/01/07/Moving-From-Next-to-Cactus/"/>
    <id>http://example.com/2024/01/07/Moving-From-Next-to-Cactus/</id>
    <published>2024-01-07T08:50:29.000Z</published>
    <updated>2024-01-07T08:51:44.779Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>TSP</title>
    <link href="http://example.com/2023/05/28/TSP/"/>
    <id>http://example.com/2023/05/28/TSP/</id>
    <published>2023-05-28T11:01:14.000Z</published>
    <updated>2024-01-07T07:46:38.663Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>TSP全称为Travelling Salesman Problem（旅行商问题），通俗而言，它是指对于给定的一系列城市和每对城市之间的距离，找到访问每一座城市仅一次并回到起始城市的最短回路。<br>由于求精确解的时间复杂度很大，衍生出了很多近似算法，不过在这里不讨论，我们在这里只讨论精确解DP算法</p></blockquote><ul><li>有n个城市，从起点 0 开始游历每一个城市，只访问每个城市一次，最后回到起点，所需要的最短路径是多少？</li><li>定义dp[S][i] ,S为集合即已经走过的城市，但是从0个城市到所有城市的集合太多了，所以我们采用状态压缩，便于遍历。dp[S][i] 即在i点结束，集合S中每个点恰好走过一次时的最短路长度</li><li>所以最终答案是 min(dp[S][i]),S为所有城市，i的话每个点都可能是终点。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230528224632.png"></p><p>容易得出以上状态转移方程，即dp[S][i] &#x3D; min(不包括 i 的集合 + j 到 i 的距离)<br>上图有些错误，应该是 <strong>dp[S-{i}]</strong> ,下面看代码</p><p><strong>参考代码，模板</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[n][n] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="number">15</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> minn = INT_MAX;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nowstate = <span class="number">1</span>; nowstate &lt; (<span class="number">1</span> &lt;&lt; n); ++nowstate) <span class="comment">// 集合变化</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[nowstate] = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX);<span class="comment">// 初始化dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nowstate &amp; (<span class="number">1</span> &lt;&lt; j))) <span class="comment">// 如果现在的状态包括 j 这个城市</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> preState = nowstate ^ (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                <span class="keyword">if</span> (preState == <span class="number">0</span>) <span class="comment">// 如果集合只包括 j 这个城市 那么dp值为 d[0][j] 假设起点是0的话</span></span><br><span class="line">                    dp[nowstate][j] = d[<span class="number">0</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 集合不止 j 这个城市 , 遍历 0 ~ n 城市，如果前置状态也就是 S - &#123;j&#125; 这个集合都没更新的话就不用理了，如果更新了就进行比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[preState][i] &lt; INT_MAX &amp;&amp; dp[preState][i] + d[i][j] &lt; dp[nowstate][j])</span><br><span class="line">                            dp[nowstate][j] = dp[preState][i] + d[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][j] + d[<span class="number">0</span>][j]); <span class="comment">// 如果是要求环就加上 d[0][j] 如果不是的话就不用加</span></span><br><span class="line">    cout &lt;&lt; minn &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>943.最短超级串</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calu</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">shortestSuperstring</span><span class="params">(vector&lt;string&gt; &amp;words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            graph[i][j] = <span class="built_in">calu</span>(words[i], words[j]);</span><br><span class="line">            graph[j][i] = <span class="built_in">calu</span>(words[j], words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">path</span>(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> now_state = <span class="number">1</span>; now_state &lt; (<span class="number">1</span> &lt;&lt; n); ++now_state)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[now_state] = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((now_state &amp; (<span class="number">1</span> &lt;&lt; j)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> pre_state = now_state ^ (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                <span class="keyword">if</span> (pre_state == <span class="number">0</span>)</span><br><span class="line">                    dp[now_state][j] = words[j].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[pre_state][i] &lt; INT_MAX &amp;&amp; dp[pre_state][i] + graph[i][j] &lt; dp[now_state][j])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[now_state][j] = dp[pre_state][i] + graph[i][j];</span><br><span class="line">                            path[now_state][j] = i;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last = <span class="number">-1</span>, minn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &lt; minn)</span><br><span class="line">        &#123;</span><br><span class="line">            minn = dp[i][j];</span><br><span class="line">            last = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cur = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(last);</span><br><span class="line">        <span class="type">int</span> temp = cur;</span><br><span class="line">        cur ^= (<span class="number">1</span> &lt;&lt; last);</span><br><span class="line">        last = path[temp][last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = s.<span class="built_in">top</span>();</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    result += words[i];</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        result += (words[j].<span class="built_in">substr</span>(words[j].<span class="built_in">size</span>() - graph[i][j]));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calu</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">rfind</span>(a.<span class="built_in">substr</span>(i), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> b.<span class="built_in">size</span>() - (a.<span class="built_in">size</span>() - i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; words&#123;<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">shortestSuperstring</span>(words);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://leetcode.com/problems/find-the-shortest-superstring/solutions/194932/travelling-salesman-problem/">Leetcode -Travelling Salesman Problem</a></li><li><a href="https://zhuanlan.zhihu.com/p/609551220">开学算法练习—状态压缩DP解决TSP问题</a></li><li><a href="https://www.geeksforgeeks.org/travelling-salesman-problem-using-dynamic-programming/">Travelling Salesman Problem using Dynamic Programming</a></li><li><a href="https://www.luogu.com.cn/blog/Starlight237/solution-p1433">题解 P1433 【吃奶酪】</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;TSP全称为Travelling Salesman Problem（旅行商问题），通俗而言，它是指对于给定的一系列</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LRU &amp; TopK</title>
    <link href="http://example.com/2023/05/26/LRU-TopK/"/>
    <id>http://example.com/2023/05/26/LRU-TopK/</id>
    <published>2023-05-26T13:54:41.000Z</published>
    <updated>2024-01-07T07:46:23.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><blockquote><p>最近最少使用(Least Recently Used) ，加入新的将最少使用的元素淘汰掉</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230526231747.png"></p><p>两种操作：</p><ul><li>当访问时，如果有就将访问的挪到头</li><li>当加入时，将新的挪到头，如果链表满了，将尾移除</li></ul><p>O(1)操作头尾元素，用双向链表，O(1)时间访问用哈希表</p><p><strong>手搓双向链表实现</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DLNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> key,value;</span><br><span class="line">        DLNode* prev,*post;</span><br><span class="line">        <span class="built_in">DLNode</span>(<span class="type">int</span> k, <span class="type">int</span> v): <span class="built_in">key</span>(k),<span class="built_in">value</span>(v),<span class="built_in">prev</span>(<span class="literal">nullptr</span>),<span class="built_in">post</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;*head,*tail;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,DLNode*&gt; hashmap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity):<span class="built_in">capacity</span>(capacity) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLNode</span>(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLNode</span>(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        head-&gt;post = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(DLNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cur-&gt;post-&gt;prev = cur-&gt;prev;</span><br><span class="line">        cur-&gt;prev-&gt;post = cur-&gt;post;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(DLNode* cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cur-&gt;post = head-&gt;post;</span><br><span class="line">        cur-&gt;prev = head;</span><br><span class="line">        head-&gt;post-&gt;prev = cur;</span><br><span class="line">        head-&gt;post = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">count</span>(key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur = hashmap[key];</span><br><span class="line">        <span class="built_in">remove</span>(cur);</span><br><span class="line">        <span class="built_in">insert</span>(cur);</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">count</span>(key) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = hashmap[key];</span><br><span class="line">            cur-&gt;value = value;</span><br><span class="line">            <span class="built_in">remove</span>(cur);</span><br><span class="line">            <span class="built_in">insert</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap.<span class="built_in">size</span>() == capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> leastUse = tail-&gt;prev;</span><br><span class="line">                <span class="built_in">remove</span>(leastUse);</span><br><span class="line">                hashmap.<span class="built_in">erase</span>(leastUse-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> leastUse;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> cur = <span class="keyword">new</span> <span class="built_in">DLNode</span>(key,value);</span><br><span class="line">            hashmap[key] = cur;</span><br><span class="line">            <span class="built_in">insert</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优雅的STL版本</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity): <span class="built_in">capacity</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(key) == map.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> key_value = *map[key];</span><br><span class="line">        cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        cache.<span class="built_in">push_front</span>(key_value);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> key_value.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(key) != map.<span class="built_in">end</span>()) cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cache.<span class="built_in">size</span>() == capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            map.<span class="built_in">erase</span>(cache.<span class="built_in">back</span>().first);</span><br><span class="line">            cache.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h3><blockquote><p>字面意思，就是求无序数组的第k大的数</p></blockquote><h4 id="最大值最小值"><a href="#最大值最小值" class="headerlink" title="最大值最小值"></a>最大值最小值</h4><p>先从寻找最大值最小值开始，直接遍历也就是O(n)的时间复杂度。</p><p><strong>伪代码</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">min = A[1]</span><br><span class="line">for i = 2 to A.length </span><br><span class="line">    if min &gt; A[i] min = A[i]</span><br><span class="line"></span><br><span class="line"># 上述伪代码一眼O(n)</span><br><span class="line"># 如果求同时最大最小值，可以稍微优化一下，从每个数与min 和 max 比较，总共一轮是两次的比较，优化到3/2次比较</span><br><span class="line"></span><br><span class="line">min = A[1] vs A[2] </span><br><span class="line">max = A[1] vs A[2]</span><br><span class="line">for i = 3 to A.length </span><br><span class="line">    if(A[i] &lt; A[i + 1])</span><br><span class="line">        if(min &gt; A[i]) min = A[i]</span><br><span class="line">        if(max &lt; A[i + 1]) max = A[i + 1]</span><br><span class="line">    else </span><br><span class="line">        ...</span><br><span class="line">    i += 2</span><br><span class="line"></span><br><span class="line"># 这样子成对处理就会优化到总共 3n/2 - 2 次比较</span><br></pre></td></tr></table></figure><h4 id="TopK-1"><a href="#TopK-1" class="headerlink" title="TopK"></a>TopK</h4><ul><li>在这里我们找第 k 小的数</li><li>利用快速排序的partition思想</li><li>当partition分出来的 i &lt; k 时，也就是我们找到第 i 小的数，我们需要在 i + 1 ~ n中找第k小的数。当 i &gt; k 时，我们需要在 1 ~ i - 1中找第k小的数。</li><li>如果 i &#x3D;&#x3D; k 说明刚好找到</li><li>partition 的思想就是让 i 左边的数都小于 i 右边的数都大于 i ，不care i 左右两边内部的顺序，只care i 的位置。</li></ul><p><strong>期望时间复杂度</strong>为O(n)，假设每次都是刚好分半, 有可能还更小 T(n) + T(n&#x2F;2) + T(n&#x2F;4) +… T(1) 也就是等积数列求和为 T(2n) 所以为O(n)</p><p><strong>最坏情况</strong>为O(n^2)，如果很不幸每次都是找到一组的最大元素进行partition 就会造成 T(n) + T(n - 1) + T(n - 2) + .. T(1) 的情况 最后为T(n^2),所以用random划分来尽可能地避免该情况</p><p><strong>伪代码</strong>:算法导论中第七章的快排的partition十分优雅，可以看看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RandomPartition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">rand</span>()%(r - l + <span class="number">1</span>) + l;</span><br><span class="line">    std::<span class="built_in">swap</span>(nums[q],nums[r]);</span><br><span class="line">    <span class="keyword">auto</span> x = nums[r];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= x)</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopK</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">RandomPartition</span>(nums, l, r);</span><br><span class="line">    <span class="keyword">if</span> (i == k)</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> i &lt; k ? <span class="built_in">TopK</span>(nums, i + <span class="number">1</span>, r, k) : <span class="built_in">TopK</span>(nums, l, i - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">TopK</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;LRU&quot;&gt;&lt;a href=&quot;#LRU&quot; class=&quot;headerlink&quot; title=&quot;LRU&quot;&gt;&lt;/a&gt;LRU&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;最近最少使用(Least Recently Used) ，加入新的将最少使用的元素淘汰掉&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Topological Sorting</title>
    <link href="http://example.com/2023/05/25/Topological-Sorting/"/>
    <id>http://example.com/2023/05/25/Topological-Sorting/</id>
    <published>2023-05-25T13:57:36.000Z</published>
    <updated>2024-01-07T07:46:34.827Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote><p>Topological Sorting(拓扑排序) 主要用于有向无环图（DAG），用来排序点的先后关系或者判断该图是否有环</p></blockquote><ul><li>将所有入度为0的点放入栈或队列中</li><li>然后遍历栈中的点，将点的出度边删除</li><li>然后重复前两部直到没有点可以放入栈中</li><li>当出栈数 &#x3D;&#x3D; 总点数，说明是DAG、</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 力扣207</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses)</span></span>;<span class="comment">// 计算每个点的入度</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; edgeMap;<span class="comment">// 存表，在这里不需要排序所以用unordered_map</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> prerequisite : prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            ++inDegree[prerequisite[<span class="number">0</span>]];</span><br><span class="line">            edgeMap[prerequisite[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) </span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环二三步</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ++count;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; nextCourses = edgeMap[now];</span><br><span class="line">            <span class="keyword">if</span>(!nextCourses.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nextCourses.<span class="built_in">size</span>(); ++i) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 删出度边</span></span><br><span class="line">                    <span class="keyword">if</span>(--inDegree[nextCourses[i]] == <span class="number">0</span>) q.<span class="built_in">push</span>(nextCourses[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == numCourses) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://leetcode.cn/problems/course-schedule/">leetcode - 207. 课程表</a></li><li><a href="https://zhuanlan.zhihu.com/p/339709006">拓扑排序详解 通俗易懂</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Topological Sorting(拓扑排序) 主要用于有向无环图（DAG），用来排序点的先后关系或者判断该图</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://example.com/2023/05/25/Trie/"/>
    <id>http://example.com/2023/05/25/Trie/</id>
    <published>2023-05-25T12:23:41.000Z</published>
    <updated>2024-01-07T07:46:36.768Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote><p>Trie(字典树) 是一种树形结构，用于高效存储和检索字符串集中的键。</p></blockquote><ul><li>Trie 是一个多叉树，通常是英文单词，有26个字母为26叉</li><li>我们只要存储子节点，和一个bool变量来判断到达该节点时是否构成一个单词集里的词</li><li>通常有Insert和Search两个函数</li></ul><p>假设有单词表有n个单词，单词最长长度为m</p><table><thead><tr><th>Operation</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>Insertion</td><td>O(m)</td><td>O(n*m)</td></tr><tr><td>Searching</td><td>O(m)</td><td>O(1)</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230525202618.png"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHILDREN_SIZE = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isEndOfWord; <span class="comment">// 该节点是否是一个单词的结尾</span></span><br><span class="line">    std::vector&lt;TrieNode *&gt; children;<span class="comment">// 该节点的子节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isEndOfWord</span>(<span class="literal">false</span>), <span class="built_in">children</span>(<span class="number">26</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(std::string word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(std::string word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string keys[] = &#123;<span class="string">&quot;the&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;there&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;answer&quot;</span>, <span class="string">&quot;any&quot;</span>, <span class="string">&quot;by&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;bye&quot;</span>, <span class="string">&quot;their&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *obj = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> key : keys)</span><br><span class="line">        obj-&gt;<span class="built_in">Insert</span>(key);</span><br><span class="line"></span><br><span class="line">    std::string words[] = &#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;these&quot;</span>,<span class="string">&quot;thire&quot;</span>,<span class="string">&quot;their&quot;</span>,<span class="string">&quot;th&quot;</span>,<span class="string">&quot;thaw&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> output[][<span class="number">32</span>] = &#123;<span class="string">&quot;Not present in trie&quot;</span>, <span class="string">&quot;Present in trie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : words)</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; <span class="string">&quot; --- &quot;</span> &lt;&lt; output[obj-&gt;<span class="built_in">Search</span>(word)] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie.cpp             output</span></span><br><span class="line"><span class="comment">// the --- Present in trie</span></span><br><span class="line"><span class="comment">// these --- Not present in trie</span></span><br><span class="line"><span class="comment">// thire --- Not present in trie</span></span><br><span class="line"><span class="comment">// their --- Present in trie</span></span><br><span class="line"><span class="comment">// th --- Not present in trie</span></span><br><span class="line"><span class="comment">// thaw --- Not present in trie</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Trie(字典树) 是一种树形结构，用于高效存储和检索字符串集中的键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图形学-一些额外细节</title>
    <link href="http://example.com/2023/05/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E4%B8%80%E4%BA%9B%E9%A2%9D%E5%A4%96%E7%BB%86%E8%8A%82/"/>
    <id>http://example.com/2023/05/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E4%B8%80%E4%BA%9B%E9%A2%9D%E5%A4%96%E7%BB%86%E8%8A%82/</id>
    <published>2023-05-04T13:27:27.000Z</published>
    <updated>2024-01-07T07:45:38.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>系统的学习完图形学发现还有一些小细节有所疏漏，在此记录</p><h3 id="变换法线向量"><a href="#变换法线向量" class="headerlink" title="变换法线向量"></a>变换法线向量</h3><h4 id="法线变换矩阵"><a href="#法线变换矩阵" class="headerlink" title="法线变换矩阵"></a>法线变换矩阵</h4><p>为了进行光照计算，一般要使用到模型的顶点的法线进行计算。局部坐标经过矩阵M转化到世界坐标，然后再通过矩阵V转化到观察空间。则<strong>观察空间的顶点位置则变为M<em>V</em>p(顶点坐标)，而顶点法线却不能直接直接由M<em>V</em>n（顶点法线）计算</strong>，因为模型发生non-uniform缩放时，经过M<em>V</em>n变换后的法线不在与模型表面垂直。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504213856.png"></p><p>用于法线变换的矩阵应该是：</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504214214.png"></p><p>如果是在世界坐标上计算，则法线变换的矩阵为</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504214249.png"></p><h4 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h4><p>我们设T为切向向量，N为法线向量，P2，P1为三角形边上的某两个点,带’的变量为变换后的坐标</p><p>-&gt; T &#x3D; P2 - P1 </p><p>-&gt; MVT &#x3D; MV(P2-P1)</p><p>-&gt; MVT &#x3D; MVP2 - MVP1</p><p>从而得到 T’ &#x3D; P2’ - P1’</p><p>因为切线向量和法线向量永远垂直，所以TN &#x3D; 0<br>设N’ &#x3D; G * N(G为我们要解出的法线变换矩阵)</p><p>-&gt; N’T’ &#x3D; (GN)(MVT) &#x3D; 0 </p><p>由于GN时列向量，所以做点积时要转置成行向量</p><p>-&gt; (GN)^转置 * (MVT) &#x3D; N^转置 G^转置 MVT &#x3D; 0</p><p>为了让N^转置 *T &#x3D; 0 则 G^转置MV &#x3D; I(单位矩阵)</p><p>-&gt; G &#x3D; ((MV)^-1)^转置</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/72734738">渲染管线中的法线变换矩阵</a></p><h3 id="透视矫正插值"><a href="#透视矫正插值" class="headerlink" title="透视矫正插值"></a>透视矫正插值</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>我们的重心坐标往往都是在屏幕空间下得到的，如果使用屏幕空间下的重心坐标进行插值会造成一定的误差，与在观察空间时不一样的。因为到了屏幕空间，插值运算就不会考虑近大远小了。</p><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504223959.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504224109.png"></p><p>我们对A,B点画x轴方向的线交于OC</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504224210.png"></p><p>易得(t&#x2F;1-t) &#x3D; AG&#x2F;BK &#x3D; (ac<em>Z1&#x2F;d)&#x2F;(bc</em>Z2&#x2F;d) &#x3D; sZ1&#x2F;(1-m)&#x2F;Z2 ,对两边用倒数进行处理得到</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504224358.png"></p><p>再将该式子代入(6)得</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504224429.png"></p><p>上述是两个点的计算，推广到重心坐标，得</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504224456.png"></p><p>然后进行推广到任意属性（法线向量，纹理坐标等）</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504224934.png"></p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/144331875">计算机图形学六：透视矫正插值和图形渲染管线总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/403259571">图形学 - 关于透视矫正插值那些事</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;系统的学习完图形学发现还有一些小细节有所疏漏，在此记录&lt;/p&gt;
&lt;h3 id=&quot;变换法线向量&quot;&gt;&lt;a href=&quot;#变换法线向量&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图形学-光栅化</title>
    <link href="http://example.com/2023/05/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <id>http://example.com/2023/05/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%85%89%E6%A0%85%E5%8C%96/</id>
    <published>2023-05-03T05:30:56.000Z</published>
    <updated>2024-01-07T07:45:33.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图形管线（graphics-pipeline）总览"><a href="#图形管线（graphics-pipeline）总览" class="headerlink" title="图形管线（graphics pipeline）总览"></a>图形管线（graphics pipeline）总览</h3><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503140547.png"></p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><h4 id="绘制线条（midpoint-Bresenham算法）"><a href="#绘制线条（midpoint-Bresenham算法）" class="headerlink" title="绘制线条（midpoint-Bresenham算法）"></a>绘制线条（midpoint-Bresenham算法）</h4><p>我们首先知道任何一条一维直线可以用 f(x,y) &#x3D; ax + by + c &#x3D; 0 ,将点(x0,y0) 和(x1,y1)代入得以下结果</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503214800.png"></p><p>我们在这里先考虑斜率在(0,1]的情况，之后类推到 (-∞,-1],(-1,0],(1,∞)</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503215239.png"></p><p>在基于斜率在0-1的情况下，如上图所示，假设我们现在要画橙色格子，只可能是在最后一个蓝色格子的右边或者右上，如果直线高于黑色圆点就画在右上，如果低于黑色圆点就画在右边。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503215544.png"></p><p>伪代码如上，那么some condition是什么，我们知道每个像素坐标是方格的中间，那么黑色原点应该是最后一个蓝色方格的(x+1,y+0.5),所以得到f(x+1,y+0.5) &gt; 0 时，也就是中点在直线上面，那就把橙色格子画在右边。相反就画在右上，如果相等，取决于自己，影响不大。</p><p>上面就是比较好的直线绘制算法，但是有一个问题，我们每次都要进行一次F(x,y)的计算，在现在光三角形面数就有几百万的模型上，无疑是十分消耗资源的。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503215938.png"></p><p>在上式，我们找到所对应的关系，我们一开始就将(x0+1,y0+0.5)代入，后面每次计算我们只要累加上述图片的函数后面的一部分就可以省下很多次f(x,y)的计算。因此我们得到以下改进过的伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503220154.png"></p><p>接着我们推广不同的角度的直线，也就是将x，y转化为斜率（0，1）的范围，也就是进行翻转等。下面是milo yip实现的一份很漂亮的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bresenham</span><span class="params">(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = <span class="built_in">abs</span>(x1 - x0), sx = x0 &lt; x1 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> dy = <span class="built_in">abs</span>(y1 - y0), sy = y0 &lt; y1 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> err = (dx &gt; dy ? dx : -dy) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setpixel = draw</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">setpixel</span>(x0, y0), x0 != x1 || y0 != y1) &#123;</span><br><span class="line">        <span class="type">int</span> e2 = err;</span><br><span class="line">        <span class="keyword">if</span> (e2 &gt; -dx) &#123; err -= dy; x0 += sx; &#125;</span><br><span class="line">        <span class="keyword">if</span> (e2 &lt;  dy) &#123; err += dx; y0 += sy; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三角形的光栅化"><a href="#三角形的光栅化" class="headerlink" title="三角形的光栅化"></a>三角形的光栅化</h4><p>有了直线绘制算法，我们就可以画出一个三角形了，但是如何涂满三角形内部呢。最简单的做法就是判断每个像素点是否在内部，利用叉乘的性质，我们事先知道想要光栅化的三角形的三个顶点P0，P1，P2，以及检测点Q。 只要分别计算 P0P1 × P0Q , P1P2 × P1Q , P2P0 × P2Q ，三者同号就说明必然处于三角形内部，不同号则说明该点一定在三角形外部。但是对全部像素点还是很浪费，可以用包围盒的思路，快速算出包围盒然后对包围盒里的点进行判断即可。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503221856.png"></p><p>因为每个在三角形的点都可以用重心表示法表示出来</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503223329.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503223237.png"></p><p>只要点在里面，我们算出来的值就会 &gt; 0，利用这个性质以及，任意两个二维向量组合成矩阵的行列式的绝对值，为这两个向量所围成平行四边形的面积，不难得出</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503223729.png"></p><p>我们尝试将叉乘列出来，发现巧妙的是，正好对应方程式</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503222945.png"></p><p>发现很符合上面求α，β，γ的式子，代入获得伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503223826.png"></p><p>注意到，如果一个点在边上的话，如何解决，毕竟有可能同时在两个三角形上，答案是取决你自己，详见虎书8.1.2。因为如果不画的话，两个三角形将会产生缝隙，如果两个都画的话，如果三角形是透明的，这将导致双重着色。</p><h4 id="Z-buffer算法"><a href="#Z-buffer算法" class="headerlink" title="Z-buffer算法"></a>Z-buffer算法</h4><p>常见的处理前后关系有画家算法和z-buffer算法，前者性能消耗较大已经很少用了，后者很简单，我们设置一个zbuffer数组，绘制三角形的时候如果该三角形的深度比较小，就覆盖掉zbuffer的值，同时更新该点的颜色。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503225042.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503225034.png"></p><p>即使这样，我们可能会遇到深度冲突的问题，也就是物体z轴相同，会进行闪烁。越接近far平面，depth变化越小，精度变差越容易出现z-fighting问题。<br>避免Z-fighting问题：</p><ul><li>可以将near和 far的距离缩小，同时尽量将near变大一些。</li><li>当然也可以使用精度更高的zbuffer，简单来说就是 float -&gt; double</li></ul><p>参考：<a href="https://zhuanlan.zhihu.com/p/25095708">全面认识Depth - 这里有关于Depth的一切</a></p><h3 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h3><h4 id="逐平面着色-Flat-Shading"><a href="#逐平面着色-Flat-Shading" class="headerlink" title="逐平面着色(Flat Shading)"></a>逐平面着色(Flat Shading)</h4><p>顾名思义，就是以每一个面作为一个着色单位进行着色计算</p><h4 id="逐顶点着色-Per-vertex-Shading-x2F-Gouraud-shading"><a href="#逐顶点着色-Per-vertex-Shading-x2F-Gouraud-shading" class="headerlink" title="逐顶点着色(Per-vertex Shading&#x2F;Gouraud shading)"></a>逐顶点着色(Per-vertex Shading&#x2F;Gouraud shading)</h4><p>顾名思义就是对每一个顶点进行着色计算，顶点法线计算就是由这个点相关的每个面的法线求平均值再进行标准化即可得到,对于内部的点就用重心坐标计算颜色</p><h4 id="逐像素着色-Phong-shading"><a href="#逐像素着色-Phong-shading" class="headerlink" title="逐像素着色(Phong shading)"></a>逐像素着色(Phong shading)</h4><p>就是对每个像素进行着色计算，三角形内部的点同样用重心法进行计算，只不过这次是计算法线，这样子可能要更准确些。</p><h4 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230503233930.png"></p><h3 id="着色模型"><a href="#着色模型" class="headerlink" title="着色模型"></a>着色模型</h3><h4 id="Ambient泛光模型"><a href="#Ambient泛光模型" class="headerlink" title="Ambient泛光模型"></a>Ambient泛光模型</h4><p>即只考虑环境光，这时一个经验模型</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504210946.png"></p><p>其中<br>Ka代表物体表面对环境光的反射率，Ia代表入射环境光的亮度，Ienv存储结果，即人眼所能看到从物体表面反射的环境光的亮度。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504211039.png"></p><h4 id="Lambert漫反射模型-diffuse"><a href="#Lambert漫反射模型-diffuse" class="headerlink" title="Lambert漫反射模型(diffuse)"></a>Lambert漫反射模型(diffuse)</h4><p>就是在Ambient上增加了漫反射项。漫反射便是光从一定角度入射之后从入射点向四面八方反射，且每个不同方向反射的光的强度相等，而产生漫反射的原因是物体表面的粗糙，导致了这种物理现象的发生。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504211346.png"></p><p>只有当入射光线与平面垂直的时候才能接受完整的光，入射角度越倾斜损失的能量越大。<br>除了入射角度，光源与照射点的距离也要考虑，离得越远强度越弱。 </p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504211515.png"></p><p>其中Kd为漫反射系数，I为入射光强，n,l分别如图中所示为法线向量和入射方向，max是为了剔除夹角大于90°的光。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504211558.png"></p><h4 id="Phong反射模型-Specular"><a href="#Phong反射模型-Specular" class="headerlink" title="Phong反射模型(Specular)"></a>Phong反射模型(Specular)</h4><p>phong 反射模型主要是为了计算高光，下图R为光线反射方向，v为人眼观察方向，</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504211732.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504211851.png"></p><p>其中Ks为镜面反射系数，I为入射光强，r为光源到入射点距离，注意这里在max剔除大于90°的光之后，我们还乘了一个指数p，添加该项的原因很直接，因为离反射光越远就越不应该看见反射光，需要一个指数p加速衰减，α为R和v的夹角，当p越大越准确</p><h4 id="Blinn-Phong反射模型"><a href="#Blinn-Phong反射模型" class="headerlink" title="Blinn-Phong反射模型"></a>Blinn-Phong反射模型</h4><p>我们将R和v夹角转化为R的半程向量转化为与h的夹角，得到结果十分近似，同时计算速度变快很多。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504212148.png"></p><h4 id="整体计算公式"><a href="#整体计算公式" class="headerlink" title="整体计算公式"></a>整体计算公式</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230504212203.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;图形管线（graphics-pipeline）总览&quot;&gt;&lt;a href=&quot;#图形管线（graphics-pipeline）总览&quot; class=&quot;headerlink&quot; title=&quot;图形管线（graphics pipeline）总览&quot;&gt;&lt;/a&gt;图形管线（graphi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图形学 几何变换</title>
    <link href="http://example.com/2023/05/02/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
    <id>http://example.com/2023/05/02/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</id>
    <published>2023-05-02T05:11:11.000Z</published>
    <updated>2024-01-07T07:45:35.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在复习图形学理论知识，顺便补一下记录，在这里记录的是比较常见的变换，会有一些比较复杂的地方没有涉及到。在图形学的变换中，对于数学的要求并不是很高，只需要会简单的线性代数矩阵乘法即可。</p><h3 id="2D线性变换-Linear-Transformation"><a href="#2D线性变换-Linear-Transformation" class="headerlink" title="2D线性变换(Linear Transformation)"></a>2D线性变换(Linear Transformation)</h3><p>我们将点坐标以向量作为表示，变换以矩阵表示。两者相乘就是点经过变换后的新位置</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502132310.png"></p><h4 id="缩放变换-Scaling"><a href="#缩放变换-Scaling" class="headerlink" title="缩放变换(Scaling)"></a>缩放变换(Scaling)</h4><p>缩放变换就是原坐标乘以一个数进行变换,设原点为(x,y),新点为(sx * x, sy * y),可以很快反推出矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502132549.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502132346.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502132736.png"></p><h4 id="剪切变换-Shearing"><a href="#剪切变换-Shearing" class="headerlink" title="剪切变换(Shearing)"></a>剪切变换(Shearing)</h4><p>不知道该怎么翻译，应该是将正方形变形为平行四边形的操作。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502132842.png"></p><p>假设只对x进行变换，而不对y进行变换，那么x新坐标即为(1+ay)，稍微反推一下，获取关键坐标(0,0) (a,1),y 没有进行剪切变换。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502133038.png"></p><p>另一种方法可以想为shearing只是对一个轴进行旋转一个角度</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502133409.png"></p><h4 id="旋转变换-Rotation"><a href="#旋转变换-Rotation" class="headerlink" title="旋转变换(Rotation)"></a>旋转变换(Rotation)</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502133613.png"></p><p>假设点a到(0,0)距离为r，那么xa &#x3D; rcosα, ya &#x3D; rsinα所示，我们将a向量旋转到b向量，那么</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502133738.png"></p><p>将xa &#x3D; rcosα, ya &#x3D; rsinα带入后得到</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502133827.png"></p><p>然后我们推出旋转矩阵为</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502133856.png"></p><p>以上是逆时针旋转的矩阵</p><h4 id="对称变换-Reflection"><a href="#对称变换-Reflection" class="headerlink" title="对称变换(Reflection)"></a>对称变换(Reflection)</h4><p>其实跟缩放变换差不多 </p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502134045.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502134020.png"></p><h4 id="变换的组合"><a href="#变换的组合" class="headerlink" title="变换的组合"></a>变换的组合</h4><p>由于矩阵乘法一般不满足交换律，即 A<em>B !&#x3D; B</em>A,所以变换的顺序比较重要</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502134249.png"></p><h3 id="3D线性变换"><a href="#3D线性变换" class="headerlink" title="3D线性变换"></a>3D线性变换</h3><h4 id="scaling"><a href="#scaling" class="headerlink" title="scaling"></a>scaling</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502134720.png"></p><h4 id="rotation"><a href="#rotation" class="headerlink" title="rotation"></a>rotation</h4><p>旋转较二维有所不同，我们只需要了解对应不同轴旋转的矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502134828.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502134727.png"></p><p><strong>绕任意轴旋转</strong>：我们只有绕x，y，z旋转的方法，我们将轴给旋转到x&#x2F;y&#x2F;z上，然后再应用标准旋转矩阵，最后将轴逆旋转回到原先的地方就完成了</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502153826.png"></p><p>接下来我们尝试将将u v w(已知u，任取t方向与u组成平面，利用叉乘特性得到v w) 对应到 x y z </p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502154126.png"></p><h3 id="仿射变换-affine-transformation"><a href="#仿射变换-affine-transformation" class="headerlink" title="仿射变换(affine transformation)"></a>仿射变换(affine transformation)</h3><p>前面一直在讨论线性变换，也就是依据原点(0,0)进行变换，如果我们加上位置变换(Translation)就会让之前的所有矩阵都不成立。为了相同，我们增加一维，让(x,y) -&gt; (x,y,1) 这样子当 x’ &#x3D; m11x + m12y + xt时，就不会打乱之前的线性变换矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502142043.png"></p><p>这样子的向量是不是很熟悉，也就是齐次坐标，最后一维为1是一个坐标，为0时是一个向量，对于其他数字，我们要将坐标进行归一化，也就是(x,y,w) -&gt; (x&#x2F;w,y&#x2F;w,1)</p><p>在三维状态下也是如此</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502142647.png"></p><h3 id="视图变换-Viewing-Transformation"><a href="#视图变换-Viewing-Transformation" class="headerlink" title="视图变换(Viewing Transformation)"></a>视图变换(Viewing Transformation)</h3><p>在之前的变换，我们讨论了如何变换点的位置。现在我们要将现实世界中的点投影在屏幕上，我们将要经历三步</p><ul><li>摄像机变换(eye&#x2F;camera transformation) : 调整摄像机位置，旋转角度，也就是得到<strong>物体与摄像机的相对位置</strong></li><li>投影变换(projection transformation) : 摄像机变换后，得到可视范围物体对于摄像机的相对坐标，之后根据情况选择平行投影或者透视头型，将<strong>三维空间投影至标准二维平面</strong>[-1,1]^2</li><li>视口变换(viewport transformatino) ： 将[-1,1]^2 -&gt; [0,width]<em>[0,height],也就是*<em>将标准平面映射到屏幕分辨率范围上</em></em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502143533.png"></p><h4 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h4><p>先从视口变换入手，视口变换是最简单也是最容易理解的矩阵，将-1 -&gt; 0 ,1 - &gt; width&#x2F;height 也就是简单的缩放变换，然后为了保持原点在屏幕中间，多了一步Translation</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502150436.png"></p><h4 id="正交（Orthographic）投影变换"><a href="#正交（Orthographic）投影变换" class="headerlink" title="正交（Orthographic）投影变换"></a>正交（Orthographic）投影变换</h4><p>正交投影也是简单的缩放变换和位移，我们用一个包围盒围住物体，要注意的是在这里，n &gt; f，因为我们是从-z往物体上看的</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502151041.png"></p><p>由于是空间的变换，容易得到以下矩阵<br>证明过程，先举一个二维的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502151452.png"></p><p>可以发现分三步走，Translate（移动到原点）-&gt;Scale（进行缩放变化）-&gt;Translate（移动到对应的位置）</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502151648.png"></p><p>推广到三维</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502151707.png"></p><p>将[l, r] [t, b] [n, f] 和 [-1, 1]^3 代入得正交矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502151125.png"></p><h4 id="摄像机变换"><a href="#摄像机变换" class="headerlink" title="摄像机变换"></a>摄像机变换</h4><p>虽然说是摄像机变换，但其实是调整物体的位置，将摄像机的坐标轴对应到原世界的x，y，z就行了，问题就变成了将camera的坐标系变到与原世界坐标系重合</p><p>我们先定义摄像机的三个属性</p><ul><li>e(eye position) : 摄像机位置</li><li>g(gaze direction) : 摄像机朝向的角度</li><li>t(view-up vector) : 摄像机朝向角度的正上方向，也就是为了g，t组成一个平面</li></ul><p>然后我们得到摄像机坐标系</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502153229.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502153251.png"></p><p>我们将摄像机变换分成两步</p><ul><li>移动到原点</li><li>通过旋转矩阵将二者坐标系重合</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502153514.png"></p><h4 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h4><p>透视变换就是将原本的包围盒变成一个具有近大远小属性的锥形盒子</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502154621.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502154602.png"></p><p>我们容易得到以下对应关系，但是第三行如何得出，利用近平面和远平面的z坐标不变的性质进行代入</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502154855.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502155145.png"></p><p>现在我们已经得到了包围盒变为锥形盒子的矩阵 P<br>可以很快得到一个等式 <strong>Mper &#x3D; Morth * P</strong><br>也就是说，我们先将包围盒变成 [-1,1] ^ 2 的，然后在这个[-1,1] ^ 2的小正方体进行透视变换，这与先变为锥形盒子再压缩到[-1,1] ^ 2是一样的,得出以下矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230502155553.png"></p><h4 id="简短的总结"><a href="#简短的总结" class="headerlink" title="简短的总结"></a>简短的总结</h4><p>我们在经历过上述计算后，可以得出现实世界到屏幕上的矩阵变换 M &#x3D; Mview * Mper * Mcam * Mmodel</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>Fundamentals of Computer Graphics 4th 第六章第七章</li><li>GAMES101-现代计算机图形学入门-闫令琪 变换部分</li><li><a href="https://zhuanlan.zhihu.com/p/144329075">计算机图形学二：视图变换(坐标系转化，正交投影，透视投影，视口变换)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在复习图形学理论知识，顺便补一下记录，在这里记录的是比较常见的变换，会有一些比较复杂的地方没有涉及到。在图形学的变换中，对于数学的要求并</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++ primer</title>
    <link href="http://example.com/2023/04/15/c-primer/"/>
    <id>http://example.com/2023/04/15/c-primer/</id>
    <published>2023-04-15T13:19:35.000Z</published>
    <updated>2024-01-07T07:46:01.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于面试被狠狠拷打，决定恶补c++。有些概念太长会以图片显示</p><h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418202838.png"></p><p>一些类型选择的建议：</p><ul><li>数值不可能为负时，选用无符号类型</li><li>使用int执行整数运算，如果超过int范围，选用longlong</li><li>算术表达式中不要使用char或bool,只有在存放字符或bool值才使用它们。因为char在有些机器是有符号的，而在一些机器上又是无符号的。</li><li>执行浮点数运算用double，float常常精度不够，而且双精度和单精度的计算代价相差无几。</li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418203722.png"></p><ul><li>将非bool型算术值赋给bool时，为0则结果为false，否则为true</li><li>当bool值给非bool型，为false则结果为0，true 为 1</li><li>当浮点数赋给整数类型时，砍掉小数点后面的</li><li>当整数赋给浮点时，小数部分为0</li><li>当给unsigned赋给一个超出范围的值时，结果是初始值加表示数值总数取模后的余数，在这里就是(-1+256)%256</li><li>当给一个有符号类型一个超出范围的值时，结果时未定义的。程序可能继续工作、可能崩溃，也可能产生垃圾数据。</li></ul><p>当一个算数表达式既有unsigned又有int时，int就会转化为unsigned</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418204711.png"></p><p>当 u &#x3D; 0 时，迭代输出0，然后执行–u，此时 u &#x3D; -1 被自动转化为4294967295，此时会无限循环</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418204946.png"></p><h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><p>以0开头代表八进制数，0x或0X开头代表十六进制，比如：<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205302.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205426.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205542.png"></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>当对象在创建时获得了一个特定值，我们说这个对象被初始化了。如果定义变量时没有指定初值，则变量被默认初始化，此时被赋予了“默认值”。定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置变量将不被初始化，由于是未被定义的，试图拷贝或以其他形式访问此值将引发错误。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418205841.png"></p><h4 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h4><p>c++将声明和定义区分开来，声明使得名字为程序所知，定义负责创建与名字关联的实体。</p><p>变量声明规定变量的类型和名字，在这一点上定义与之相同，但除此之外，定义还申请存储空间，也可能为变量赋一个初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// 如果想声明一个变量而非定义它，在变量名前添加关键字extern</span></span><br><span class="line"><span class="type">int</span> j;<span class="comment">// 声明并定义 j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>; <span class="comment">// extern语句如果包含初始值就不再是声明，而变成定义了。</span></span><br><span class="line"><span class="comment">// 如果在函数体这样写，将会引发错误。</span></span><br></pre></td></tr></table></figure><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211425.png"></p><ul><li>引用即别名。</li><li>引用本身并不是一个对象，不能定义引用的引用。</li><li>引用类型要与之绑定的对象严格匹配。</li><li>引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</li></ul><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211747.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211809.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418211905.png"></p><p>指针的值（地址）应属于下列4种状态之一：</p><ul><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象</li><li>无效指针，也就是上述情况之外的其他值，试图拷贝或以其他形式访问无效指针都将引发错误</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212135.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212340.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418212627.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">// 从右往左读，离变量名最近的符号对变量的类型有最直接的影响，因此r是一个引用。*说明r引用的是一个指针。</span></span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>默认状态下，const对象仅在一个文件内有效，如果程序包含多个文件，同名的const变量其实等同于在不同文件中分别定义了独立的变量。解决的方法便是在const变量前加extern</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h4 id="const与引用"><a href="#const与引用" class="headerlink" title="const与引用"></a>const与引用</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418213248.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418213820.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214147.png"></p><p>由于const引用也经常被称为常量引用，所以在正常引用中不能做的——使用字面值或者表达式作为初始值，类型不一致，在const引用中都可以做</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214232.png"></p><h4 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214516.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418214614.png"></p><h4 id="顶层与底层const"><a href="#顶层与底层const" class="headerlink" title="顶层与底层const"></a>顶层与底层const</h4><p>顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量，也就是说，顶层const表示的对象是常量，无法改变。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418215607.png"></p><h5 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h5><p>常量表达式指值不会改变且在编译过程就能得到计算结果的表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>; <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;<span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;<span class="comment">// 不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();<span class="comment">// 不是常量表达式</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220303.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220655.png"></p><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418220844.png"></p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418221240.png"></p><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype 作用是选择并返回操作数的数据类型。编译器只分析表达式得到类型，却不实际计算表达式的值</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418221458.png"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418222613.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230418222654.png"></p><p>使用数组下标时，通常将其定义为size_t类型。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419093955.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094201.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094228.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094312.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094545.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094557.png"></p><p>严格来说，c++没有多维数组，通常说的多维数组其实是数组的数组</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419094706.png"></p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h4><p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p><h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095331.png"></p><h4 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095540.png"></p><h4 id="i-还是-i"><a href="#i-还是-i" class="headerlink" title="++i 还是 i++"></a>++i 还是 i++</h4><p>前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095813.png"></p><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419095939.png"></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419100130.png"></p><h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p>sizeof 返回一条表达式或一个类型名字所占的字节数。其所得值是一个size_t类型的常量表达式。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419100642.png"></p><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><ul><li><p>static_cast: 只要不包含底层const，就可以用。当需要把一个较大的算数类型复制给较小的类型时，同时我们不在乎潜在的精度损失，static_cast就非常有用。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419104556.png"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132259.png"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132320.png"></p></li><li><p>dynamic_cast:运行时类型识别的运算符，用于将基类的指针或引用安全地转化为派生类的指针或引用。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132236.png"></p></li><li><p>const_cast: 它只能改变运算对象的底层const，一般称其为“去掉const性质”，一旦去掉，编译器就不再组织我们对该对象进行写操作了。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419105145.png"></p></li><li><p>reinterpret_cast: 通常为运算对象的位模式提供较低层次的重新解释。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419110344.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">65</span>);</span><br><span class="line"><span class="type">char</span>* ch = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt; (p);</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 65</span></span><br><span class="line">cout &lt;&lt; *ch &lt;&lt; endl; <span class="comment">// A</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl; <span class="comment">// 地址00000249CE417930</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl; <span class="comment">// A</span></span><br></pre></td></tr></table></figure><blockquote><p>举个例子，32位系统，int是32位，指针也是32位，我既可以把一个32位的值解释成一个整数，也可以解释成一个指针。至于究竟能不能这样解释，由程序员负责。而reinterpret_cast就是干这个事的。<br><a href="https://zhuanlan.zhihu.com/p/33040213">C++类型转换之reinterpret_cast</a></p></blockquote></li></ul><h4 id="RTTI-运行时类型识别"><a href="#RTTI-运行时类型识别" class="headerlink" title="RTTI 运行时类型识别"></a>RTTI 运行时类型识别</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132434.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132459.png"></p><p>typeid 作用于对象，我们应该用*bp而非bp</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132655.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230419132730.png"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h4><p>名字有作用域、对象有生命周期。</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间</li></ul><p>自动对象：我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。</p><p>形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。</p><p>局部静态对象：在程序的第一次执行初始化，直到程序终止才销毁。在此期间，即使对象所在的函数结束执行也不会对它有所影响。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421105708.png"></p><h4 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h4><p>形参初始化的原理与变量初始化一样。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110256.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110522.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110618.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110649.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110735.png"></p><p><strong>含有可变形参的函数</strong> ： </p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110825.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421110855.png"></p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>不要返回局部对象的引用或指针：函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111054.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111845.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111856.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421111906.png"></p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421112312.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421112244.png"></p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数可避免函数调用的开销，一般来说，内联机制用于优化规模较小，流程直接，频繁调用的函数。就比如说，调用函数比函数执行时间长，用内联函数就行了。</p><h4 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125221.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125231.png"></p><h4 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421125357.png"></p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>感觉类似于c#的委托，像是给一个函数的别名</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230421130122.png"></p><h3 id="初步探索类"><a href="#初步探索类" class="headerlink" title="初步探索类"></a>初步探索类</h3><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>常量对象、以及常量对象的引用或指针都只能调用常量成员函数。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422204832.png"></p><p>简单来说，就是让该函数的权限为只读，也就是说没法去改变成员函数的值。<br>同时，如果一个对象为const，它只有权力调用const函数，因为成员变量不能改变。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>不同于其他函数，构造函数不能被声明成const。</p><p>如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。又称为合成默认构造函数，按照一下规则初始化类地数据成员</p><ul><li>如果存在类内的初始值，就用它来初始化成员</li><li>否则，默认初始化该成员。</li></ul><p>某些类不能依赖于合成的默认构造函数，原因如下：</p><ul><li>对于一个普通的类来说，必须定义它自己的默认构造函数。只有类不包含任何构造函数的情况下才会自动生成默认构造函数。</li><li>对于某些类来说，合成的默认构造函数可能执行错误的操作。如果定义在块中的内置类型或复合类型（数组和指针）被默认初始化，则它们的值将是未定义的。</li><li>如果类中包含一个其他类类型的成员且这个成员没有默认构造函数，那么编译器将无法初始化该成员。</li></ul><p>&#x3D; default，即要求编译器生成默认构造函数，如果在类的内部，默认是内联的，如果在类的外部，默认不是内联的。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211706.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211751.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211833.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422212543.png"></p><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。</p><p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。一般来说，最好定义在类开始的位置或者结束的位置。</p><p>友元仅仅指定了访问权限，如果希望类能够调用某个友元函数，那么必须在友元声明之外在专门对函数定义一次。</p><h4 id="类的inline"><a href="#类的inline" class="headerlink" title="类的inline"></a>类的inline</h4><p>在类中，常有一些规模较小的函数适合被声明内联函数，定义在类内部的成员函数是自动inline的。</p><h4 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422211331.png"></p><h4 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h4><p>类的静态成员存在任何对象之外，对象中不包含任何于静态数据成员有关的数据。静态成员函数也不予任何对象绑定在一起，它们不包含this指针。同时，静态成员函数不能声明成const，也不能在里面调用this指针。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230422213444.png"></p><h3 id="c-标准库"><a href="#c-标准库" class="headerlink" title="c++标准库"></a>c++标准库</h3><h4 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425195814.png"></p><p>顺序容器的选择：</p><ul><li>通常选择vector</li><li>有很多小元素，空间额外开销很重要，不要用list或forward_list</li><li>随机访问元素，用vector 或 deque</li><li>在中间插入或删除元素，应使用list或forward_list</li><li>头尾插入或删除元素，用deque</li><li>如果只有在输入时踩在中间位置插入元素，随后需要随机访问：考虑输入阶段用list，输入完成后拷贝到vector</li><li>又要随机访问，又要在中间位置插入元素，看访问操作多还是插入&#x2F;删除元素操作多</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200215.png"></p><h4 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h4><p>begin指向第一个元素，end指向最后一个元素之后的位置通常称为左闭右合区间。即[begin,end)</p><ul><li>如果begin &#x3D;&#x3D; end 说明该范围为空</li><li>如果begin !&#x3D; end 说明至少包含一个元素，且begin指向该范围中的第一个元素</li><li>begin可以递增，使得begin &#x3D;&#x3D; end</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(begin!=end)&#123;</span><br><span class="line">  *begin = val;</span><br><span class="line">  ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200629.png"></p><p>当不需要写访问的时候，应该使用cbegin和cend</p><h4 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200725.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200822.png"></p><h4 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425200902.png"></p><p>assign 相对于赋值运算符(&#x3D;)允许从以一个不同但相容的类型赋值（比如char* 和 string），或者从容器的一个子序列赋值。assign操作用所指定的元素的拷贝替换容器中的所有元素。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201049.png"></p><p>swap操作交换两个相同类型的内容，保证操作很快，元素本身未被交换，只是交换了两个容器的内部数据结构。<br>元素不会被移动意味着，除string外指向容器的迭代器、引用指针在swap后都不会失效，除了string。<br>与其他容器不同，swap两个array会真正地交换元素。</p><h4 id="容器比较"><a href="#容器比较" class="headerlink" title="容器比较"></a>容器比较</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201329.png"></p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201416.png"></p><ul><li>push_back、push_front、insert:放入到容器中的元素时对象值地一个拷贝而不是对象本身。</li><li>emplace操作:则是将参数传递给元素类型的构造函数，直接在容器管理的内存空间中直接构造元素，参数必须与元素类型的构造函数相匹配。</li></ul><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425201920.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202108.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202245.png"></p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202408.png"></p><h4 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202449.png"></p><h4 id="string-操作"><a href="#string-操作" class="headerlink" title="string 操作"></a>string 操作</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202540.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202609.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202654.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202711.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202727.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425202750.png"></p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>也就是让容器看起来像一种不同的类型，比如说queue是基于deque实现的。比较常见的时stack，queue,priority_queue。</p><h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><p>算法永远不会改变底层容器的大小，可能改变值，可能移动元素，但永远不会添加或删除元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读算法</span></span><br><span class="line"><span class="type">int</span> *result = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),val);<span class="comment">//查找算法</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">count</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),val);<span class="comment">// 统计个数</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),<span class="number">0</span>);<span class="comment">// 求和、和的初值设置为0</span></span><br><span class="line">string result = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),<span class="string">&quot;&quot;</span>); <span class="comment">// 将vec的每个元素连起来</span></span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">equal</span>(vec.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),other.<span class="built_in">cbegin</span>());<span class="comment">// 比较算法，确定两个序列是否保存相同的值，基于两个序列相等的假设。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写算法</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());<span class="comment">// 将元素重置为0</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">begin</span>() + vec.<span class="built_in">size</span>()/<span class="number">2</span>,<span class="number">10</span>);<span class="comment">//将子序列都赋为10</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">size</span>(),<span class="number">0</span>); <span class="comment">// 与fill稍微不同，是从vec.begin开始将vec.size()个元素变为0。</span></span><br><span class="line"><span class="comment">// 要注意的是，fill_n假定begin指定一个元素，从begin开始的序列至少包含vec.size()个元素，容易犯的错误就是在空容器调用fill_n</span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),vec2);<span class="comment">// 将vec拷贝到vec2中，返回目的位置迭代器即vec2为元素之后的位置</span></span><br><span class="line"><span class="built_in">replace</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//将0变为42</span></span><br><span class="line"><span class="built_in">replace_copy</span>(a.<span class="built_in">cbegin</span>(),a.<span class="built_in">cend</span>(),<span class="built_in">back_inserter</span>(b),<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//将a拷贝到b但是拷贝时0都编程42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排元素算法</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());<span class="comment">// 从小到大排序</span></span><br><span class="line"><span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());<span class="comment">//排列范围的元素，指向不重复区域之后一个位置的迭代器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="lambada表达式与泛型算法"><a href="#lambada表达式与泛型算法" class="headerlink" title="lambada表达式与泛型算法"></a>lambada表达式与泛型算法</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205348.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205429.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425205447.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words.vector&lt;string&gt;::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">elimDups</span>(words);<span class="comment">//将words按字典序排序，删除重复单词</span></span><br><span class="line">  <span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[](<span class="type">const</span> string &amp;a,<span class="type">const</span> string &amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()&#125;);</span><br><span class="line">  <span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string &amp;a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz&#125;);</span><br><span class="line">  <span class="keyword">auto</span> count = words.<span class="built_in">end</span>() - wc;</span><br><span class="line">  for_each(wc,words.<span class="built_in">end</span>(),[](<span class="type">const</span> string &amp;s)&#123;cout&lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambada-捕获"><a href="#lambada-捕获" class="headerlink" title="lambada 捕获"></a>lambada 捕获</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425211551.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230425211902.png"></p><h3 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h3><p>程序使用动态内存的原因：1.程序不知道自己需要使用多少对象。 2.程序不知道所需对象的准确类型。 3.程序需要在多个对象间共享数据。<br>动态内存很难使用，有时候会忘记释放内存，这时会产生内存泄漏；有时指针引用内存的情况下指针已经被释放这时会产生引用非法内存的指针。</p><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501202449.png"></p><p>默认初始化的智能指针保存一个空指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;<span class="comment">// 初始化方式与vector一样</span></span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;<span class="built_in">empty</span>())</span><br><span class="line">  *p1 = <span class="string">&quot;hi&quot;</span></span><br><span class="line"><span class="comment">// 如果p1不为空，检查它是否指向一个空string</span></span><br></pre></td></tr></table></figure><p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为42的int的shared_ptr</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 指向一个值为&quot;9999999999&quot;的string</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// 指向一个值初始化的int，即为0</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于vector的emplace，传递参数类型必须相对应，不传递的话就会进行值初始化，通常用auto来保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p6 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。<br>每个shared_ptr都有一个关联的计数器，通常称为<strong>引用计数</strong>。当我们用一个shared_ptr去初始化另一个shared_ptr，或者作为参数传递给函数，或者作为函数返回值，所关联的计数器都会<strong>递增</strong>。赋予一个新值，或者shared_ptr销毁（比如离开作用域）计数器递减。一旦一个shared_ptr计数器变为0，会自动释放自己所管理的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q;<span class="comment">// 给 r 赋值让它指向另一个地址</span></span><br><span class="line"><span class="comment">// 递增 q 指向对象的引用计数</span></span><br><span class="line"><span class="comment">// 递减 r 原来指向对象的引用计数</span></span><br><span class="line"><span class="comment">// r 原来指向的对象没有引用者，自动释放</span></span><br></pre></td></tr></table></figure><h4 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h4><p>new 分配内存，delete释放new分配的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 默认初始化，*pi的值未定义</span></span><br><span class="line"><span class="type">int</span> *pi1 = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// 值初始化，*pi1为0</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); <span class="comment">// pi2指向的对象的值为1024</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);<span class="comment">// 分配并初始化一个const int</span></span><br><span class="line"><span class="type">const</span> string *pcs = <span class="keyword">new</span> <span class="type">const</span> string;<span class="comment">// 分配并默认初始化一个const 的空string</span></span><br><span class="line"><span class="comment">// 一个动态分配的const对象必须初始化</span></span><br><span class="line"><span class="comment">// 对于一个定义了默认构造函数的类类型</span></span><br><span class="line"><span class="comment">// 其const动态对象可以隐式初始化</span></span><br><span class="line"><span class="comment">// 而其他类型对象就必须显式初始化</span></span><br><span class="line"><span class="comment">// 由于分配对象是const，new返回的指针是一个指向const的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果内存不够用，内存分配失败</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// new抛出std::bad_alloc</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>;<span class="comment">// new 返回一个空指针</span></span><br></pre></td></tr></table></figure><p>delete做两步：销毁给定指针指向的对象;释放对应的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *pi1 = &amp;i;</span><br><span class="line"><span class="type">int</span> *pi2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> *pd = <span class="keyword">new</span> <span class="built_in">double</span>(<span class="number">33</span>);</span><br><span class="line"><span class="type">double</span> *pd2 = pd;</span><br><span class="line"><span class="keyword">delete</span> i;<span class="comment">// 错误，i不是指针</span></span><br><span class="line"><span class="keyword">delete</span> pi1;<span class="comment">// 未定义,pi指向一个局部变量</span></span><br><span class="line"><span class="keyword">delete</span> pd;<span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">delete</span> pd2;<span class="comment">// 未定义，pd2指向的内存已经被释放了</span></span><br><span class="line"><span class="keyword">delete</span> pi2;<span class="comment">// 正确，释放一个空指针没有错误</span></span><br></pre></td></tr></table></figure><p>由内置指针管理的动态内存在被显式释放(delete)前一直都会存在</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501205622.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501205711.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210052.png"></p><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210525.png"></p><ul><li>与shared_ptr不同，某个时刻<strong>只能有一个unique_ptr指向一个给定对象</strong>。当unique_ptr被销毁时，所指向的对象也被销毁。</li><li>与shared_ptr不同，没有类似make_shared的标准库函数，定义unique_ptr时，<strong>需要将其绑定到一个new返回的指针上</strong>。</li><li>由于一个unique_ptr拥有所指向的对象，所以<strong>不支持普通的拷贝或赋值操作</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210603.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210639.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210650.png"></p><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230501210929.png"></p><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个weak_ptr时，要用一个shared_ptr来初始化它</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于对象可能不存在，不能使用weak_ptr直接访问对象</span></span><br><span class="line"><span class="comment">// 而必须调用lock，此函数检查weak_ptr所指对象是否仍然存在</span></span><br><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h3><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>如果一个<strong>构造函数</strong>的<strong>第一个参数</strong>是<strong>自身类类型</strong>的引用，且任何额外默认参数都有默认值，则为拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>();<span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);<span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们构造一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506195211.png"></p><p><strong>直接初始化</strong>：实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。</p><p><strong>拷贝初始化</strong>：我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。通常使用拷贝构造函数完成，如果有移动构造函数，则有时会使用移动构造函数。</p><p>拷贝初始化的发生情况：</p><ul><li>&#x3D;定义变量</li><li>将一个对象从实参传递给非引用的形参</li><li>返回类型为非引用类型的函数返回的对象</li><li>用花括号列表 初始化一个数组中的元素或一个聚合类的成员</li><li>标准库容器insert&#x2F;push，与之相对，用emplace创建的元素都进行直接初始化</li></ul><p>拷贝函数在这几种情况下都会被隐式地使用，因此，拷贝构造函数不应是explicit的</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506200110.png"></p><h4 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data trans,accum;</span><br><span class="line">trans = accum; <span class="comment">// 使用Sales_data 的拷贝赋值元素符</span></span><br></pre></td></tr></table></figure><p>与类控制对象如何初始化一样，类也可以控制其对象如何赋值。与拷贝构造函数一样，如果未定义，编译器会为它合成一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;);<span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值运算符通常返回一个指向其左侧运算对象的引用</span></span><br></pre></td></tr></table></figure><p>拷贝赋值元素运算符会将右侧对象的每个非static成员赋予左侧对象的对应成员</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506200857.png"></p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数释放对象使用的资源，并销毁对象的非static数据成员。析构函数<strong>没有返回值，也不接受参数，不能呗重载，一个给定类只有唯一一个析构函数</strong>。同时，析构函数自动运行，程序按需分配资源，通常无须当心何时释放这些资源</p><p>在析构函数中，先执行函数体，然后销毁成员。按初始化顺序的<strong>逆序</strong>销毁。释放对象在生存期分配的所有资源。<br>析构部分式隐式的，成员销毁时完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型成员没有析构函数，什么都不需要做。<br>隐式销毁内置指针类型的成员不会delete它所指地对象。</p><p>调用析构函数的时机：</p><ul><li>变量离开其作用域时</li><li>对象被销毁，成员被销毁</li><li>容器被销毁</li><li>动态分配的对象，对指向它的指针应用delete时</li><li>临时对象，创建它的完整表达式结束时被销毁</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506201821.png"></p><p>未定义时，编译器会为它定义一个合成析构函数，析构函数体自身不直接销毁成员，成员时在析构函数体执行后隐式销毁的。</p><p>如果一个类需要自定义析构函数，几乎肯定的是，也需要自定义拷贝赋值运算符和拷贝构造函数。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203014.png"></p><h4 id="x3D-default"><a href="#x3D-default" class="headerlink" title="&#x3D;default"></a>&#x3D;default</h4><p>使用&#x3D;default来显式地要求编译器生成合成的版本<br>当我们使用&#x3D;default时，合成的函数会被隐式地声明为inline</p><p>我们只能对具有合成版本的成员函数使用&#x3D;default</p><h4 id="x3D-delete"><a href="#x3D-delete" class="headerlink" title="&#x3D;delete"></a>&#x3D;delete</h4><p>我们可以为任何函数指定&#x3D;delete（除了析构函数）<br>&#x3D;delete函数：虽然我们声明了它们，但不能以任何方式使用它们。<br>&#x3D;delete主要用于禁止拷贝控制成员，如果希望引导函数匹配过程，删除函数有时也是有用的。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203438.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203413.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506203743.png"></p><p>尽可能使用&#x3D;delete来阻止拷贝，而不应该声明为private</p><h4 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204218.png"></p><p><strong>行为像值的类</strong>：每个类的对象都有自己的实现</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204605.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506204742.png"></p><p><strong>行为像指针的类</strong>：所有类的对象共享类的资源，比如shared_ptr。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211340.png"></p><p>主要的不同体现在拷贝构造函数中，析构函数和拷贝赋值运算符依据引用计数有所改变</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211509.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211603.png"></p><h4 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h4><p>对于重拍元素顺序的算法，定义swap时非常重要的。<br>如果一个类定义了自己的swap，那么算法将使用自定义版本，否则将使用标准库的swap。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211803.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506211925.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506212016.png"></p><h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>在某些情况下，对象拷贝后就立即被销毁了。这时候，移动而非拷贝对象会大幅度提升性能。</p><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>通过&amp;&amp;来获得右值引用，只能绑定到<strong>一个将要销毁的对象</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230506231308.png"></p><p>变量是左值，因此我们不能将右值引用绑定到变量上，即使是右值引用类型。</p><p>标准库move函数，可以显示地将一个左值转换为对应的右值引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br><span class="line"><span class="comment">// move告诉编译器，将rr1当作右值一样处理</span></span><br><span class="line"><span class="comment">// 除了对rr1赋值或销毁，我们不再使用它</span></span><br></pre></td></tr></table></figure><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数的第一个参数是一个右值引用，保证移后元对象处于一个状态——销毁无害。一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权归属新创建的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//告诉标准库我们的构造函数不抛出任何异常</span></span><br><span class="line"><span class="comment">// 成员初始化接管s的资源</span></span><br><span class="line">:<span class="built_in">elements</span>(s.elements),<span class="built_in">first_free</span>(s.first_free),<span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">  s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 被接收后指针都置为nullptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507001946.png"></p><p>在这里，我们检查this 与 rhs的地址是否相同。相同不做任何事情。否则释放已有元素，然后接管右值引用的元素。再把rhs指针赋为nullptr</p><p><strong>在移动后，移后源对象必须可析构</strong>。</p><h4 id="合成移动操作"><a href="#合成移动操作" class="headerlink" title="合成移动操作"></a>合成移动操作</h4><p>如果一个类定义了拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。<br>只有当一个类<strong>没有定义任何自己版本的拷贝控制成员</strong>，且<strong>类的每个非static数据成员都可以移动</strong>时，编译器才会为它合成移动构造函数或移动赋值运算符。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507002510.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507002957.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507003227.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507003912.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507004102.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507004122.png"></p><h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><p>面向对象程序设计基于三个基本概念：数据抽象、继承、和动态绑定。</p><h4 id="数据抽象、继承、动态绑定"><a href="#数据抽象、继承、动态绑定" class="headerlink" title="数据抽象、继承、动态绑定"></a>数据抽象、继承、动态绑定</h4><p><strong>数据抽象</strong>：只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p><p><strong>继承</strong>：通过继承联系在一起的类构成一种层次关系。通常根部叫做<strong>基类</strong>，直接或间接从基类继承而来叫<strong>派生类</strong>。</p><p><strong>动态绑定</strong>：当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。动态绑定即是在运行时选择函数的版本，在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p><h4 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h4><p>基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作。</p><p>因为在派生类有与基类对应的部分，所以能把派生类的对象当作基类对象来使用，也能将基类指针或引用绑定到派生类对象中的基类部分上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;<span class="comment">// 基类</span></span><br><span class="line">Bulk_quote bulk;<span class="comment">// 派生类</span></span><br><span class="line">Quote *p = &amp;item;<span class="comment">// p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;<span class="comment">// p指向bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;<span class="comment">// r绑定到bulk的Quote部分</span></span><br></pre></td></tr></table></figure><p>派生类先初始化基类部分，然后按照声明顺序初始化派生类的成员。</p><p>不管从基类中派生出多少个派生类，对于每个<strong>静态成员</strong>来说都只存在<strong>唯一</strong>的实例。</p><p>静态成员遵循通用的访问控制规则</p><p><strong>防止继承</strong>，即在类名后跟一个关键字final</p><p>我们可以将<strong>基类的指针（内置或智能）或引用绑定到派生类对象</strong>上。例如，可以用Quote&amp;指向一个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给一个Quote*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态类型在编译时就已知，是变量声明时的类型或表达式生成的类型</span></span><br><span class="line"><span class="comment">// 动态类型则是变量或表达式表示的内存中的对象的类型，运行时才知道</span></span><br><span class="line"><span class="type">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line"><span class="comment">// item的静态类型是Quote&amp;</span></span><br><span class="line"><span class="comment">// 它的动态类型依赖于item绑定的实参</span></span><br><span class="line"><span class="comment">// 如果传递一个Bulk_quote，则item动态类型则是Bulk_quote</span></span><br><span class="line"><span class="comment">// 如果表达式既不是引用也不是指针，动态类型和静态类型永远一致。</span></span><br><span class="line"><span class="comment">// 比如Quote类型变量永远是一个Quote对象</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在基类向派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生了对象上</span></span><br><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;</span><br><span class="line">Bulk_quote&amp; bulkRef = base;</span><br><span class="line"><span class="comment">// 以上都是错误的，不能将基类转化为派生类</span></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;<span class="comment">// 正确，动态类型是Bulk_quote</span></span><br><span class="line">Bulk_quote *bulkP = itemP;<span class="comment">// 错误，不能将基类转化成派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用dynamic_cast,如果在基类中含有一个或多个虚函数</span></span><br><span class="line"><span class="comment">// 如果已知某个基类转化派生类是安全的，可以用static_cast</span></span><br></pre></td></tr></table></figure><p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分会被忽略，也就是被切掉</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507144244.png"></p><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>动态绑定<strong>只会在我们通过指针或引用调用虚函数</strong>时才会发生。如果通过一个普通类型（非引用非指针）的表达式调用虚函数，在编译时就会将表达式的把呢不能确定下来。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507152318.png"></p><p>基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507152800.png"></p><p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507153006.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drived</span> : <span class="keyword">public</span> Base&#123;  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();<span class="comment">//递归调用自己</span></span><br><span class="line">    Base::<span class="built_in">foo</span>();<span class="comment">//明确告诉编译器，调用Base::foo而不是自己</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507154155.png"></p><p>含有纯虚函数的类是抽象基类，我们<strong>不能创建一个抽象基类的对象</strong>。可以定义它的派生类，前提是这些类覆盖了纯虚函数。</p><p>派生类只初始化它的直接基类</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507155227.png"></p><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507161237.png"></p><p>上述表示，如果友元通过派生类来访问protected成员是可以的。但是友元直接访问protected成员就不可以</p><p><a href="https://www.zhihu.com/question/37051531/answer/70216882">C++派生类的成员或友元只能通过派生类对象来访问基类的受保护成员? - 邱昊宇的回答 - 知乎</a></p><p>在类中用using声明改变访问级别，当然派生类只能为访问到的名字提供using</p><p>struct 默认public继承<br>class 默认private继承</p><h4 id="继承的类作用域"><a href="#继承的类作用域" class="headerlink" title="继承的类作用域"></a>继承的类作用域</h4><p>派生类的作用域位于基类作用域之内，如果一个名字在派生类中无法解析，则会在外层基类作用域中寻找该名字的定义。</p><p>在编译时进行<strong>名字查找</strong>，意味着能够使用哪些成员由静态类型决定。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507164433.png"></p><p>派生类会覆盖基类的同名成员，我们可以通过作用域运算符来使用基类成员。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507164558.png"></p><p><strong>名字查找</strong>,假设调用obj-&gt;foo():</p><ul><li>首先确定obj的静态类型</li><li>然后在obj的静态类型对应的类中查找foo。找不到，就一直往继承链上找。如果一直找不到，就报错。</li><li>一旦找到foo，进行类型检查</li><li>如果合法，则会根据是否是虚函数进行调用：1.如果时虚函数，则依据obj的动态类型的版本;2.如果不是，直接调用</li></ul><p>我们可以看到<strong>名字查找先于类型检查,所以会有以下结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507165048.png"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507165828.png"></p><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507211827.png"></p><h4 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507212141.png"></p><p><strong>派生类中删除的拷贝控制与基类的关系</strong>：</p><ul><li>基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是delete或private，则派生类对应的是delete的。原因是编译器不能使用基类成员来执行这些操作</li><li>如果基类中有一个<strong>private或delete的析构函数</strong>，则派生类合成的默认和拷贝构造函数是delete，因为编译器无法销毁派生类对象的基类部分</li><li>编译器不会合成一个delete移动操作。当我们使用&#x3D;default，如果基类中对应是delete或private，则派生类中是delete，原因是派生类基类部分不可移动。同样，基类析构函数delete或private，则派生类移动构造函数也是delete</li></ul><p><strong>派生类拷贝或移动构造函数</strong>：</p><p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中<strong>显式地使用</strong>基类的拷贝（或移动）构造函数</p><p><strong>派生类赋值运算符</strong>：同理，复制运算符也要显式地为基类部分赋值</p><p><strong>派生类析构函数</strong>：销毁顺序与创建顺序相反，先执行派生类析构函数，再执行基类的。</p><p>如果构造函数或析构函数调用了某个虚函数，则应该执行与类型相对应的虚函数版本。</p><h4 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h4><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/20230507213936.png"></p><p>using声明不会改变构造函数的访问级别。<br>using声明不能指定explicit或constexpr，继承的构造函数如果有这些属性，那么也有。<br>构造函数的默认实参不会被继承。相反，会获得多个继承。比如，基类有一个接受两个形参的构造函数，第二个含有默认实参，则派生类获得两个构造函数，一个接受两个形参，一个只接受一个形参，对应没有默认值的形参。</p><p>如果基类含有几个构造函数，大多数派生类会继承这些构造函数。有两个例外情况：</p><ul><li>派生类继承一部分构造函数，为其他构造函数定义自己的版本。</li><li>默认、拷贝和移动构造函数不会被继承，会按照正常规则被合成。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于面试被狠狠拷打，决定恶补c++。有些概念太长会以图片显示&lt;/p&gt;
&lt;h3 id=&quot;变量和基本类型&quot;&gt;&lt;a href=&quot;#变量和基本类型&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Sortings</title>
    <link href="http://example.com/2023/02/04/Sortings/"/>
    <id>http://example.com/2023/02/04/Sortings/</id>
    <published>2023-02-04T05:03:21.000Z</published>
    <updated>2024-01-07T07:52:06.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>算是比较系统的重新学一遍算法，首先学算法，第一位接触的就是排序算法了。虽然很久以前用的就比较熟了，学习起来没什么难度。不过，通过看github那些大牛写的代码，同样受益匪浅，在一些代码处理上算是十分优秀了，也学到了一些测试方法——单元测试的AAA规则，Arrange,Act,Assert。同时还在自己编写修改代码时学上一些github工作流程，虽然只是学的毛皮，不过够用就行了。</p><h3 id="排序算法上使用的API"><a href="#排序算法上使用的API" class="headerlink" title="排序算法上使用的API"></a>排序算法上使用的API</h3><p>所有排序算法的接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     排序方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span>需要排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span>比较用的Comparer <span class="doctag">&lt;paramref name=&quot;array&quot; /&gt;</span>.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>comparer接口的比较规则</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">IntComparer</span> : <span class="title">IComparer</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> IComparer&lt;<span class="built_in">int</span>&gt;.Compare(<span class="built_in">int</span> x, <span class="built_in">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.CompareTo(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int Compare(int x, int y) =&gt; x.CompareTo(y);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序算是最简单的排序算法，两两进行比较交换直到不需要被交换</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/202302041354888.gif"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>     冒泡排序类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数组元素类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BubbleSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     时间复杂度 O(n^2)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     空间复杂度 O(1)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     在这里，我们按照升序排序</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     比较相邻元素，大的放在后面</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     这样子每次最后一个是最大元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     在不包含最大元素的范围重复步骤，直到没得交换</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     最好情况是 N - 1 次交换和 0 次交换</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     最坏情况是 N * (N - 1)/2 次交换</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span>要排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span>比较器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.Length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> wasChanged = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; array.Length - i - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (comparer.Compare(array[j], array[j + <span class="number">1</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> temp = array[j];</span><br><span class="line">                        array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    wasChanged = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!wasChanged)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序也是特别简单的算法之一，即在未排序的找到最小（大）元素放在排序序列的起始位置，然后重复步骤。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/202302041400592.gif"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     实现选择排序的类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数组元素类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SelectionSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     时间复杂度 O(n^2)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     空间复杂度 O(1)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     找到数组最小元素，然后和第一个位置交换</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     指针向后移动一位，然后再在剩下的数组元素找出最小</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     如此往复，总共进行了 N 次交换</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span>排序数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span>比较器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.Length - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> jmin = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; array.Length; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(comparer.Compare(array[jmin], array[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        jmin = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> temp = array[i];</span><br><span class="line">                array[i] = array[jmin];</span><br><span class="line">                array[jmin] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的工作原理就是从前往后扫描，将未排序的元素插入到已排序元素中。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/202302041408746.gif"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     实现插入排序的算法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数组元素类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InsertionSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     时间复杂度 O(n^2)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     空间复杂度 O(1)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     我们保证当前需要排序的元素的前面是有序的</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     然后将该元素插入前面中</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     由于前面是有序的，假设是升序</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     只要找到第一个比它小的元素插入就停止</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     否则就一直两两交换位置直到第一位</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     平均情况下需要 N^2/4 次交换</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     最坏情况需要 N^2/2 次交换</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     最好情况需要 N - 1 次交换 和 0 次交换</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span>排序数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span>比较器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; comparer.Compare(array[j], array[j - <span class="number">1</span>]) &lt; <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> temp = array[j - <span class="number">1</span>];</span><br><span class="line">                    array[j - <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是优化过的插入排序，相对于插入排序只能一小步一小步的交换，希尔排序可以一大步一大步的交换，取决于当前的步长。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     实现希尔排序的类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数组元素类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     希尔排序的最坏时间复杂度取决于step</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     在这里，我们使用比较普遍的 1,4,13,40 数列</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     若使用 对数组长度进行对半取，最坏时间复杂度大概为 O(n^2)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     3*n+1 大概在 O(n^(3/2))</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     希尔排序就是用跳跃式的来减少最坏情况的发生</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     也就是说，原本插入可能要 N 次 交换，变到 3 次交换</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     最优的最坏时间复杂度为O(n*(logn)^2),但是step的计算比较麻烦</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     所以通常用 3 为倍数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span>排序数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span>比较器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> step = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (step &lt; array.Length / <span class="number">3</span>) step = <span class="number">3</span> * step + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (step &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                GappedInsertionSort(array, comparer, step);</span><br><span class="line">                step /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GappedInsertionSort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> step</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = step; i &lt; array.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= step &amp;&amp; comparer.Compare(array[j], array[j - step]) &lt; <span class="number">0</span>; j -= step)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j - step];</span><br><span class="line">                    array[j - step] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/202302051332826.gif"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     实现归并排序的类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数组参数类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MergeSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     时间复杂度 O(n*logn)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     空间复杂度 O(n)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     归并数组就是将两个有序的数组归并成更大的有序数组</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     通常用自顶向下比较容易理解</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     不断递归到大小只有 1 的数组，然后逐步向上归并</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array.Length &lt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> (left, right) = Split(array);</span><br><span class="line">            Sort(left, comparer);</span><br><span class="line">            Sort(right, comparer);</span><br><span class="line">            Merge(array, left, right, comparer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span>(<span class="params">T[] array, T[] left, T[] right, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> mainIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> rightIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt; left.Length &amp;&amp; rightIndex &lt; right.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> compResult = comparer.Compare(left[leftIndex], right[rightIndex]);</span><br><span class="line">                array[mainIndex++] = compResult &lt;= <span class="number">0</span> ? left[leftIndex++] : right[rightIndex++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt; left.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                array[mainIndex++] = left[leftIndex++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rightIndex &lt; right.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                array[mainIndex++] = right[rightIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> (<span class="params">T[] left, T[] right</span>) <span class="title">Split</span>(<span class="params">T[] array</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> mid = array.Length / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> (array.Take(mid).ToArray(), array.Skip(mid).ToArray());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     实现快速排序的类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">QuickSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     平均时间复杂度 O(nlogn)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     最坏情况下时间复杂度 O(n^2)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     空间复杂度 O(logn)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     选定一个参数，将比它小的数放左边，比它大的数放右边  </span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span> =&gt; Sort(array, comparer, <span class="number">0</span>, array.Length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">SelectPivot</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> mid = Partition(array, comparer, left, right);</span><br><span class="line">            Sort(array, comparer, left, mid);</span><br><span class="line">            Sort(array, comparer, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Partition</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> pivot = SelectPivot(array, comparer, left, right);</span><br><span class="line">            <span class="keyword">var</span> nleft = left;</span><br><span class="line">            <span class="keyword">var</span> nright = right;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (comparer.Compare(array[nleft], pivot) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nleft++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (comparer.Compare(array[nright], pivot) &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nright--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nleft &gt;= nright)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> nright;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> temp = array[nleft];</span><br><span class="line">                array[nleft] = array[nright];</span><br><span class="line">                array[nright] = temp;</span><br><span class="line"></span><br><span class="line">                nleft++;</span><br><span class="line">                nright--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>随便选一位参数</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     随便选一个作为参数进行快排</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">RandomPivotQuickSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">QuickSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Random _random = <span class="keyword">new</span>();</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> T <span class="title">SelectPivot</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">            =&gt; array[_random.Next(left, right + <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>选中间为参数</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     以数组中间为参数，进行快排</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MiddlePointQuickSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">QuickSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> T <span class="title">SelectPivot</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">            =&gt; array[left + (right - left) / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三向切分快速排序"><a href="#三向切分快速排序" class="headerlink" title="三向切分快速排序"></a>三向切分快速排序</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     实现三向切分快排的类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Quick3waySorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     时间复杂度与快排差不多</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     但是对大量重复元素执行效率更高</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     在快排的基础上，我们选一个参数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     但是有重复元素，我们将重复元素放在中间</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     然后对左对右进行分别递归</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     这样子减少对重复的排序</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">            =&gt; Sort(array, comparer, <span class="number">0</span>, array.Length - <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> (lt, rt) = Partition(array, comparer, left, right);</span><br><span class="line">            Sort(array, comparer, left, lt - <span class="number">1</span>);</span><br><span class="line">            Sort(array, comparer, rt + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> (<span class="built_in">int</span> lt, <span class="built_in">int</span> rt) Partition(T[] array, IComparer&lt;T&gt; comparer, <span class="built_in">int</span> left, <span class="built_in">int</span> right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> pivot = array[left];</span><br><span class="line">            <span class="keyword">var</span> lt = left;</span><br><span class="line">            <span class="keyword">var</span> i = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> rt = right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= rt)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> cmp = comparer.Compare(array[i], pivot);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Swap(array, lt++, i++);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Swap(array, i, rt--);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (lt, rt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params">T[] array, <span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = array[x];</span><br><span class="line">            array[x] = array[y];</span><br><span class="line">            array[y] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序即是利用堆的特性来进行排序，得出得结果是让数组为一个大根堆数组，而不是有序数组，若要获得有序数组，需要将堆顶一个一个拿出来，拿出堆顶时间为O(1)，维护剩余的堆需要logn，所以总的时间复杂度为nlogn </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithms.Sorters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     实现堆排序的类 这里是小根堆</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数组元素类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HeapSorter</span>&lt;<span class="title">T</span>&gt; : <span class="title">IComparisonSorter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>     时间复杂度 O(nlogn)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;comparer&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">T[] array, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">            =&gt; HeapSort(array, comparer);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span>(<span class="params">IList&lt;T&gt; data, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建堆？</span></span><br><span class="line">            <span class="keyword">var</span> heapSize = data.Count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> p = (heapSize - <span class="number">1</span>) / <span class="number">2</span>; p &gt;= <span class="number">0</span>; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                  MakeHeap(data, heapSize, p, comparer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将降序堆转化为升序队列，即将每个大根堆堆顶的元素取走然后重塑堆</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = data.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = data[i];</span><br><span class="line">                data[i] = data[<span class="number">0</span>];</span><br><span class="line">                data[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">                heapSize--;</span><br><span class="line">                MakeHeap(data, heapSize, <span class="number">0</span>, comparer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeHeap</span>(<span class="params">IList&lt;T&gt; data, <span class="built_in">int</span> heapSize, <span class="built_in">int</span> index, IComparer&lt;T&gt; comparer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> largest = index;</span><br><span class="line">            <span class="keyword">var</span> left = <span class="number">2</span> * (index + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> right = <span class="number">2</span> * (index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; comparer.Compare(data[left], data[largest]) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                largest = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; comparer.Compare(data[right], data[largest]) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                largest = right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (largest != index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = data[index];</span><br><span class="line">                data[index] = data[largest];</span><br><span class="line">                data[largest] = temp;</span><br><span class="line"></span><br><span class="line">                MakeHeap(data, heapSize, largest, comparer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/OSTEP/202302051329717.png" alt="img"></p><p>可以直白的说，大多数情况下，快速排序是最佳选择。我们在工程实践上通常用的是官方提供的库，除非是要写的语言没有提供官方库，或者是官方库的算法不太理想，才会去自己手写排序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;算是比较系统的重新学一遍算法，首先学算法，第一位接触的就是排序算法了。虽然很久以前用的就比较熟了，学习起来没什么难度。不过，通过看githu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github工作流</title>
    <link href="http://example.com/2022/11/16/github%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://example.com/2022/11/16/github%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2022-11-16T05:37:35.000Z</published>
    <updated>2024-01-07T07:46:20.670Z</updated>
    
    <content type="html"><![CDATA[<p>视频链接： <a href="https://www.bilibili.com/video/BV19e4y1q7JJ/?share_source=copy_web&vd_source=8277fbbcfe9cfbff0708d41552ef71ab">十分钟学会正确的github工作流，和开源作者们使用同一套流程</a></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1. git clone https://github.com/example/example.git </span><br><span class="line">// 克隆远程项目到本地 git clone + &quot;github项目提供的http&quot;</span><br><span class="line">2. git checkout -b my-feature </span><br><span class="line">// 修改代码,建立新分支而不是直接往main上push代码</span><br><span class="line">// &quot;my-feature&quot; 是这个分支的名字</span><br><span class="line">// 这个命令会复制一份当前的breach到新breach</span><br><span class="line">3. git diff </span><br><span class="line">// 当修改代码后,用 git diff 查看自己对代码做出的改变</span><br><span class="line">4. git add &lt;changed_file&gt;</span><br><span class="line">// 把已修改的代码告知 git ，这样 git 就可以 commit 了</span><br><span class="line">5. git commit &quot;comment(可有可无)&quot;</span><br><span class="line">// 把修改放入git中</span><br><span class="line">6. git push origin my-feature</span><br><span class="line">// 将当前 git 新创建的 breach 推回给github</span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line">（当修改代码的时候发现github出现改变 , 假设是main）</span><br><span class="line">1. git checkout main</span><br><span class="line">// 切换回main分支</span><br><span class="line">2. git pull origin master(main)</span><br><span class="line">// 这样 github 的 main 就会同步到 git 的 main</span><br><span class="line">3. git checkout my-feature</span><br><span class="line">// 回到 my-feature</span><br><span class="line">4. git rebase main</span><br><span class="line">// 同步修改，先不管自己的修改，然后把 main 先放进这个分支，最后根据我的修改成新的内容</span><br><span class="line">// 中途可能会出现rebase conflict，手动选择要哪一段代码</span><br><span class="line">5. git push -f origin my-feature </span><br><span class="line">// 将 git 变化的分支放进github</span><br><span class="line"></span><br><span class="line">6. github 上  (请求)pull request -&gt; (主人)Squash and merge</span><br><span class="line">// 在github中将两个分支合到mainbranch</span><br><span class="line"></span><br><span class="line">7. 然后删掉第二个分支（如果没用的话）</span><br><span class="line"></span><br><span class="line">8. git branch -D my-feature</span><br><span class="line">// 删除 git 的分支</span><br><span class="line"></span><br><span class="line">9. git pull origin master(main)</span><br><span class="line">// git 更新 github的最新代码</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;视频链接： &lt;a href=&quot;https://www.bilibili.com/video/BV19e4y1q7JJ/?share_source=copy_web&amp;vd_source=8277fbbcfe9cfbff0708d41552ef71ab&quot;&gt;十分钟学会正确的git</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Union Find</title>
    <link href="http://example.com/2022/08/31/Union-Find/"/>
    <id>http://example.com/2022/08/31/Union-Find/</id>
    <published>2022-08-31T01:37:01.000Z</published>
    <updated>2024-01-07T07:53:01.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>并查集在打竞赛的时候就学过了，现在差不多过了两年半，重拾算法，认真学学。当时在学的时候完全不理解并查集是什么意思，只能说当文科背了。认真看了英文版的ALgorithm 4th，才完全理解了这个并、查是什么意思，集应该是集合，也有可能是数据结构的意思，不知道是谁翻译的。如果阅读CS相关的书，尤其是基础书(即前置知识只需要你会写代码即可)，我推荐看英文版。虽然一开始看的很辛苦，但是一旦进入状态，基本能够了解作者想要告诉你什么，而且书里面的英语基本上是英文的大白话，除去几个专有名词需要查一下，其他基本上都是高中学过的单词。希望我能通过这段时间的英文教材阅读来练习自己以后阅读英文文档的能力吧。<br>关于并查集，我们直接看英文，Union - Find，Union即为并，即链接，Find为查找，查找出所在的集合。之所以叫这个名字，是因为Union和Find这两个方法是必不可少的，而且后续讨论优化也是在这两个方法中优化。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>当我们说p q时，即说p连接了q，然后有以下特点 ：</p><ul><li>反身性：p自身连接自己</li><li>对称性：如果p连接了q，则q连接了p</li><li>传递性：如果p连接了q且q连接了r，则p连接了r</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UF</span></span><br><span class="line">&#123;</span><br><span class="line">    UF(<span class="built_in">int</span> N)<span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span>(<span class="params"><span class="built_in">int</span> p,<span class="built_in">int</span> q</span>)<span class="comment">//连接p和q，即让他们在同一个集合</span></span></span><br><span class="line"><span class="function">    <span class="built_in">int</span> <span class="title">Find</span>(<span class="params"><span class="built_in">int</span> p</span>)<span class="comment">//找到p所在的集合</span></span></span><br><span class="line"><span class="function">    <span class="built_in">bool</span> <span class="title">Connected</span>(<span class="params"><span class="built_in">int</span> p,<span class="built_in">int</span> q</span>)<span class="comment">//判断p和q点是否在同一个集合</span></span></span><br><span class="line"><span class="function">    <span class="built_in">int</span> <span class="title">Count</span>()<span class="comment">//返回有多少个集合</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>简单来说，并查集就是让一个一个孤立的点连在一起，连在一起的点有一个共同的集合</p><h4 id="基本架构实现"><a href="#基本架构实现" class="headerlink" title="基本架构实现"></a>基本架构实现</h4><p>这里给出基本架构，可以看到，需要更改的基本上是Find和Union</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UF</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] id;<span class="comment">//集合的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span>(<span class="params"><span class="built_in">int</span> N</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="built_in">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            id[i] = i ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Count</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Connected</span>(<span class="params"><span class="built_in">int</span> p, <span class="built_in">int</span> q</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Find(p)==Find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params"><span class="built_in">int</span> p</span>)<span class="comment">//Find函数，后面会实现</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span>(<span class="params"><span class="built_in">int</span> p,<span class="built_in">int</span> q</span>)<span class="comment">//Union函数，后面会实现</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Quick-Find实现"><a href="#Quick-Find实现" class="headerlink" title="Quick-Find实现"></a>Quick-Find实现</h4><p>先来快速看看实现的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> id[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span>(<span class="params"><span class="built_in">int</span> p, <span class="built_in">int</span> q</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pId = Find(p);</span><br><span class="line">    <span class="built_in">int</span> qId = Find(q);</span><br><span class="line">    <span class="keyword">if</span>(pID == qID) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; id.Length; i++)</span><br><span class="line">        <span class="keyword">if</span>(id[i] == pId) </span><br><span class="line">            id[i] = qId;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里很简单，id就是p所在的集合编号，如果在Union中两个id不同，那么就会遍历全部集合，如果遍历到的点都属于p所在的集合，那么我们把遍历到的点的id改为q所属的集合的id。</p><p>不过我们想想，Find的时间复杂度为 O(1),而Union的时间复杂度为 O(N)。假设我们仅仅使用了N-1次连接我们就可以使整个连接成一个集合，那时间复杂度也至少是 N*(N-1),也就是O(N^2)，那当N大的时候消耗的时间将会很多。所以接下来我们来优化一下Union方法。</p><h4 id="Quick-Union实现"><a href="#Quick-Union实现" class="headerlink" title="Quick-Union实现"></a>Quick-Union实现</h4><p>先来快速看看两个方法里的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(p != parent[p]) </span><br><span class="line">        p = parent[p];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span>(<span class="params"><span class="built_in">int</span> p,<span class="built_in">int</span> q</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pRoot = Find(p);</span><br><span class="line">    <span class="built_in">int</span> qRoot = Find(q);</span><br><span class="line">    <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span> ;</span><br><span class="line">    id[pRoot] = qRoot;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Find和Union做了些许改变，parent和root可以让我们很快的联想到树的结构，我们将树根作为集合的编号，这样子Union仅仅需要O(1)即可完成一次连接，而Find消耗的时间复杂度虽然变多了，但是还是可以接受的。不过这并不是一个稳定的算法，假如Union将树形集合连接成了一个树链，那么Find的总时间就会变为(1+2+…N) ~ N^2&#x2F;2 ~ N^2,虽然最坏的情况也会比之前Quick-Find快，但是作为O(N^2)级别的时间复杂度，当数据量足够大也与Quick-Find差别不大。所以我们可以改变连接的方式，避免树链的出现。</p><h4 id="Weighted-Quick-Union-实现"><a href="#Weighted-Quick-Union-实现" class="headerlink" title="Weighted Quick-Union 实现"></a>Weighted Quick-Union 实现</h4><p>先来看看这次的Union代码，Find实现没有变，这次我们增加了一个Weight的实现,即树的权重(以集合里面有多少个点来计算，如果有N个点，则Weight为N)，加权树有一个特点，它可以保证树的最大深度&lt;&#x3D;lgN，因为不可能有树链的情况产生，且保证较小的树是直接加到根上的，这样最多仅仅让树的深度 +1</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pRoot = Find(p);</span><br><span class="line">    <span class="built_in">int</span> qRoot = Find(q);</span><br><span class="line">    <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(weight[pRoot] &lt; weight[qRoot]) </span><br><span class="line">    &#123;</span><br><span class="line">        parent[pRoot] = qRoot; </span><br><span class="line">        weight[qRoot] += weight[pRoot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        parent[qRoot] = pRoot;</span><br><span class="line">        weight[pRoot] +=weight[qRoot];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这次Weighted Quick-Union做的改变就是尽可能地让小树直接连在大树的根上，这样子基本上不会出现有树链的情况。我们来证明一下，假设让小树直接连接在大树的根上，设两棵树的权重分别为 i ，j 且 i &lt;&#x3D; j，设 i+j &#x3D; k,大树本身所需要的遍历时间不变，而小树的最大遍历时间会增加 1 ,即最大遍历时间变为 1 + lgi &#x3D; lg(i+i) &lt;&#x3D; lg(i+j) &#x3D; lg(k)，即 lgk 最多可能等于 lgi + 1。所以可以保证最坏时间复杂度为 N*(2*lgN)即为O(NlgN)。</p><p>我们可以更加极限一点，让每个点直接连着根，即路径压缩</p><h4 id="Weighted-Quick-Union-with-Path-Compression-实现"><a href="#Weighted-Quick-Union-with-Path-Compression-实现" class="headerlink" title="Weighted Quick-Union with Path Compression 实现"></a>Weighted Quick-Union with Path Compression 实现</h4><p>我们仅仅需要在Find中爬树的过程中将爬过的点直接附着在根上，这样可以保证树的深度在Find后很难超过2，使时间复杂度接近 1</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> root = p;</span><br><span class="line">    <span class="comment">//首先先找出根</span></span><br><span class="line">    <span class="keyword">while</span> (root != parent[root])</span><br><span class="line">        root = parent[root];</span><br><span class="line">    <span class="comment">//然后再次找根在遍历的过程中把每个节点直接附着在根上</span></span><br><span class="line">    <span class="keyword">while</span> (p != root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> newp = parent[p];</span><br><span class="line">        parent[p] = root;</span><br><span class="line">        p = newp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Algorithm配套习题"><a href="#Algorithm配套习题" class="headerlink" title="Algorithm配套习题"></a>Algorithm配套习题</h3><p>由于配套习题实在是太多了，我们这里只看网站上提供的题目</p><p><strong>1.5.8</strong> 给出反例来说明为什么这个quickFind中的Union方法是错误的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span>(<span class="params"><span class="built_in">int</span> p, <span class="built_in">int</span> q</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (connected(p, q)) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; id.length; i++)</span><br><span class="line">      <span class="keyword">if</span> (id[i] == id[p]) id[i] = id[q];</span><br><span class="line">   count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对比</span></span><br><span class="line"><span class="comment">public void Union(int p, int q)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int pId = Find(p);</span></span><br><span class="line"><span class="comment">    int qId = Find(q);</span></span><br><span class="line"><span class="comment">    if(pID == qID) return ;</span></span><br><span class="line"><span class="comment">    for(int i=0; i &lt; id.Length; i++)</span></span><br><span class="line"><span class="comment">        if(id[i] == pId) </span></span><br><span class="line"><span class="comment">            id[i] = qId;</span></span><br><span class="line"><span class="comment">    count--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>答：我们可以看到for循环中id[i] &#x3D;&#x3D; id[p]这里，在遍历中，我们可能改变了id[p]的值，比如(id[i] &#x3D;&#x3D; id[p],i&#x3D;&#x3D;p)，这样子当 i &gt; p 时，后面的都会失效。</p><p><strong>1.5.10</strong> 在Weighted Quick-Union中，假设我们让id[rootp] &#x3D;&#x3D; q 来代替id[rootp]&#x3D;&#x3D;id[rootq].算法的结果会出错吗？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pRoot = Find(p);</span><br><span class="line">    <span class="built_in">int</span> qRoot = Find(q);</span><br><span class="line">    <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(weight[pRoot] &lt; weight[qRoot]) </span><br><span class="line">    &#123;</span><br><span class="line">        parent[pRoot] = qRoot; </span><br><span class="line">        <span class="comment">//parent[pRoot] = q;</span></span><br><span class="line">        weight[qRoot] += weight[pRoot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        parent[qRoot] = pRoot;</span><br><span class="line">        weight[pRoot] +=weight[qRoot];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：不会.但是这样子不能让小树直接附着在大树的根上，这样时间复杂度并不能达到我们想要的效果。</p><h4 id="算法网址及Github代码"><a href="#算法网址及Github代码" class="headerlink" title="算法网址及Github代码"></a>算法网址及Github代码</h4><p>有一些部分题目是写代码，直接放在github中了，可以看看网址，有图助于理解</p><ul><li><a href="https://algs4.cs.princeton.edu/15uf/">https://algs4.cs.princeton.edu/15uf/</a></li><li><a href="https://github.com/talentstream/Algorithm-4th-Practice-/tree/main/Union-Find">https://github.com/talentstream/Algorithm-4th-Practice-/tree/main/Union-Find</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;并查集在打竞赛的时候就学过了，现在差不多过了两年半，重拾算法，认真学学。当时在学的时候完全不理解并查集是什么意思，只能说当文科背了。认真看了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Design Patterns</title>
    <link href="http://example.com/2022/08/07/design%20patterns/"/>
    <id>http://example.com/2022/08/07/design%20patterns/</id>
    <published>2022-08-07T13:04:20.000Z</published>
    <updated>2024-01-07T07:52:50.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近花了点读了《敏捷软件开发》这本书，关于这本书，我基本上是随便看看，了解有什么知识，也就在代码部分（具体示例方面）花了些功夫。尽管知道了解了这些知识，但是在工程上，没写个1w行以上的代码还是难以融会贯通。毕竟理论和工程是不一样的，工程实现理论至少是两个数量级以上的难度。不过通过画简单的UML图和短小的代码是可以快速认识到是什么，用来做什么，这样就足够了。</p><h3 id="《敏捷软件开发》阅读经验"><a href="#《敏捷软件开发》阅读经验" class="headerlink" title="《敏捷软件开发》阅读经验"></a>《敏捷软件开发》阅读经验</h3><p>这本书还是一本很好的书，对于了解敏捷开发，设计模式是足够的，同时也有足够多的源代码可以读。我读的一版是《敏捷软件开发：原则、模式与实践》c++版本的，不过里面也有java，虽然我的主语言是c#，但是也是阅读起来也不会太困难。这本书中文版虽然是在03年出版的，但是在现在对于我这种未入行业的小白也是十分有启发的。<br>根据我这次阅读的经验，我推荐第I部分（也就是1-6章）还有第II部分的第7章<strong>粗读</strong>，对原则和设计模式之类的进行<strong>通读</strong>，18，19章的薪水支付实践进行<strong>细读</strong></p><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。不过设计模式的出现基本上是为了解决 <strong>“设计的臭味”</strong> ——僵化性(Rigidity)，脆弱性(Fragility)，牢固性(Immobility)，粘滞性(Viscosity)，不必要的复杂性(Needless Complexity)，不必要的重复(Needless Repetition)，以及晦涩性(Opacity)</p><ul><li><strong>僵化性</strong>：很难对系统改动，因为每次改动都会使其他地方改动</li><li><strong>脆弱性</strong>：对系统的改动会导致其他的地方出现问题</li><li><strong>牢固性</strong>：设计中包含对其它系统有用的部分，但是把这部分抽离出来成本太高</li><li><strong>粘滞性</strong>：做新的改动时，保持系统设计的方法比破坏设计的方法更难使用</li><li><strong>不必要的复杂性</strong>：包含当前没有用的组成部分，可能会变得混乱</li><li><strong>不必要的重复</strong>：包含重复的结构，原本可以用单一的抽象进行统一</li><li><strong>晦涩性</strong>：难以阅读、理解</li></ul><h4 id="设计模式的描述常常包含以下内容"><a href="#设计模式的描述常常包含以下内容" class="headerlink" title="设计模式的描述常常包含以下内容"></a>设计模式的描述常常包含以下内容</h4><ul><li><strong>意图(Problem)</strong> 部分简单描述问题和解决方案。</li><li><strong>动机(Solution)</strong> 部分将进一步解释问题并说明模式会如何提供解决方案。</li><li><strong>结构(Structure)</strong> 部分展示模式的每个部分和它们之间的关系。</li></ul><h4 id="学习设计模式的好处以及一些问题"><a href="#学习设计模式的好处以及一些问题" class="headerlink" title="学习设计模式的好处以及一些问题"></a>学习设计模式的好处以及一些问题</h4><ul><li>现在常常说的23种设计模式是经过实践验证的解决方案。了解这些设计模式对于阅读源代码十分有用。</li><li>同时方便交流，只要知晓模式以及名称的原理，就可以用一个设计模式的名字来互相沟通这里该怎么写</li></ul><p>同时设计模式也一些问题，设计模式有一些是为了弥补语言本身的缺陷，有些语言有方便的语法，基本上一句话就可以代表一种设计模式。</p><p>“如果你只有一把铁锤， 那么任何东西看上去都像是钉子。” 这点是最重要的，对于初学者会带来一定困扰，学习某个模式之后，他们会在所有地方使用该模式，即便是在较为简单的代码中也使用这种模式。所以说初学者学来帮助自己阅读源码就绰绰有余了。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>在学习设计模式之前，我们得先学会如何读UML图。虽然UML图有很多种，但是基本上只要会读UML类图，就可以胜任大部分的工作。</p><h4 id="UML类方框"><a href="#UML类方框" class="headerlink" title="UML类方框"></a>UML类方框</h4><p>UML类图中基本上就三种普通类，抽象类和接口。都用矩形框表示，第一层是类名称，第二层是成员变量，第三层是类的方法。</p><ul><li><strong>“+”</strong> 表示 public</li><li><strong>“-“</strong> 表示 private</li><li><strong>“#”</strong> 表示 protected</li></ul><p>抽象类的类名以及抽象方法都用<strong>斜体</strong>，接口会在第一层加上一个 <strong>&lt;&lt; interface &gt;&gt;</strong> ，其他并没有什么不同</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807220610.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807221329.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807221347.png" alt="img"></p><h4 id="UML类图中的关系"><a href="#UML类图中的关系" class="headerlink" title="UML类图中的关系"></a>UML类图中的关系</h4><p>下面一张图如果可能的话应该在《c++ prime plus》中看过，可以很快理解是什么意思，我们基本上只要记得关系对应的箭头就可以了。不过不知道也没关系，我们可以快速过一遍，了解足矣。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807221552.png" alt="img"></p><h5 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h5><p>简单来说就是类实现接口，由类指向接口<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807222154.png" alt="img"></p><h5 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h5><p>指对象之间的继承关系，由子类指向父类<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807222354.png" alt="img"></p><h5 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h5><p>指这个对象在内部引用了另一个对象，关联关系内部又为依赖关联、聚合关联和组合关联三种类型</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807222649.png" alt="img"></p><h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>指A使用了B，但是A和B并没什么关系，就可以认为是依赖关系</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807223108.png" alt="img"></p><h5 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h5><p>指A拥有B，B可以属于多种A</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807223430.png" alt="img"></p><h5 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h5><p>指A包括B，同生同灭</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220807223521.png" alt="img"></p><h4 id="UML类图小结"><a href="#UML类图小结" class="headerlink" title="UML类图小结"></a>UML类图小结</h4><p>大概稍微看一下就行了，我认为看英文(is a那些)更容易理解关系是什么意思，虽然关联关系还可再分，不过基本上不搞那么详细。毕竟UML类图是为了前期快速构思类的关系的，基本上我们只用前三种关系——<strong>实现关系、泛化关系，关联关系</strong></p><h3 id="面向对象设计的一些原则"><a href="#面向对象设计的一些原则" class="headerlink" title="面向对象设计的一些原则"></a>面向对象设计的一些原则</h3><p>在了解设计模式之前，我们需要了解一些原则，这也是使用设计模式的目的之一。</p><h4 id="单一职责原则-SRP-Single-Responsibility-Principle"><a href="#单一职责原则-SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(SRP-Single Responsibility Principle)"></a>单一职责原则(SRP-Single Responsibility Principle)</h4><p>当一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责变化的时候，可能就容易导致其他职责的变化。假设一个类既可以链接管理，又可以进行数据通信，在数据通信方面由于客户需求不断变化，可能在数据通信方面不断修改导致链接管理修改起来也很麻烦，这时就应该分离这两个职责，让两个职责分别置于不同的类中。</p><h4 id="开放-封闭原则-OCP-The-Open-Closed-Principle"><a href="#开放-封闭原则-OCP-The-Open-Closed-Principle" class="headerlink" title="开放-封闭原则(OCP-The Open-Closed Principle)"></a>开放-封闭原则(OCP-The Open-Closed Principle)</h4><p>指的是在一个类中新加入的扩展的功能并不需要修改原有的功能。比如说绘制图案，原本只能绘制正方形和圆形，如果加入三角形，那在绘制图案的时候只需添加三角形这个类而不修改其他类。</p><h4 id="Liskov替换原则-LSP-Liskov-Substitution-Principle"><a href="#Liskov替换原则-LSP-Liskov-Substitution-Principle" class="headerlink" title="Liskov替换原则(LSP-Liskov Substitution Principle)"></a>Liskov替换原则(LSP-Liskov Substitution Principle)</h4><p>违反LSP原则必然违反OCP原则，任何基类可以出现的地方，子类一定可以出现，即在使用时子类可以替换掉基类但是功能不受影响</p><h4 id="依赖导致原则-DIP-Dependency-Inversion-Principle"><a href="#依赖导致原则-DIP-Dependency-Inversion-Principle" class="headerlink" title="依赖导致原则(DIP-Dependency Inversion Principle)"></a>依赖导致原则(DIP-Dependency Inversion Principle)</h4><ul><li>高层模块不应该依赖于底层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ul><p>高层模块即实践模块，比如main函数，修改了main函数的实现方式却不改变底层模块类的代码变化</p><h4 id="接口隔离原则-ISP-Interface-Segregation-Principle"><a href="#接口隔离原则-ISP-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(ISP-Interface Segregation Principle)"></a>接口隔离原则(ISP-Interface Segregation Principle)</h4><p>建立单一接口，不要建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。跟SRP差不多</p><h3 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h3><p>设计模式可以根据其意图来分类。主要分为三种类别</p><ul><li><strong>创建型模式(Creational Patterns)</strong> 提供创建对象的机制， 增加已有代码的灵活性和可复用性</li><li><strong>结构型模式(Structural Patterns)</strong> 介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效</li><li><strong>行为模式(Behavioral Patterns)</strong> 负责对象间的高效沟通和职责委派</li></ul><h3 id="创建型模式-Creational-Patterns"><a href="#创建型模式-Creational-Patterns" class="headerlink" title="创建型模式(Creational Patterns)"></a>创建型模式(Creational Patterns)</h3><h4 id="Factory-Method-工厂模式"><a href="#Factory-Method-工厂模式" class="headerlink" title="Factory Method(工厂模式)"></a>Factory Method(工厂模式)</h4><p>工厂模式是一种创建型设计模式，其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为<strong>卡车</strong>的类中。一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用（即使用 new运算符）。不用担心， 对象仍将通过new运算符创建，只是该运算符改在工厂方法中调用罢了。工厂方法返回的对象通常被称作 “产品”。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808133543.png" alt="img"></p><p>这样子，我们可以在子类中重写工厂方法。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808134434.png" alt="img"></p><p>举例来说，<strong>RoadLogically</strong>类的工厂方法也就是<strong>createTransport()<strong>返回的便是</strong>Truck</strong>对象，而<strong>SeaLogistics</strong>返回的便是<strong>Ship</strong>对象。</p><p>调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的运输。 客户端知道所有运输对象都提供交付方法，但是并不关心其具体实现方式。</p><h5 id="工厂方法模式结构"><a href="#工厂方法模式结构" class="headerlink" title="工厂方法模式结构"></a>工厂方法模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808164835.png" alt="img"></p><p>由图可以看到这个结构被分为了两部分，一个Creator部分，一个Product部分，Creator部分负责创建，同时提供SomeOperation()进行操作，而SomeOperation()内部是获得具体物体的接口，并且做出具体实现。</p><p>1.<strong>产品(Product)</strong> 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p><p>2.<strong>具体产品(Con­crete Prod­ucts)</strong> 是产品接口的不同实现。</p><p>3.<strong>创建者(Cre­ator)</strong> 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p><p>你可以将工厂方法声明为抽象方法，强制要求每个子类以不同方式实现该方法.或者，你也可以在基础工厂方法中返回默认产品类型。</p><p>注意，尽管它的名字是创建者，但它最主要的职责并不是创建产品。一般来说，创建者类包含一些与产品相关的核心业务逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来.打个比方，大型软件开发公司拥有程序员培训部门。但是，这些公司的主要工作还是编写代码，而非生产程序员。</p><p>4.<strong>具体创建者(Con­crete Cre­ators)</strong> 将会重写基础工厂方法，使其返回不同类型的产品。</p><p>注意，并不一定每次调用工厂方法都会创建新的实例。工厂方法也可以返回缓存、对象池或其他来源的已有对象。</p><h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><p>根据上图，我们可以快速的做出一个基于运输例子的伪代码(并不是很伪)，如果有新的种类，比如说飞机，那么修改就很容易了，并不需要修改原来的代码，只需要多写一个<strong>AirLogistics类</strong>继承<strong>Logistics类</strong>，写一个<strong>Plane</strong>继承<strong>Transport接口</strong>，甚至连父类的Logistics都不用动，这很好的践行了SRP和OCP原则。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Logisitic抽象类，也就是Creator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Logisitic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//CreateTransport也就是工厂方法(FactoryMethod)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Transport <span class="title">CreateTransport</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">planDelivery</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transport t = CreateTransport();</span><br><span class="line">        t.Deliver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RoadLogistics</span> : <span class="title">Logisitic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> overrride Transport <span class="title">CreateTransport</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回的是产品类，而不是本尊</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Truck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SeaLogistics</span> : <span class="title">Logisitic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> overrride Transport <span class="title">CreateTransport</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ship();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Transport接口，也就是Product</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Transport</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deliver</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">Transport</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deliver</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Ship</span> : <span class="title">Transport</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deliver</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适合工厂模式的地方"><a href="#适合工厂模式的地方" class="headerlink" title="适合工厂模式的地方"></a>适合工厂模式的地方</h5><ul><li>当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。</li><li>如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。</li><li>如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。</li></ul><h5 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h5><p><strong>优点</strong>：</p><ul><li>你可以避免创建者和具体产品之间的紧密耦合。</li><li>符合SRP</li><li>符合OCP</li></ul><p><strong>缺点</strong>：</p><ul><li>应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。简单来说，就是在工作初期使用<strong>工厂模式</strong>（比较简单，而且容易通过子类修改),但代码复杂时会演化成其他模式</li></ul><h4 id="Abstract-Factory-抽象工厂模式"><a href="#Abstract-Factory-抽象工厂模式" class="headerlink" title="Abstract Factory(抽象工厂模式)"></a>Abstract Factory(抽象工厂模式)</h4><p>抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。</p><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>假设你正在开发一款家具商店模拟器。你的代码中包括一些类，用于表示：<br>1.一系列相关产品，例如 椅子Chair、沙发Sofa和咖啡桌Cof­fee­Table。<br>2.系列产品的不同变体。例如，你可以使用现代Mod­ern、维多利亚Vic­to­ri­an、​装饰风艺术Art­Deco等风格生成椅子、沙发和咖啡桌。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808150223.png" alt="img"></p><p>你需要设法单独生成每件家具对象，这样才能确保其风格一致。如果顾客收到的家具风格不一样，他们可不会开心。<br>此外，你也不希望在添加新产品或新风格时修改已有代码。家具供应商对于产品目录的更新非常频繁，你不会想在每次更新时都去修改核心代码的。</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>首先， 抽象工厂模式建议为系列中的<strong>每件产品</strong>明确声明接口（例如椅子、沙发或咖啡桌）。然后，确保所有产品变体都继承这些接口。例如，所有风格的椅子都实现椅子接口；所有风格的咖啡桌都实现咖啡桌接口，以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808150715.png" alt="img"></p><p>接下来，我们需要声明抽象工厂——包含系列中所有产品构造方法的接口。例如cre­ate­Chair创建椅子、​cre­ate­Sofa创建沙发和cre­ate­Cof­fee­Table创建咖啡桌.这些方法必须返回抽象产品类型，即我们之前抽取的那些接口：椅子,沙发和咖啡桌等等。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808150835.png" alt="img"></p><p>那么该如何处理产品变体呢？对于系列产品的每个变体，我们都将基于抽象工厂接口创建不同的工厂类。每个工厂类都只能返回特定类别的产品，例如，​现代家具工厂Mod­ern­Fur­ni­ture­Fac­to­ry只能创建现代椅子Mod­ern­Chair、现代沙发Mod­ern­Sofa和现代咖啡桌Mod­ern­Cof­fee­Table对象。</p><p>客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。</p><h5 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808151005.png" alt="img"></p><p>1.<strong>抽象产品(Abstract Prod­uct)</strong> 为构成系列产品的一组不同但相关的产品声明接口。</p><p>2.<strong>具体产品(Con­crete Prod­uct)</strong> 是抽象产品的多种不同类型实现。所有变体 （维多利亚&#x2F;现代）都必须实现相应的抽象产品 （椅子&#x2F;沙发）。</p><p>3.<strong>抽象工厂(Abstract Fac­to­ry)</strong> 接口声明了一组创建各种抽象产品的方法。</p><p>4.<strong>具体工厂(Con­crete Fac­to­ry)</strong> 实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体。</p><p>5.尽管具体工厂会对具体产品进行初始化，其构建方法签名必须返回相应的抽象产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。<strong>客户端 (Client)</strong> 只需通过抽象接口调用工厂和产品对象，就能与任何具体工厂&#x2F;产品变体交互。</p><h5 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h5><p>同样是根据抽象工厂模式结构的图，我们快速的写一个基于家具抽象工厂的不是那么伪的伪代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随便写一下代码就会很多，所以这里只写出了一部分代码</span></span><br><span class="line"><span class="comment">//抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">FurnitureFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建椅子</span></span><br><span class="line">    <span class="function">Chair <span class="title">CreateChair</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建咖啡桌</span></span><br><span class="line">    <span class="function">CoffeTable <span class="title">CreateCoffeeTable</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建沙发</span></span><br><span class="line">    <span class="function">Sofa <span class="title">CreateSofa</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VictorianFurnitureFactory</span> : <span class="title">FurnitureFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Chair <span class="title">CreateChair</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VictorianChair();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoffeTable <span class="title">CreateCoffeeTable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VictorianCoffeeTable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sofa <span class="title">CreateSofa</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VictorianSofa();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernFurnitureFactory</span> : <span class="title">FurnitureFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Chair <span class="title">CreateChair</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModernChair();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CoffeTable <span class="title">CreateCoffeeTable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModenCoffeeTable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sofa <span class="title">CreateSofa</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModernSofa();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品 Chair类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Chair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HasLegs</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SitOn</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VictorianChair</span> : <span class="title">Chair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HasLegs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SitOn</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernChair</span> : <span class="title">Chair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HasLegs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SitOn</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品 CoffeeTable类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CoffeeTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HasLegs</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VictorianCoffeeTable</span> : <span class="title">CoffeeTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HasLegs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernCoffeeTable</span> : <span class="title">CoffeeTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HasLegs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用抽象工厂代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// - factory:AbstractFactory</span></span><br><span class="line">    <span class="keyword">private</span> FurnitureFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span>(<span class="params">FurnitureFactory factory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeOperation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Chair chair = factory.CreateChair();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适合抽象工厂模式的地方"><a href="#适合抽象工厂模式的地方" class="headerlink" title="适合抽象工厂模式的地方"></a>适合抽象工厂模式的地方</h5><ul><li>如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂</li></ul><h5 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a>抽象工厂模式的优缺点</h5><p><strong>优点</strong>:</p><ul><li>你可以确保同一工厂生成的产品相互匹配</li><li>你可以避免客户端和具体产品代码的耦合</li><li>符合SRP</li><li>符合OCP</li></ul><p><strong>缺点</strong>:</p><ul><li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li></ul><h4 id="Builder-生成器模式"><a href="#Builder-生成器模式" class="headerlink" title="Builder(生成器模式)"></a>Builder(生成器模式)</h4><p>生成器模式是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><h5 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h5><p>假设有这样一个复杂对象，在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中；甚至还有更糟糕的情况，那就是这些代码散落在客户端代码的多个位置。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808163211.png" alt="img"></p><p>最简单的方法是扩展房屋基类，然后创建一系列涵盖所有参数组合的子类。但最终你将面对相当数量的子类。任何新增的参数（例如门廊类型）都会让这个层次结构更加复杂。</p><p>另一种方法则无需生成子类。你可以在房屋基类中创建一个包括所有可能参数的超级构造函数，并用它来控制房屋对象。这种方法确实可以避免生成子类，但它却会造成另外一个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808163441.png" alt="img"></p><p>通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。</p><h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><p>生成器模式建议将对象构造代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808164126.png" alt="img"></p><p>该模式会将对象构造过程<strong>划分为一组步骤</strong>，比如build­Walls创建墙壁和build­Door创建房门创建房门等。每次创建对象时，你都需要通过生成器对象执行一系列步骤。重点在于你无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤即可。</p><p>当你需要创建<strong>不同形式的产品</strong>时，其中的一些构造步骤可能需要不同的实现。例如，木屋的房门可能需要使用木头制造，而城堡的房门则必须使用石头制造。在这种情况下，你可以创建多个不同的生成器，用不同方式实现一组相同的创建步骤。然后你就可以在创建过程中使用这些生成器（例如按顺序调用多个构造步骤）来生成不同类型的对象。</p><p><strong>主管(Director)</strong> :<br>你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现。<br>严格来说，你的程序中并不一定需要主管类。客户端代码可直接以特定顺序调用创建步骤。不过，主管类中非常适合放入各种例行构造流程，以便在程序中反复使用。<br>此外，对于客户端代码来说，主管类完全隐藏了产品构造细节。客户端只需要将一个生成器与主管类关联，然后使用主管类来构造产品，就能从生成器处获得构造结果了。</p><h5 id="生成器模式结构"><a href="#生成器模式结构" class="headerlink" title="生成器模式结构"></a>生成器模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808164617.png" alt="img"></p><p>1.<strong>生成器(Builder)</strong> 接口声明在所有类型生成器中通用的产品构造步骤。</p><p>2.<strong>具体生成器(Con­crete Builders)</strong> 提供构造过程的不同实现。具体生成器也可以构造不遵循通用接口的产品。</p><p>3.<strong>产品(Prod­ucts)</strong> 是最终生成的对象。由不同生成器构造的产品无需属于同一类层次结构或接口。</p><p>4.<strong>主管(Direc­tor)</strong> 类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。</p><p>5.<strong>客户端(Client)</strong> 必须将某个生成器对象与主管类关联。一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。此后主管类就能使用生成器对象完成后续所有的构造任务。但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器。</p><h5 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h5><p>感觉上面的例子并不是很直接，所以我们下面有一个关于生成器模式的例子演示了你可以如何复用相同的对象构造代码来生成不同类型的产品——例如汽车（Car）——及其相应的使用手册（Man­u­al）。<br>生成器模式可以很方便的写出<strong>实现同类产品但是实现步骤不同</strong>，它会将一个的制造过程分为<strong>一系列步骤</strong>，用Director类在生成不同产品的时候你可以根据不同需求在同类产品选择相应的步骤，比如Car有很多种，在Builder我们有建造Car的所有步骤，但是根据需求只需要使用一些步骤。也就是说，在相应的Builder类中的方法，我们尽量的<strong>详细</strong>，这样在Director中我们能够建造更多类型的产品。<br>仍然是写一个并不是很伪的伪代码。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220808165345.png" alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义</span></span><br><span class="line"><span class="comment">//生成器接口声明了创建产品不同对象的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Product类</span></span><br><span class="line"><span class="comment">//一辆车有很多种类，SUV，小轿车等等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Product类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Manual</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Builder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSeats</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEngine</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarBuilder</span> : <span class="title">Builder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarBuilder</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.car = <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSeats</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能</span></span><br><span class="line">    <span class="comment">// 会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中</span></span><br><span class="line">    <span class="comment">// 声明这些方法（至少在静态类型的编程语言中是这样的）。</span></span><br><span class="line">    <span class="comment">//通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的准备</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car result = <span class="keyword">this</span>.car;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.Reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarManualBuilder</span> : <span class="title">Builder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Manual manual = <span class="keyword">new</span> Manual();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarManualBuilder</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.manual = <span class="keyword">new</span> Manual();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSeats</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Manual <span class="title">getResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Manual result = <span class="keyword">this</span>.manual;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.Reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主管类只负责按照特定顺序执行生成步骤</span></span><br><span class="line"><span class="comment">//由于客户端可以直接控制生成器，所以严格意义上来说主管类并不是必需的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Director</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder _builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder builder</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span>&#123; _builder = <span class="keyword">value</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeSUV</span>(<span class="params">Builder builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._builder.Reset();</span><br><span class="line">        <span class="keyword">this</span>._builder.setSeat(...);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeSportCar</span>(<span class="params">Builder builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._builder.Reset();</span><br><span class="line">        <span class="keyword">this</span>._builder.setSeat(...);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    Director director = <span class="keyword">new</span> Director();</span><br><span class="line"></span><br><span class="line">    CarBuilder builder = <span class="keyword">new</span> CarBuilder();</span><br><span class="line"></span><br><span class="line">    director.MakeSportsCar(builder);</span><br><span class="line"></span><br><span class="line">    Car car = builder.getResult();</span><br><span class="line"></span><br><span class="line">    CarManualBuilder builder = <span class="keyword">new</span> CarManualBuilder();</span><br><span class="line">    director.MakeSportsCar(builder);</span><br><span class="line"></span><br><span class="line">    Manual manual = builder.GetResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适合生成器模式的地方"><a href="#适合生成器模式的地方" class="headerlink" title="适合生成器模式的地方"></a>适合生成器模式的地方</h5><ul><li>使用生成器模式可避免 <strong>“重叠构造函数 (tele­scop­ing con­struc­tor)”</strong> 的出现。即下列代码</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pizza</span> &#123;</span><br><span class="line">    Pizza(<span class="built_in">int</span> size) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="built_in">int</span> size, boolean cheese) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="built_in">int</span> size, boolean cheese, boolean pepperoni) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当你希望使用代码<strong>创建不同形式的产品</strong> （例如石头或木头房屋） 时，可使用生成器模式。</li><li>使用生成器构造组合树或其他复杂对象。生成器模式让你能分步骤构造产品。你可以延迟执行某些步骤而不会影响最终产品。你甚至可以递归调用这些步骤，这在创建对象树时非常方便。<strong>生成器在执行制造步骤时，不能对外发布未完成的产品</strong>。这可以避免客户端代码获取到不完整结果对象的情况。</li></ul><h5 id="生成器模式的优缺点"><a href="#生成器模式的优缺点" class="headerlink" title="生成器模式的优缺点"></a>生成器模式的优缺点</h5><p><strong>优点</strong> :</p><ul><li>你可以分步创建对象，暂缓创建步骤或递归运行创建步骤。</li><li>生成不同形式的产品时，你可以复用相同的制造代码。</li><li>符合SRP</li></ul><p><strong>缺点</strong> :</p><ul><li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li></ul><h4 id="Prototype-原型模式"><a href="#Prototype-原型模式" class="headerlink" title="Prototype(原型模式)"></a>Prototype(原型模式)</h4><p>原型模式是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。(即当你需要一个相同的类，但是重新设置参数很繁琐，原型模式能让你很快地创造一个新的除了名字不一样其他一摸一样的变量)</p><h5 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h5><p>如果你有一个对象，并希望生成与其完全相同的一个复制品，你该如何实现呢？首先，你必须新建一个属于相同类的对象。然后，你必须遍历原始对象的所有成员变量，并将成员变量值复制到新对象中。但有个小问题。并非所有对象都能通过这种方式进行复制，因为有些对象可能拥有私有成员变量，它们在对象本身以外是不可见的。</p><p>直接复制还有另外一个问题。因为你必须知道对象所属的类才能创建复制品，所以代码必须依赖该类。即使你可以接受额外的依赖性，那还有另外一个问题：有时你只知道对象所实现的接口，而不知道其所属的具体类，比如可向方法的某个参数传入实现了某个接口的任何对象。</p><h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><p>原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象，同时又无需将代码和对象所属类耦合。通常情况下，这样的接口中仅包含一个<strong>克隆方法</strong>。</p><p>所有的类对继承的通用接口的克隆方法实现都非常相似。都是创建一个当前类的对象，然后返回一个类——即 return new Class(this);通常在构造函数中先写好初始化的样式。</p><p>其实在c#语言中已经有提供的<strong>ICloneable接口</strong>进行复制,就是立即可用的原型模式，但是我们可以仍然去看看并且理解这个模式是如何运行的。</p><h5 id="原型结构模式"><a href="#原型结构模式" class="headerlink" title="原型结构模式"></a>原型结构模式</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220809232541.png" alt="img"></p><p>1.<strong>原型(Pro­to­type)</strong> 接口将对克隆方法进行声明。在绝大多数情况下，其中只会有一个名为 clone克隆的方法。</p><p>2.<strong>具体原型(Con­crete Pro­to­type)</strong> 类将实现克隆方法。除了将原始对象的数据复制到克隆体中之外，该方法有时还需处理克隆过程中的极端情况，例如克隆关联对象和梳理递归依赖等等。</p><p>3.<strong>客户端(Client)</strong> 可以复制实现了原型接口的任何对象。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220809233359.png" alt="img"></p><p>1.<strong>原型注册表(Pro­to­type Reg­istry)</strong> 提供了一种访问常用原型的简单方法，其中存储了一系列可供随时复制的预生成对象。最简单的注册表原型是一个名称 → 原型的哈希表。但如果需要使用名称以外的条件进行搜索，你可以创建更加完善的注册表版本。</p><h5 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h5><p>我会在这里附上一份伪代码以及c#官方提供的代码顺便学习这个接口。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220809233553.png" alt="img"></p><p><strong>一份伪代码</strong> : 通过阅读可以快速了解是如何clone的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础原型。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span> <span class="title">is</span></span><br><span class="line">    <span class="title">field</span> <span class="title">X</span>: <span class="title">int</span></span><br><span class="line">    <span class="title">field</span> <span class="title">Y</span>: <span class="title">int</span></span><br><span class="line">    <span class="title">field</span> <span class="title">color</span>: <span class="title">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常规构造函数。</span></span><br><span class="line">    <span class="title">constructor</span> <span class="title">Shape</span>() <span class="title">is</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span><br><span class="line">    <span class="title">constructor</span> <span class="title">Shape</span>(<span class="title">source</span>: <span class="title">Shape</span>) <span class="title">is</span></span><br><span class="line">        <span class="title">this</span>()</span><br><span class="line">        <span class="title">this.X</span> = source.X</span><br><span class="line">        <span class="keyword">this</span>.Y = source.Y</span><br><span class="line">        <span class="keyword">this</span>.color = source.color</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clone（克隆）操作会返回一个形状子类。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> method <span class="title">clone</span>():Shape</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span></span><br><span class="line"><span class="function"><span class="comment">// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span></span><br><span class="line"><span class="function"><span class="comment">// 成的克隆对象。这可以保持克隆结果的一致。</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Rectangle extends Shape <span class="keyword">is</span></span></span><br><span class="line"><span class="function">    field width: <span class="built_in">int</span></span></span><br><span class="line"><span class="function">    field height: <span class="built_in">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">Rectangle</span>(<span class="params">source: Rectangle</span>) <span class="keyword">is</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 需要调用父构造函数来复制父类中定义的私有成员变量。</span></span></span><br><span class="line"><span class="function">        <span class="title">super</span>(<span class="params">source</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.width</span> = source.width</span><br><span class="line">        <span class="keyword">this</span>.height = source.<span class="function">height</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">clone</span>():Shape <span class="keyword">is</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">Rectangle</span>(<span class="params"><span class="keyword">this</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Circle extends Shape <span class="keyword">is</span></span></span><br><span class="line"><span class="function">    field radius: <span class="built_in">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">Circle</span>(<span class="params">source: Circle</span>) <span class="keyword">is</span></span></span><br><span class="line"><span class="function">        <span class="title">super</span>(<span class="params">source</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.radius</span> = source.<span class="function">radius</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">clone</span>():Shape <span class="keyword">is</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">Circle</span>(<span class="params"><span class="keyword">this</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 客户端代码中的某个位置。</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Application <span class="keyword">is</span></span></span><br><span class="line"><span class="function">    field shapes: array of Shape</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">Application</span>() <span class="keyword">is</span></span></span><br><span class="line"><span class="function">        Circle circle</span> = <span class="keyword">new</span> Circle()</span><br><span class="line">        circle.X = <span class="number">10</span></span><br><span class="line">        circle.Y = <span class="number">10</span></span><br><span class="line">        circle.radius = <span class="number">20</span></span><br><span class="line">        shapes.<span class="keyword">add</span>(circle)</span><br><span class="line"></span><br><span class="line">        Circle anotherCircle = circle.clone()</span><br><span class="line">        shapes.<span class="keyword">add</span>(anotherCircle)</span><br><span class="line">        <span class="comment">// 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内</span></span><br><span class="line">        <span class="comment">// 容完全一样。</span></span><br><span class="line"></span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle()</span><br><span class="line">        rectangle.width = <span class="number">10</span></span><br><span class="line">        rectangle.height = <span class="number">20</span></span><br><span class="line">        shapes.<span class="keyword">add</span>(rectangle)</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">businessLogic</span>() <span class="keyword">is</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 其完全相同的复制品。</span></span></span><br><span class="line"><span class="function">        Array shapesCopy</span> = <span class="keyword">new</span> Array of Shapes.</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。</span></span><br><span class="line">        <span class="comment">// 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`</span></span><br><span class="line">        <span class="comment">// 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，</span></span><br><span class="line">        <span class="comment">// 我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span><br><span class="line">        <span class="keyword">foreach</span> (s <span class="keyword">in</span> shapes) <span class="keyword">do</span></span><br><span class="line">            shapesCopy.<span class="keyword">add</span>(s.clone())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有</span></span><br><span class="line">        <span class="comment">// 子元素的复制品。</span></span><br></pre></td></tr></table></figure><p><strong>c#提供的ICloneable接口的代码</strong> : 通过这里我们可以看见不需要写构造函数，只需要用到<strong>MemberwiseClone</strong>这个函数就可以很快地完成</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RefactoringGuru.DesignPatterns.Prototype.Conceptual</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">        <span class="keyword">public</span> DateTime BirthDate;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">        <span class="keyword">public</span> IdInfo IdInfo;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//浅复制，只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存</span></span><br><span class="line">        <span class="comment">//也就是说不管是修改原对象还是新对象两个都会一起改变</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">ShallowCopy</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深复制，会创造一个新的对象，但不与于原对象共享内存</span></span><br><span class="line">        <span class="comment">//修改新旧对象互不影响</span></span><br><span class="line">        <span class="comment">//所以我们可以认识到原型模式是深复制</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">DeepCopy</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person clone = (Person)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">            clone.IdInfo = <span class="keyword">new</span> IdInfo(IdInfo.IdNumber);</span><br><span class="line">            clone.Name = String.Copy(Name);</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IdInfo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> IdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IdInfo</span>(<span class="params"><span class="built_in">int</span> idNumber</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.IdNumber = idNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试例子，通过例子我们可以快速的理解深复制与浅复制之间的区别</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">            p1.Age = <span class="number">42</span>;</span><br><span class="line">            p1.BirthDate = Convert.ToDateTime(<span class="string">&quot;1977-01-01&quot;</span>);</span><br><span class="line">            p1.Name = <span class="string">&quot;Jack Daniels&quot;</span>;</span><br><span class="line">            p1.IdInfo = <span class="keyword">new</span> IdInfo(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Perform a shallow copy of p1 and assign it to p2.</span></span><br><span class="line">            Person p2 = p1.ShallowCopy();</span><br><span class="line">            <span class="comment">// Make a deep copy of p1 and assign it to p3.</span></span><br><span class="line">            Person p3 = p1.DeepCopy();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Display values of p1, p2 and p3.</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Original values of p1, p2, p3:&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;   p1 instance values: &quot;</span>);</span><br><span class="line">            DisplayValues(p1);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;   p2 instance values:&quot;</span>);</span><br><span class="line">            DisplayValues(p2);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;   p3 instance values:&quot;</span>);</span><br><span class="line">            DisplayValues(p3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Change the value of p1 properties and display the values of p1,</span></span><br><span class="line">            <span class="comment">// p2 and p3.</span></span><br><span class="line">            p1.Age = <span class="number">32</span>;</span><br><span class="line">            p1.BirthDate = Convert.ToDateTime(<span class="string">&quot;1900-01-01&quot;</span>);</span><br><span class="line">            p1.Name = <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">            p1.IdInfo.IdNumber = <span class="number">7878</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\nValues of p1, p2 and p3 after changes to p1:&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;   p1 instance values: &quot;</span>);</span><br><span class="line">            DisplayValues(p1);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;   p2 instance values (reference values have changed):&quot;</span>);</span><br><span class="line">            DisplayValues(p2);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;   p3 instance values (everything was kept the same):&quot;</span>);</span><br><span class="line">            DisplayValues(p3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayValues</span>(<span class="params">Person p</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;      Name: &#123;0:s&#125;, Age: &#123;1:d&#125;, BirthDate: &#123;2:MM/dd/yy&#125;&quot;</span>,</span><br><span class="line">                p.Name, p.Age, p.BirthDate);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;      ID#: &#123;0:d&#125;&quot;</span>, p.IdInfo.IdNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The example displays the following output:</span></span><br><span class="line"><span class="comment">//       Original values of p1 and p2:</span></span><br><span class="line"><span class="comment">//          p1 instance values:</span></span><br><span class="line"><span class="comment">//             Name: Sam, Age: 42</span></span><br><span class="line"><span class="comment">//             Value: 6565</span></span><br><span class="line"><span class="comment">//          p2 instance values:</span></span><br><span class="line"><span class="comment">//             Name: Sam, Age: 42</span></span><br><span class="line"><span class="comment">//             Value: 6565</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       Values of p1 and p2 after changes to p1:</span></span><br><span class="line"><span class="comment">//          p1 instance values:</span></span><br><span class="line"><span class="comment">//             Name: Frank, Age: 32</span></span><br><span class="line"><span class="comment">//             Value: 7878</span></span><br><span class="line"><span class="comment">//          p2 instance values:</span></span><br><span class="line"><span class="comment">//             Name: Sam, Age: 42</span></span><br><span class="line"><span class="comment">//             Value: 7878</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       Values of p1 and p3 after changes to p1:</span></span><br><span class="line"><span class="comment">//          p1 instance values:</span></span><br><span class="line"><span class="comment">//             Name: George, Age: 39</span></span><br><span class="line"><span class="comment">//             Value: 8641</span></span><br><span class="line"><span class="comment">//          p3 instance values:</span></span><br><span class="line"><span class="comment">//             Name: Frank, Age: 32</span></span><br><span class="line"><span class="comment">//             Value: 7878</span></span><br></pre></td></tr></table></figure><h5 id="适合原型模式的地方"><a href="#适合原型模式的地方" class="headerlink" title="适合原型模式的地方"></a>适合原型模式的地方</h5><ul><li><p>如果你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式。</p></li><li><p>如果子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象。</p></li></ul><h5 id="原型模式的优缺点"><a href="#原型模式的优缺点" class="headerlink" title="原型模式的优缺点"></a>原型模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以克隆对象，而无需与它们所属的具体类相耦合。</li><li>你可以克隆预生成原型，避免反复运行初始化代码。</li><li>你可以更方便地生成复杂对象。</li><li>你可以用继承以外的方式来处理复杂对象的不同配置。</li></ul><p><strong>缺点</strong> ：</p><ul><li>克隆包含循环引用的复杂对象可能会非常麻烦。</li></ul><h4 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton(单例模式)"></a>Singleton(单例模式)</h4><p>单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p><h5 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h5><p>单例模式是一个十分常用的设计模式，在Unity中，它常常被用在是<strong>Manager</strong>类中，比如<strong>SceneManager</strong>,<strong>UIManager</strong>,<strong>AudioManager</strong>等等。也就是说在代码中会有一种全局类，各个模块都可以调用它。虽然它违反了单一职责原则，但由于使用起来十分方便，但还是很香的（跟全局变量一样）。</p><p>总结下来，单例模式的特点：</p><ul><li>保证一个类只有一个实例</li><li>为该实例提供一个全局访问节点</li></ul><h5 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h5><p>所有单例的实现都包含以下两个相同的步骤：</p><ul><li>将默认构造函数设为<strong>私有</strong>，防止其他对象使用单例类的new运算符。</li><li>新建一个静态构建方法作为构造函数。该函数会 “偷偷” 调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。<br>如果你的代码能够访问单例类，那它就能调用单例类的静态方法。无论何时调用该方法，它总是会返回相同的对象。</li></ul><h5 id="单例模式结构"><a href="#单例模式结构" class="headerlink" title="单例模式结构"></a>单例模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220810001041.png" alt="img"></p><p>1.<strong>单例(Sin­gle­ton)</strong> 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。</p><p>单例的构造函数必须对<strong>客户端(Client)</strong> 代码隐藏。调用获取实例方法必须是获取单例对象的唯一方式。</p><h5 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h5><p>由于单例模式实现过于简单，我们这里不讲伪代码，反而我们来直接看看各种的单例模式。</p><p><strong>懒汉单例模式</strong> ：在第一次调用的时候实例化本身，在并发环境下，可能出现多个本身对象。所以线程是不安全的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将构造函数设置为私有，防止用户创造实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单的线程安全的懒汉单例模式</strong> :<br>需要注意的是，这里使用了一个<strong>private static object</strong>变量进行锁定，这是因为当如果对一个外部类可以访问的对象进行锁定时会导致性能低下甚至死锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将构造函数设置为私有，防止用户创造实例</span></span><br><span class="line">    <span class="keyword">private</span> Singleton&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> obj = <span class="keyword">new</span> <span class="built_in">object</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span>(obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双重检查锁定的懒汉单例模式</strong> :要比前者方法更加完美</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将构造函数设置为私有，防止用户创造实例</span></span><br><span class="line">    <span class="keyword">private</span> Singleton&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> obj = <span class="keyword">new</span> <span class="built_in">object</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(instace == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span>(obj)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉单例模式</strong> :在类初始化时，已经自行实例化一个静态对象，所以本身就是线程安全的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉单例模式实现十分简单，同时也是线程安全的，要相比懒汉单例模式更加好用一些。</p><h5 id="适合单例模式的地方"><a href="#适合单例模式的地方" class="headerlink" title="适合单例模式的地方"></a>适合单例模式的地方</h5><ul><li>如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。</li><li>如果你需要更加严格地控制全局变量，可以使用单例模式。</li></ul><h5 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以保证一个类只有一个实例。</li><li>你获得了一个指向该实例的全局访问节点。</li><li>仅在首次请求单例对象时对其进行初始化。</li></ul><p><strong>缺点</strong> ：</p><ul><li>违反了单一职责原则。该模式同时解决了两个问题。</li><li>单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。</li><li>该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。</li><li>单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。要么干脆不编写测试代码，或者不使用单例模式。</li><li>类似全局变量，在阅读代码时会产生一定困难，不知道哪里而来。</li></ul><h3 id="结构型模式-Structural-Patterns"><a href="#结构型模式-Structural-Patterns" class="headerlink" title="结构型模式(Structural Patterns)"></a>结构型模式(Structural Patterns)</h3><h4 id="Adapter-适配器模式"><a href="#Adapter-适配器模式" class="headerlink" title="Adapter(适配器模式)"></a>Adapter(适配器模式)</h4><p>适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816154433.png" alt="img"></p><p>上图是一个十分直观的图</p><h5 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h5><p>假如你正在开发一款股票市场监测程序，它会从不同来源下载 XML 格式的股票数据，然后向用户呈现出美观的图表。在开发过程中，你决定在程序中整合一个第三方智能分析函数库。但是遇到了一个问题，那就是分析函数库只兼容 JSON 格式的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816154342.png" alt="img"></p><h5 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h5><p>你可以创建一个<strong>适配器</strong>。这是一个特殊的对象，能够转换对象接口，使其能与其他对象进行交互。</p><p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。被封装的对象甚至察觉不到适配器的存在。例如，你可以使用一个将所有数据转换为英制单位（如英尺和英里）的适配器封装运行于米和千米单位制中的对象。</p><p>适配器不仅可以转换不同格式的数据，其还有助于采用不同接口的对象之间的合作。它的运作方式如下：</p><ul><li>适配器实现与其中一个现有对象兼容的接口。</li><li>现有对象可以使用该接口安全地调用适配器方法。</li><li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816154725.png" alt="img"></p><h5 id="适配器模式结构"><a href="#适配器模式结构" class="headerlink" title="适配器模式结构"></a>适配器模式结构</h5><p><strong>对象适配器</strong> ：适配器实现了其中一个对象的接口，并对另一个对象进行封装。所有流行的编程语言都可以实现适配器。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816154822.png" alt="img"></p><p>1.<strong>客户端(Client)</strong> 是包含当前程序业务逻辑的类。<br>2.<strong>客户端接口(Client Inter­face)</strong> 描述了其他类与客户端代码合作时必须遵循的协议。</p><p>3.<strong>服务(Ser­vice)</strong> 中有一些功能类 （通常来自第三方或遗留系统）。客户端与其接口不兼容，因此无法直接调用其功能。</p><p>4.<strong>适配器(Adapter)</strong> 是一个可以同时与客户端和服务交互的类：它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用。</p><p>5.客户端代码只需通过接口与适配器交互即可，无需与具体的适配器类耦合。因此，你可以向程序中添加新类型的适配器而无需修改已有代码。这在服务类的接口被更改或替换时很有用：你无需修改客户端代码就可以创建新的适配器类。</p><p><strong>类适配器</strong> ：这一实现使用了继承机制：适配器同时继承两个对象的接口。请注意，这种方式仅能在支持多重继承的编程语言中实现，例如C++。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816155303.png" alt="img"></p><p>1.<strong>类适配器</strong>不需要封装任何对象，因为它同时继承了客户端和服务的行为。适配功能在重写的方法中完成。最后生成的适配器可替代已有的客户端类进行使用。</p><h5 id="伪代码-5"><a href="#伪代码-5" class="headerlink" title="伪代码"></a>伪代码</h5><p>仅仅看结构也是很难理解是啥意思的，来看看经典的方钉圆孔问题，如何将方钉用适配器转化成圆钉来适配圆孔。一样照着之前，写一个不是那么伪的伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816155544.png" alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆孔类(RoundHole)和圆钉类(RoundPeg)互相兼容 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RoundHole</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundHole</span>(<span class="params"><span class="built_in">int</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getRadius</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">fits</span>(<span class="params">RoundPeg peg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getRadius() &gt;= peg.getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RoundPeg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundPeg</span>(<span class="params"><span class="built_in">int</span> radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getRadius</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不兼容的方钉(SquarePeg)类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SquarePeg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SquarePeg</span>(<span class="params"><span class="built_in">int</span> width</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getWidth</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器类其实就是圆钉的子类，算是特殊的圆钉类，将获得的方钉“打磨”成圆钉</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SquarePegAdapter</span> : <span class="title">RoundPeg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//适配器通常包含一个要被转换的实例</span></span><br><span class="line">    <span class="keyword">private</span> SquarePeg peg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SquarePegAdapter</span>(<span class="params">SquarePeg peg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.peg = peg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getRadius</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> peg.getWidth() * Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line">hole = <span class="keyword">new</span> RoundHole(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">_sqpeg = <span class="keyword">new</span> SquarePeg(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">sqpeg_adapter = <span class="keyword">new</span> SquarePegAdapter(_sqpeg);</span><br><span class="line">hole.fits(sqpeg_adapter);</span><br><span class="line"><span class="comment">//变换之后，我们进行操作的就是适配器类而不是方钉类了</span></span><br></pre></td></tr></table></figure><h5 id="适合适配器模式的地方"><a href="#适合适配器模式的地方" class="headerlink" title="适合适配器模式的地方"></a>适合适配器模式的地方</h5><ul><li>当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类。也就是创造一个中间层类，如果你在前人的代码修改但是又不打算修改太多</li><li>如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</li></ul><h5 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>符合SRP</li><li>符合OCP</li></ul><p><strong>缺点</strong> ：</p><ul><li>代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单。</li></ul><h4 id="Bridge-桥接模式"><a href="#Bridge-桥接模式" class="headerlink" title="Bridge(桥接模式)"></a>Bridge(桥接模式)</h4><p>桥接模式是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p><h5 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816163009.png" alt="img"></p><p>假如你有一个几何形状<strong>Shape</strong>类，从它能扩展出两个子类：​圆形<strong>Cir­cle</strong>和方形<strong>Square</strong>。你希望对这样的类层次结构进行扩展以使其包含颜色，所以你打算创建名为红色<strong>Red</strong>和 蓝色<strong>Blue</strong>的形状子类。但是，由于你已有两个子类，所以总共需要创建四个类才能覆盖所有组合，例如蓝色圆形<strong>Blue­Cir­cle</strong>和红色方形<strong>Red­Square</strong>。在层次结构中新增形状和颜色将导致代码复杂程度指数增长。例如添加三角形状，你需要新增两个子类，也就是每种颜色一个；此后新增一种新颜色需要新增三个子类，即每种形状一个。如此以往，情况会越来越糟糕。</p><h5 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h5><p>问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。这在处理类继承时是很常见的问题。</p><p>桥接模式通过将继承改为组合的方式来解决这个问题。具体来说，就是抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象，从而使得一个类不必拥有所有的状态和行为。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816163706.png" alt="img"></p><p>根据该方法，我们可以将颜色相关的代码抽取到拥有 红色和 蓝色两个子类的颜色类中，然后在形状类中添加一个指向某一颜色对象的引用成员变量。现在，形状类可以将所有与颜色相关的工作委派给连入的颜色对象。这样的引用就成为了 形状和 颜色之间的桥梁。此后，新增颜色将不再需要修改形状的类层次，反之亦然。</p><h5 id="桥接模式结构"><a href="#桥接模式结构" class="headerlink" title="桥接模式结构"></a>桥接模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816164716.png" alt="img"></p><p>1.<strong>抽象部分(Abstrac­tion)</strong> 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p><p>2.<strong>实现部分(Imple­men­ta­tion)</strong> 为所有具体实现声明通用接口。抽象部分仅能通过在这里声明的方法与实现对象交互。抽象部分可以列出和实现部分一样的方法，但是抽象部分通常声明一些复杂行为，这些行为依赖于多种由实现部分声明的原语操作。</p><p>3.<strong>具体实现(Con­crete Imple­men­ta­tions)</strong> 中包括特定于平台的代码。</p><p>4.**精确抽象(Refined Abstrac­tion)**提供控制逻辑的变体。与其父类一样，它们通过通用实现接口与不同的实现进行交互。</p><p>5.通常情况下，**客户端(Client)**仅关心如何与抽象部分合作。但是，客户端需要将抽象对象与一个实现对象连接起来。</p><h5 id="伪代码-6"><a href="#伪代码-6" class="headerlink" title="伪代码"></a>伪代码</h5><p>在这次不那么伪的伪代码中我打算展现两段，其中一个是之前的Shape和Color之间的桥接。首先我们来看看遥控器遥控设备，是很容易理解设备就是实现部分，而遥控为抽象设备。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220816170510.png" alt="img"></p><p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互，使得同一个遥控器可以支持不同类型的设备。<br>你可以开发独立于设备类的遥控器类，只需新建一个遥控器子类即可。例如，基础遥控器可能只有两个按钮，但你可在其基础上扩展新功能，比如额外的一节电池或一块触摸屏。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span></span><br><span class="line"><span class="comment">// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Device device;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Remote</span>(<span class="params">Device device</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.device = device;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">togglePower</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(device.isEnabled())</span><br><span class="line">        &#123;</span><br><span class="line">            device.disable();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">volumeUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        device.setVolume(device.getVolume() + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">volumeDown</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        device.setChannel(device.getChannel() + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelDown</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdvancedRemote</span> : <span class="title">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        device.setVolume(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span></span><br><span class="line"><span class="comment">// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span></span><br><span class="line"><span class="comment">// 抽象接口则会基于这些操作定义较高层次的操作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Device</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">isEnable</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enable</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disable</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">getVolume</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVolume</span>(<span class="params">..</span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">getChannel</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChannel</span>(<span class="params">..</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TV</span> : <span class="title">Device</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> vlass Radio : Device</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line">tv = <span class="keyword">new</span> Tv();</span><br><span class="line">remote = <span class="keyword">new</span> RemoteControl(tv);</span><br><span class="line">remote.togglePower();</span><br><span class="line"></span><br><span class="line">radio = <span class="keyword">new</span> Radio();</span><br><span class="line">remote = <span class="keyword">new</span> AdvancedRemoteControl(radio);</span><br></pre></td></tr></table></figure><p>对于Shape和Color我们可能很难区别谁是“抽象”，谁是“实现”，但是桥接模式同样适合拆分类的结构,即抽取复杂类的其中一个维度使之成为独立的类层次。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Square</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Color</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Red</span> : <span class="title">Color</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blue</span> : <span class="title">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适合桥接模式的地方"><a href="#适合桥接模式的地方" class="headerlink" title="适合桥接模式的地方"></a>适合桥接模式的地方</h5><ul><li>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类），可以使用桥接模式。桥接模式可以将庞杂类拆分为几个类层次结构。此后，你可以修改任意一个类层次结构而不会影响到其他类层次结构。这种方法可以简化代码的维护工作，并将修改已有代码的风险降到最低。</li><li>如果你希望在几个独立维度上扩展一个类，可使用该模式。</li><li>如果你需要在运行时切换不同实现方法，可使用桥接模式。</li></ul><h5 id="桥接模式的优缺点"><a href="#桥接模式的优缺点" class="headerlink" title="桥接模式的优缺点"></a>桥接模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以创建与平台无关的类和程序。</li><li>客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。</li><li>符合OCP</li><li>符合SRP</li></ul><p><strong>缺点</strong> ：</p><ul><li>对高内聚的类使用该模式可能会让代码更加复杂。</li></ul><h4 id="Composite-组合模式"><a href="#Composite-组合模式" class="headerlink" title="Composite(组合模式)"></a>Composite(组合模式)</h4><p>组合模式是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。</p><h5 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h5><p><strong>如果应用的核心模型能用树状结构表示，在应用中使用组合模式才有价值。</strong>例如，你有两类对象： ​ 产品和盒子。一个盒子中可以包含多个产品或者几个较小的盒子。这些小盒子中同样可以包含一些产品或更小的盒子，以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818150134.png" alt="img"></p><p>订单中可能包括各种产品，这些产品放置在盒子中，然后又被放入一层又一层更大的盒子中。整个结构看上去像是一棵倒过来的树。你可以尝试直接计算：打开所有盒子，找到每件产品，然后计算总价。这在真实世界中或许可行，但在程序中，你并不能简单地使用循环语句来完成该工作。你必须事先知道所有产品和盒子的类别，所有盒子的嵌套层数以及其他繁杂的细节信息。因此，直接计算极不方便，甚至完全不可行。</p><h5 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h5><p>组合模式建议使用一个通用接口来与产品和盒子进行交互，并且在该接口中声明一个计算总价的方法。那么方法该如何设计呢？对于一个产品，该方法直接返回其价格；对于一个盒子，该方法遍历盒子中的所有项目，询问每个项目的价格，然后返回该盒子的总价格。如果其中某个项目是小一号的盒子，那么当前盒子也会遍历其中的所有项目，以此类推，直到计算出所有内部组成部分的价格。你甚至可以在盒子的最终价格中增加额外费用，作为该盒子的包装费用。<strong>类似于树的递归遍历</strong><br>该方式的最大优点在于你无需了解构成树状结构的对象的具体类。你也无需了解对象是简单的产品还是复杂的盒子。你只需调用通用接口以相同的方式对其进行处理即可。当你调用该方法后，对象会将请求沿着树结构传递下去。</p><h5 id="组合模式结构"><a href="#组合模式结构" class="headerlink" title="组合模式结构"></a>组合模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818150405.png" alt="img"></p><p>1.<strong>组件(Com­po­nent)</strong> 接口描述了树中简单项目和复杂项目所共有的操作。</p><p>2.<strong>叶节点(Leaf)</strong> 是树的基本结构，它不包含子项目。<br>一般情况下，叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p><p>3.<strong>容器(Con­tain­er)</strong> ——又名 <strong>“组合 (Com­pos­ite)”</strong>——是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，它只通过通用的组件接口与其子项目交互。<br>容器接收到请求后会将工作分配给自己的子项目，处理中间结果，然后将最终结果返回给客户端。</p><p>4.<strong>客户端(Client)</strong> 通过组件接口与所有项目交互。因此，客户端能以相同方式与树状结构中的简单或复杂项目交互。</p><h5 id="伪代码-7"><a href="#伪代码-7" class="headerlink" title="伪代码"></a>伪代码</h5><p>一个例子是利用组合模式在图形编辑器中实现一系列的几何图形。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818151017.png" alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Graphic</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span>(<span class="params">x,y</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dot类是叶节点，不能能包含任何子对象，通常完成所有工作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dot</span> : <span class="title">Graphic</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T x,y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dot</span>(<span class="params">T x,T y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span>(<span class="params">T x,T y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.x += x,<span class="keyword">this</span>.y +=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有的组件类都可以拓展</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Dot</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params">T x,T y,T radius</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CompoundGraphic类是复杂组件，也就是树中的非叶子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CompoundGraphic</span> : <span class="title">Graphic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Graphic[] chidren;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">Graphic child</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加至chidren数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params">Graphic child</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移除chidren数组里的一个child</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历每一个child，让child来做具体的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span>(<span class="params">x,y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> children)</span><br><span class="line">        &#123;</span><br><span class="line">            child.move(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分两步，一个是画完所有child的内容</span></span><br><span class="line">        <span class="comment">//第二步是根据自身内容画点东西</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简明的客户端代码</span></span><br><span class="line"></span><br><span class="line">CompoundGraphic tree = <span class="keyword">new</span> CompoundGraphic();</span><br><span class="line">CompoundGraphic branch1 = <span class="keyword">new</span> CompoundGraphic();</span><br><span class="line">branch1.Add(<span class="keyword">new</span> Dot(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">branch1.Add(<span class="keyword">new</span> Dot(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">CompoundGraphic branch2 = <span class="keyword">new</span> CompoundGraphic();</span><br><span class="line">branch2.Add(<span class="keyword">new</span> Circle(<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">branch2.Add(<span class="keyword">new</span> Dot(<span class="number">7</span>,<span class="number">8</span>));</span><br><span class="line">branch3.Add(<span class="keyword">new</span> Dot(<span class="number">9</span>,<span class="number">10</span>));</span><br><span class="line">tree.Add(branch1);</span><br><span class="line">tree.Add(branch2);</span><br><span class="line"></span><br><span class="line">tree.move(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">tree.draw();</span><br></pre></td></tr></table></figure><h5 id="适合组合模式的地方"><a href="#适合组合模式的地方" class="headerlink" title="适合组合模式的地方"></a>适合组合模式的地方</h5><ul><li>如果你需要实现<strong>树状对象结构</strong>，可以使用组合模式。</li><li>如果你希望客户端代码以<strong>相同方式处理简单和复杂元素</strong>，可以使用该模式。</li></ul><h5 id="组合模式的优缺点"><a href="#组合模式的优缺点" class="headerlink" title="组合模式的优缺点"></a>组合模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以利用<strong>多态</strong>和<strong>递归</strong>机制更方便地使用复杂树结构。</li><li>符合OCP</li></ul><p><strong>缺点</strong> ：</p><ul><li>对于功能差异较大的类，提供公共接口或许会有困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解。</li></ul><h4 id="Decorator-装饰模式"><a href="#Decorator-装饰模式" class="headerlink" title="Decorator(装饰模式)"></a>Decorator(装饰模式)</h4><p>装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><h5 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h5><p>假设你正在开发一个提供通知功能的库，其他程序可使用它向用户发送关于重要事件的通知。<br>库的最初版本基于<strong>通知器Noti­fi­er类</strong>，其中只有很少的几个成员变量，一个构造函数和一个send发送方法。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818203702.png" alt="img"></p><p>此后某个时刻，你会发现库的用户希望使用除邮件通知之外的功能。许多用户会希望接收关于紧急事件的手机短信，还有些用户希望在微信上接收消息，而公司用户则希望在 QQ 上接收消息。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818203808.png" alt="img"></p><p>首先扩展通知器类，然后在新的子类中加入额外的通知方法。现在客户端要对所需通知形式的对应类进行初始化，然后使用该类发送后续所有的通知消息。但是很快有人会问：​“为什么不同时使用多种通知形式呢？如果房子着火了，你大概会想在所有渠道中都收到相同的消息吧。”你可以尝试创建一个特殊子类来将多种通知方法组合在一起以解决该问题。但这种方式会使得代码量迅速膨胀，不仅仅是程序库代码，客户端代码也会如此。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818203913.png" alt="img"></p><h5 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h5><p>当你需要更改一个对象的行为时，第一个跳入脑海的想法就是扩展它所属的类。但是，你不能忽视继承可能引发的几个严重问题。</p><ul><li>继承是静态的。你无法在运行时更改已有对象的行为，只能使用由不同子类创建的对象来替代当前的整个对象。</li><li>子类只能有一个父类。大部分编程语言不允许一个类同时继承多个类的行为。</li></ul><p>其中一种方法是用<strong>聚合或组合(has a&#x2F;contains a)</strong> ，而不是继承。两者的工作方式几乎一模一样：一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象；继承中的对象则继承了父类的行为，它们自己能够完成这些工作。你可以使用这个新方法来轻松替换各种连接的 “小帮手” 对象，从而能在运行时改变容器的行为。一个对象可以使用多个类的行为， 包含多个指向其他对象的引用，并将各种工作委派给引用对象<strong>聚合（或组合） 组合是许多设计模式背后的关键原则 （包括装饰在内）。记住这一点后，让我们继续关于模式的讨论</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818204142.png" alt="img"></p><p>那么什么时候一个简单的封装器可以被称为是真正的装饰呢？正如之前提到的，封装器实现了与其封装对象相同的接口。因此从客户端的角度来看，这些对象是<strong>完全一样</strong>的。封装器中的引用成员变量可以是遵循相同接口的任意对象。这使得你可以将<strong>一个对象放入多个封装器</strong>中，并在对象中添加所有这些封装器的组合行为。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818205047.png" alt="img"></p><h5 id="装饰模式结构"><a href="#装饰模式结构" class="headerlink" title="装饰模式结构"></a>装饰模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818205848.png" alt="img"></p><p>1.<strong>部件(Com­po­nent)</strong> 声明封装器和被封装对象的公用接口。</p><p>2.<strong>具体部件(Con­crete Com­po­nent)</strong> 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</p><p>3.<strong>基础装饰(Base Dec­o­ra­tor)</strong> 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</p><p>4.<strong>具体装饰类(Con­crete Dec­o­ra­tors)</strong> 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</p><p>5.<strong>客户端(Client)</strong> 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</p><h5 id="伪代码-8"><a href="#伪代码-8" class="headerlink" title="伪代码"></a>伪代码</h5><p>仅仅看上面的内容只是知道个大概，来看看更具体的例子以及写写一些不那么伪的伪代码。</p><p><strong>第一个例子，c#类型的大概结构</strong> :</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义抽象Component类，准备被具体Component类和Base Decorator类继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">Operation</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体Component类定义了基础行为，装饰器就是修饰这些行为</span></span><br><span class="line"><span class="comment">//比如说你要画一个圆，这是本身要干的事情</span></span><br><span class="line"><span class="comment">//如果要画一个红色的圆，可以用修饰器来修饰这个行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteComponent</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Operation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcreteComponent&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装饰器要跟具体组件继承相同的类</span></span><br><span class="line"><span class="comment">//该类主要为了定义所有具体装饰类的接口。</span></span><br><span class="line"><span class="comment">//通常有一个关于Component的成员变量,并且要初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Decorator</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component _component;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span>(<span class="params">Component component</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Operation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._component != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._component.Operation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> : <span class="title">Decorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span>(<span class="params">Component component</span>) : <span class="title">base</span>(<span class="params">component</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//继承初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Operation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;ConcreteDecoratorA(<span class="subst">&#123;<span class="keyword">base</span>.Operation()&#125;</span>)&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> : <span class="title">Decorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span>(<span class="params">Component component</span>) : <span class="title">base</span>(<span class="params">component</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//继承初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Operation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;ConcreteDecoratorB(<span class="subst">&#123;<span class="keyword">base</span>.Operation()&#125;</span>)&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClientCode</span>(<span class="params">Component component</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;RESULT: &quot;</span> + component.Operation());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line">Client client = <span class="keyword">new</span> Client();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> simple = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line"> Console.WriteLine(<span class="string">&quot;Client: I get a simple component:&quot;</span>);</span><br><span class="line">client.ClientCode(simple);</span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line">ConcreteDecoratorA decorator1 = <span class="keyword">new</span> ConcreteDecoratorA(simple);</span><br><span class="line">ConcreteDecoratorB decorator2 = <span class="keyword">new</span> ConcreteDecoratorB(decorator1);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Client: Now I&#x27;ve got a decorated component:&quot;</span>);</span><br><span class="line">client.ClientCode(decorator2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*演示结果</span></span><br><span class="line"><span class="comment">Client: I get a simple component:</span></span><br><span class="line"><span class="comment">RESULT: ConcreteComponent</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Now I&#x27;ve got a decorated component:</span></span><br><span class="line"><span class="comment">RESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上一个例子基本上可以知道大概的运作方式，但是对于使用还不能够了解，接下来看一个比较简单的例子，可以很容易体现装饰器是在<strong>装饰具体组件的行为</strong>，感觉就跟c#一样，如果<strong>Component</strong>相当于c#的抽象类，那么<strong>Decorator</strong>就相当于c#的接口（但是实际上c#的接口不能继承类）</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818212043.png" alt="img"></p><p>图是java的示意图，但是我这里用c#写出来</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Component类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Concrete Component 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Shape:Rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Concrete Component 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Shape:Circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象Base Decorator类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ShapeDecorator</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span>(<span class="params">Shape shape</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.decoratedShape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Concrete Decorator类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedShapeDecorator</span> : <span class="title">ShapeDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span>(<span class="params">Shape shape</span>) : <span class="title">base</span> (<span class="params">shape</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//继承初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;Red + &quot;</span>);</span><br><span class="line">        <span class="keyword">base</span>.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> circle = <span class="keyword">new</span> Circle();</span><br><span class="line">ShapeDecorator redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">ShapeDecorator redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Circle with normal border&quot;</span>);</span><br><span class="line">circle.draw();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\nCircle of red border&quot;</span>);</span><br><span class="line">redCircle.draw();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\nRectangle of red border&quot;</span>);</span><br><span class="line">redRectangle.draw();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Circle with normal border</span></span><br><span class="line"><span class="comment">Shape:Circle</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Circle of red border</span></span><br><span class="line"><span class="comment">Red + Shape:Circle</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Rectangle of red border</span></span><br><span class="line"><span class="comment">Red + Shape:Rectangle</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合装饰模式的地方"><a href="#适合装饰模式的地方" class="headerlink" title="适合装饰模式的地方"></a>适合装饰模式的地方</h5><ul><li>如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式。</li><li>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式。</li></ul><h5 id="装饰模式的优缺点"><a href="#装饰模式的优缺点" class="headerlink" title="装饰模式的优缺点"></a>装饰模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你无需创建新子类即可扩展对象的行为。</li><li>你可以在运行时添加或删除对象的功能。</li><li>你可以用多个装饰封装对象来组合几种行为。</li><li>符合SRP</li></ul><p><strong>缺点</strong> ：</p><ul><li>在封装器栈中删除特定封装器比较困难。</li><li>实现行为不受装饰栈顺序影响的装饰比较困难。</li><li>各层的初始化配置代码看上去可能会很糟糕。</li></ul><h4 id="Fecade-外观模式-x2F-门面模式"><a href="#Fecade-外观模式-x2F-门面模式" class="headerlink" title="Fecade(外观模式&#x2F;门面模式)"></a>Fecade(外观模式&#x2F;门面模式)</h4><p>外观模式是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p><h5 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h5><p>假设你必须在代码中使用某个<strong>复杂的库或框架中的众多对象</strong>。正常情况下，你需要负责所有对象的初始化工作、管理其依赖关系并按正确的顺序执行方法等。最终，程序中类的业务逻辑将与第三方类的实现细节紧密耦合，使得理解和维护代码的工作很难进行。</p><h5 id="解决方案-9"><a href="#解决方案-9" class="headerlink" title="解决方案"></a>解决方案</h5><p>外观类为包含许多活动部件的<strong>复杂子系统提供一个简单的接口</strong>。与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。</p><h5 id="外观模式结构"><a href="#外观模式结构" class="headerlink" title="外观模式结构"></a>外观模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818223832.png" alt="img"></p><p>1.<strong>外观(Facade)</strong> 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p><p>2.**创建附加外观(Addi­tion­al Facade)**类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p><p>3.<strong>复杂子系统(Com­plex Sub­sys­tem)</strong> 由数十个不同对象构成。如果要用这些对象完成有意义的工作，你必须深入了解子系统的实现细节，比如按照正确顺序初始化对象和为其提供正确格式的数据。<br>子系统类不会意识到外观的存在，它们在系统内运作并且相互之间可直接进行交互。</p><p>4.<strong>客户端(Client)</strong> 使用外观代替对子系统对象的直接调用。</p><h5 id="伪代码-9"><a href="#伪代码-9" class="headerlink" title="伪代码"></a>伪代码</h5><p>在本例中，外观模式简化了客户端与复杂视频转换框架之间的交互。你可以创建一个封装所需功能并隐藏其他代码的外观类，从而无需使全部代码直接与数十个框架类进行交互。该结构还能将未来框架升级或更换所造成的影响最小化，因为你只需修改程序中外观方法的实现即可。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818224224.png" alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种子系统类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VideoFile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OggCompressionCodec</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MPEG4CompressionCodec</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CodecFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BitrateReader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioMixer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个外观类，目的是为了将很多的子系统类转换成一个接口来给客户端看</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VideoConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//假设返回类型就是File类</span></span><br><span class="line">    <span class="comment">//不要在意里面的具体内容，只用知道这是个转化器就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">converter</span>(<span class="params">filename,format</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> VideoFile(filename);</span><br><span class="line">        CodecFactory sourceCodec = <span class="keyword">new</span> CodecFactory.extract(file);</span><br><span class="line">        <span class="keyword">if</span> (format == <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">            MPEG4CompressionCodec destinationCodec = <span class="keyword">new</span> MPEG4CompressionCodec();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            OggCompressionCodec destinationCodec = <span class="keyword">new</span> OggCompressionCodec();</span><br><span class="line">        BitrateReader buffer = BitrateReader.read(filename, sourceCodec);</span><br><span class="line">        BitrateReader result = BitrateReader.convert(buffer, destinationCodec);</span><br><span class="line">        AudioMixer result = (<span class="keyword">new</span> AudioMixer()).fix(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> convertor = <span class="keyword">new</span> VideoConverter();</span><br><span class="line"><span class="keyword">var</span> mp4 = convertor.convert(<span class="string">&quot;funny-cats-video.ogg&quot;</span>, <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">mp4.save()</span><br></pre></td></tr></table></figure><h5 id="适合外观模式的地方"><a href="#适合外观模式的地方" class="headerlink" title="适合外观模式的地方"></a>适合外观模式的地方</h5><ul><li>如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式。</li><li>如果需要将子系统组织为多层结构，可以使用外观。</li></ul><h5 id="外观模式的优缺点"><a href="#外观模式的优缺点" class="headerlink" title="外观模式的优缺点"></a>外观模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以让自己的代码独立于复杂子系统。</li></ul><p><strong>缺点</strong> ：</p><ul><li>外观可能成为与程序中所有类都耦合的上帝对象（一个上帝对象(God object)是一个了解过多或者负责过多的对象）</li></ul><h4 id="Flyweight-享元模式"><a href="#Flyweight-享元模式" class="headerlink" title="Flyweight(享元模式)"></a>Flyweight(享元模式)</h4><p>享元模式是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。简单来说，就是提取一个大类中共同的不变的内容的为一个类和一个需要经常生成的变化状态的类。</p><h5 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h5><p>真正的问题与粒子系统有关。每个粒子 （一颗子弹、 一枚导弹或一块弹片） 都由包含完整数据的独立对象来表示。当玩家在游戏中鏖战进入高潮后的某一时刻，游戏将无法在剩余内存中载入新建粒子，于是程序就崩溃了。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818230038.png" alt="img"></p><h5 id="解决方案-10"><a href="#解决方案-10" class="headerlink" title="解决方案"></a>解决方案</h5><p>仔细观察<strong>粒子Par­ti­cle类</strong>， 你可能会注意到<strong>颜色(color)和精灵图(sprite)<strong>这两个成员变量所消耗的内存要比其他变量多得多。更糟糕的是，对于所有的粒子来说，</strong>这两个成员变量所存储的数据几乎完全一样</strong> （比如所有子弹的颜色和精灵图都一样）。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818230148.png" alt="img"></p><p>每个粒子的另一些状态 （坐标、 移动矢量和速度） 则是不同的。因为这些成员变量的数值会不断变化。 这些数据代表粒子在存续期间不断变化的情景，但每个粒子的颜色和精灵图则会保持不变。<br>对象的常量数据通常被称为<strong>内在状态</strong>，其位于对象中，其他对象只能读取但不能修改其数值。而对象的其他状态常常能被其他对象 “从外部” 改变，因此被称为<strong>外在状态</strong>。<br>我们将这样一个<strong>仅存储内在状态的对象称为享元</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818230930.png" alt="img"></p><p><strong>享元与不可变性</strong> :<br>由于享元对象可在不同的情景中使用，你必须确保其状态不能被修改。<strong>享元类的状态只能由构造函数的参数进行一次性初始化</strong>，它不能对其他对象公开其设置器或公有成员变量。</p><p><strong>享元工厂</strong> :<br>为了能更方便地访问各种享元，你可以创建一个工厂方法来管理已有享元对象的缓存池。工厂方法从客户端处接收目标享元对象的内在状态作为参数，如果它能在缓存池中找到所需享元，则将其返回给客户端；如果没有找到，它就会新建一个享元，并将其添加到缓存池中。<br>你可以选择在程序的不同地方放入该函数。最简单的选择就是将其放置在享元容器中。除此之外，你还可以新建一个工厂类，或者创建一个静态的工厂方法并将其放入实际的享元类中。</p><h5 id="享元模式结构"><a href="#享元模式结构" class="headerlink" title="享元模式结构"></a>享元模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220818231129.png" alt="img"></p><p>1.享元模式只是一种优化。在应用该模式之前，你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题，并且确保该问题无法使用其他更好的方式来解决。</p><p>2.<strong>享元(Fly­weight)</strong> 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</p><p>3.<strong>情景(Con­text)</strong> 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</p><p>4.通常情况下，原始对象的行为会保留在享元类中。因此调用享元方法必须提供部分外在状态作为参数。但你也可将行为移动到情景类中，然后将连入的享元作为单纯的数据对象。</p><p>5.<strong>客户端(Client)</strong> 负责计算或存储享元的外在状态。在客户端看来，享元是一种可在运行时进行配置的模板对象，具体的配置方式为向其方法中传入一些情景数据参数。</p><p>6.<strong>享元工厂(Fly­weight Fac­to­ry)</strong> 会对已有享元的缓存池进行管理。有了工厂后，客户端就无需直接创建享元，它们只需调用工厂并向其传递目标享元的一些内在状态即可。工厂会根据参数在之前已创建的享元中进行查找，如果找到满足条件的享元就将其返回；如果没有找到就根据参数新建享元。</p><h5 id="伪代码-10"><a href="#伪代码-10" class="headerlink" title="伪代码"></a>伪代码</h5><p>在本例中，享元模式能有效减少在画布上渲染数百万个树状对象时所需的内存。该模式从主要的<strong>树Tree</strong>类中抽取内在状态，并将其移动到<strong>享元类树种类Tree­Type</strong>之中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//享元类,拥有大量共同的名字，颜色和材质</span></span><br><span class="line"><span class="comment">//如果每个树都进行一次保存将会消耗大量的内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    <span class="keyword">private</span> Texture texture;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span>(<span class="params">name,color,texture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">draw</span>(<span class="params">canvas,x,y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 创建特定类型、颜色和纹理的位图。</span></span><br><span class="line">        <span class="comment">// 2. 在画布坐标 (X,Y) 处绘制位图。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用享元工厂，当然是不一定只有一种树啦</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeType[] treeTypes;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeType <span class="title">getTreeType</span>(<span class="params">name,color,texture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeType type = treeTypes.Find(name,color,texture);</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            type = <span class="keyword">new</span> TreeType(name,color,texture);</span><br><span class="line">            treeTypes.<span class="keyword">add</span>(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的外在状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tree</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> x,y;</span><br><span class="line">    <span class="keyword">public</span> TreeType type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Type</span>(<span class="params">x,y,type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params">canvas</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        type.draw(canvas,<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树（Tree）和森林（For­est）类是享元的客户端。</span></span><br><span class="line"><span class="comment">// 如果不打算继续对树类进行开发，你可以将它们合并。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Forest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Tree[] trees;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plantTree</span>(<span class="params">x,y,name,color,texture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeType type = TreeFactory.getTreeType(name,color,texture);</span><br><span class="line">        tree = <span class="keyword">new</span> Tree(x,y,type);</span><br><span class="line">        trees.<span class="keyword">add</span>(tree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params">canvas</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> tree <span class="keyword">in</span> trees)</span><br><span class="line">        &#123;</span><br><span class="line">            tree.draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适合享元模式的地方"><a href="#适合享元模式的地方" class="headerlink" title="适合享元模式的地方"></a>适合享元模式的地方</h5><ul><li>仅在程序必须支持<strong>大量对象且没有足够的内存容量</strong>时使用享元模式(比如粒子系统)。</li></ul><h5 id="享元模式的优缺点"><a href="#享元模式的优缺点" class="headerlink" title="享元模式的优缺点"></a>享元模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>如果程序中有很多相似对象，那么你将可以节省大量内存。</li></ul><p><strong>缺点</strong> ：</p><ul><li>你可能需要牺牲执行速度来换取内存，因为他人每次调用享元方法时都需要重新计算部分情景数据。</li><li>代码会变得更加复杂。 团队中的新成员总是会问： ​“为什么要像这样拆分一个实体的状态？”。</li></ul><h4 id="Proxy-代理模式"><a href="#Proxy-代理模式" class="headerlink" title="Proxy(代理模式)"></a>Proxy(代理模式)</h4><p>代理模式是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。</p><h5 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h5><p>为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象，你只是偶尔需要使用它，并非总是需要。你可以实现延迟初始化：在实际有需要时再创建该对象。对象的所有客户端都要执行延迟初始代码。不幸的是，这很可能会带来很多重复代码。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220819001221.png" alt="img"></p><p>在理想情况下，我们希望将代码直接放入对象的类中，但这并非总是能实现：比如类可能是第三方封闭库的一部分。</p><h5 id="解决方案-11"><a href="#解决方案-11" class="headerlink" title="解决方案"></a>解决方案</h5><p>代理模式建议新建一个与原服务对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端。代理类接收到客户端请求后会创建实际的服务对象，并将所有工作委派给它。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220819001254.png" alt="img"></p><h5 id="代理模式结构"><a href="#代理模式结构" class="headerlink" title="代理模式结构"></a>代理模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220819001317.png" alt="img"></p><p>1.<strong>服务接口(Ser­vice Inter­face)</strong> 声明了服务接口。代理必须遵循该接口才能伪装成服务对象。</p><p>2.<strong>服务(Ser­vice)</strong> 类提供了一些实用的业务逻辑。</p><p>3.<strong>代理(Proxy)</strong> 类包含一个指向服务对象的引用成员变量。代理完成其任务（例如延迟初始化、记录日志、访问控制和缓存等）后会将请求传递给服务对象。通常情况下，代理会对其服务对象的整个生命周期进行管理。</p><p>4.<strong>客户端(Client)</strong> 能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理。</p><h5 id="伪代码-11"><a href="#伪代码-11" class="headerlink" title="伪代码"></a>伪代码</h5><p>代理模式虽然在绝大多数c#程序中十分不常见，但是在一些特殊情况下使用还是很方便的。我们仅仅在这里对着结构图写一个仍然不是那么伪的伪代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该服务接口是代理类和真实服务类必须要声明的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ServiceInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实的服务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Service</span> : <span class="title">ServiceInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Proxy</span> : <span class="title">ServiceInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Service _service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span>(<span class="params">Service service</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.CheckAccess())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>._service.Operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckAccess</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一些真实的Check代码段，但是这里就省略了</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Client: Executing the client code with a real subject:&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> service = <span class="keyword">new</span> Service();</span><br><span class="line">service.Operation();</span><br><span class="line"></span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Client: Executing the same client code with a proxy:&quot;</span>);</span><br><span class="line"></span><br><span class="line">Proxy proxy = <span class="keyword">new</span> Proxy(service);</span><br><span class="line">proxy.Operation();</span><br></pre></td></tr></table></figure><h5 id="适合代理模式的地方"><a href="#适合代理模式的地方" class="headerlink" title="适合代理模式的地方"></a>适合代理模式的地方</h5><ul><li>延迟初始化（虚拟代理）。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。</li><li>访问控制（保护代理）。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序（包括恶意程序），此时可使用代理模式。</li><li>本地执行远程服务（远程代理）。适用于服务对象位于远程服务器上的情形。</li><li>记录日志请求（日志记录代理）。适用于当你需要保存对于服务对象的请求历史记录时。</li><li>缓存请求结果（缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时。</li><li>智能引用。可在没有客户端使用某个重量级对象时立即销毁该对象。</li></ul><h5 id="代码模式的优缺点"><a href="#代码模式的优缺点" class="headerlink" title="代码模式的优缺点"></a>代码模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以在客户端毫无察觉的情况下控制服务对象。</li><li>如果客户端对服务对象的生命周期没有特殊要求，你可以对生命周期进行管理。</li><li>即使服务对象还未准备好或不存在，代理也可以正常工作。</li><li>符合OCP</li></ul><p><strong>缺点</strong> :</p><ul><li>代码可能会变得复杂，因为需要新建许多类。</li><li>服务响应可能会延迟。</li></ul><h3 id="行为模式-Behavioral-Patterns"><a href="#行为模式-Behavioral-Patterns" class="headerlink" title="行为模式(Behavioral Patterns)"></a>行为模式(Behavioral Patterns)</h3><h4 id="Chain-of-Responsibility-责任链模式"><a href="#Chain-of-Responsibility-责任链模式" class="headerlink" title="Chain of Responsibility(责任链模式)"></a>Chain of Responsibility(责任链模式)</h4><p>责任链模式是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。</p><h5 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h5><p>假如你正在开发一个在线订购系统。你希望对系统访问进行限制，只允许认证用户创建订单。此外，拥有管理权限的用户也拥有所有订单的完全访问权限。简单规划后，你会意识到这些检查必须依次进行。只要接收到包含用户凭据的请求，应用程序就可尝试对进入系统的用户进行认证。但如果由于用户凭据不正确而导致认证失败，那就没有必要进行后续检查了。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824130805.png" alt="img"></p><p>在接下来的几个月里，你实现了后续的几个检查步骤。</p><ul><li>一位同事认为直接将原始数据传递给订购系统存在安全隐患。因此你新增了额外的验证步骤来清理请求中的数据。</li><li>过了一段时间，有人注意到系统无法抵御暴力密码破解方式的攻击。为了防范这种情况你立刻添加了一个检查步骤来过滤来自同一IP地址的重复错误请求。</li><li>又有人提议你可以对包含同样数据的重复请求返回缓存中的结果，从而提高系统响应速度。因此，你新增了一个检查步骤，确保只有没有满足条件的缓存结果时请求才能通过并被发送给系统。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824130901.png" alt="img"></p><h5 id="解决方案-12"><a href="#解决方案-12" class="headerlink" title="解决方案"></a>解决方案</h5><p>与许多其他行为设计模式一样，责任链会将特定行为转换为被称作<strong>处理者的独立对象</strong>。在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，并执行检查操作。请求及其数据则会被作为参数传递给该方法。<br>模式建议你<strong>将这些处理者连成一条链</strong>。链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。除了处理请求外，处理者还负责沿着链传递请求。请求会在链上移动，直至所有处理者都有机会对其进行处理。最重要的是：<strong>处理者可以决定不再沿着链传递请求，这可高效地取消所有后续处理步骤</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824131142.png" alt="img"></p><p>不过还有一种稍微不同的方式 （也是更经典一种）， 那就是<strong>处理者接收到请求后自行决定是否能够对其进行处理</strong>。如果自己能够处理，处理者就不再继续传递请求。因此在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理。在处理图形用户界面元素栈中的事件时，这种方式非常常见。<br>所有<strong>处理者类均实现同一接口</strong>是关键所在。每个具体处理者仅关心下一个包含exe­cute执行方法的处理者。这样一来，你就可以在运行时使用不同的处理者来创建链，而无需将相关代码与处理者的具体类进行耦合。</p><h5 id="责任链模式结构"><a href="#责任链模式结构" class="headerlink" title="责任链模式结构"></a>责任链模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824131355.png" alt="img"></p><p>1.<strong>处理者(Han­dler)</strong> 声明了所有具体处理者的通用接口。该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p><p>2.<strong>基础处理者(Base Han­dler)</strong> 是一个可选的类，你可以将所有处理者共用的样本代码放置在其中。<br>通常情况下，该类中定义了一个保存对于下个处理者引用的成员变量。客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。该类还可以实现默认的处理行为：确定下个处理者存在后再将请求传递给它。</p><p>3.<strong>具体处理者(Con­crete Han­dlers)</strong> 包含处理请求的实际代码。每个处理者接收到请求后，都必须决定是否进行处理，以及是否沿着链传递请求。<br>处理者通常是独立且不可变的，需要通过构造函数一次性地获得所有必要地数据。</p><p>4.<strong>客户端(Client)</strong> 可根据程序逻辑一次性或者动态地生成链。值得注意的是，请求可发送给链上的任意一个处理者，而非必须是第一个处理者。</p><h5 id="伪代码-12"><a href="#伪代码-12" class="headerlink" title="伪代码"></a>伪代码</h5><p>责任链在c#程序中并不常见，因为它仅在代码与对象链打交道时才能发挥作用。但是一旦用到这种链式请求，比如按顺序地验证答案，验证信息还是有用的。<br>在下段代码中，我们会给一批食物，让每个食物在责任链上走完，如果有动物要了，后续的链就会停止，如果会一直没有动物要，那就会返回 “{food} was left untouched”。那么，如果是信息验证的话，同理，我们让一个信息在链上走，如果中间有一步错了，马上停止，只有全部符合，才会报告信息验证成功。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler 接口声明了建立处理者链的的方法，也声明了执行请求的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">Handle</span>(<span class="params"><span class="built_in">object</span> request</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基础处理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractHandler</span> : <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IHandler _nextHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._nextHandler = handler;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span> <span class="title">Handle</span>(<span class="params"><span class="built_in">object</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._nextHandler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._nextHandler.Handle(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MonkeyHandler</span> : <span class="title">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Handle</span>(<span class="params"><span class="built_in">object</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((request <span class="keyword">as</span> <span class="built_in">string</span>) == <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Monkey: I&#x27;ll eat the <span class="subst">&#123;request.ToString()&#125;</span>.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.Handle(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">SquirrelHandler</span> : <span class="title">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Handle</span>(<span class="params"><span class="built_in">object</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.ToString() == <span class="string">&quot;Nut&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Squirrel: I&#x27;ll eat the <span class="subst">&#123;request.ToString()&#125;</span>.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.Handle(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DogHandler</span> : <span class="title">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Handle</span>(<span class="params"><span class="built_in">object</span> request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.ToString() == <span class="string">&quot;MeatBall&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Dog: I&#x27;ll eat the <span class="subst">&#123;request.ToString()&#125;</span>.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.Handle(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClientCode</span>(<span class="params">AbstractHandler handler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;Nut&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cup of coffee&quot;</span> &#125;)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Client: Who wants a <span class="subst">&#123;food&#125;</span>?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = handler.Handle(food);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">$&quot;   <span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;   <span class="subst">&#123;food&#125;</span> was left untouched.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> monkey = <span class="keyword">new</span> MonkeyHandler();</span><br><span class="line"><span class="keyword">var</span> squirrel = <span class="keyword">new</span> SquirrelHandler();</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> DogHandler();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置责任链</span></span><br><span class="line">monkey.setNext(squirrel).setNext(dog);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Chain: Monkey &gt; Squirrel &gt; Dog\n&quot;</span>);</span><br><span class="line">Client.ClientCode(monkey);</span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Subchain: Squirrel &gt; Dog\n&quot;</span>);</span><br><span class="line">Client.ClientCode(squirrel);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Chain: Monkey &gt; Squirrel &gt; Dog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Who wants a Nut?</span></span><br><span class="line"><span class="comment">   Squirrel: I&#x27;ll eat the Nut.</span></span><br><span class="line"><span class="comment">Client: Who wants a Banana?</span></span><br><span class="line"><span class="comment">   Monkey: I&#x27;ll eat the Banana.</span></span><br><span class="line"><span class="comment">Client: Who wants a Cup of coffee?</span></span><br><span class="line"><span class="comment">   Cup of coffee was left untouched.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Subchain: Squirrel &gt; Dog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Who wants a Nut?</span></span><br><span class="line"><span class="comment">   Squirrel: I&#x27;ll eat the Nut.</span></span><br><span class="line"><span class="comment">Client: Who wants a Banana?</span></span><br><span class="line"><span class="comment">   Banana was left untouched.</span></span><br><span class="line"><span class="comment">Client: Who wants a Cup of coffee?</span></span><br><span class="line"><span class="comment">   Cup of coffee was left untouched.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合责任链模式的地方"><a href="#适合责任链模式的地方" class="headerlink" title="适合责任链模式的地方"></a>适合责任链模式的地方</h5><ul><li>当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式。</li><li>当必须按顺序执行多个处理者时，可以使用该模式。</li><li>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</li></ul><h5 id="责任链模式的优缺点"><a href="#责任链模式的优缺点" class="headerlink" title="责任链模式的优缺点"></a>责任链模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以控制请求处理的顺序。</li><li>符合SRP</li><li>符合OCP</li></ul><p><strong>缺点</strong> ：</p><ul><li>部分请求可能未被处理。</li></ul><h4 id="Command-命令模式"><a href="#Command-命令模式" class="headerlink" title="Command(命令模式)"></a>Command(命令模式)</h4><p>命令模式是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。</p><h5 id="问题-13"><a href="#问题-13" class="headerlink" title="问题"></a>问题</h5><p>假如你正在开发一款新的文字编辑器，当前的任务是创建一个包含多个按钮的工具栏，并让每个按钮对应编辑器的不同操作。你创建了一个非常简洁的按钮类，它不仅可用于生成工具栏上的按钮，还可用于生成各种对话框的通用按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824135308.png" alt="img"></p><p>尽管所有按钮看上去都很相似，但它们可以完成不同的操作（打开、保存、打印和应用等）。你会在哪里放置这些按钮的点击处理代码呢？最简单的解决方案是在使用按钮的每个地方都创建大量的子类。这些子类中包含按钮点击后必须执行的代码。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824135352.png" alt="img"></p><p>你很快就意识到这种方式有严重缺陷。首先，你创建了大量的子类，当<strong>每次修改基类按钮时,你都有可能需要修改所有子类的代码</strong>。简单来说，GUI代码以一种拙劣的方式依赖于业务逻辑中的不稳定代码。</p><p>还有一个部分最难办。复制&#x2F;粘贴文字等操作可能会在多个地方被调用。例如用户可以点击工具栏上小小的 “复制” 按钮，或者通过上下文菜单复制一些内容，又或者直接使用键盘上的 Ctrl+C 。</p><h5 id="解决方案-13"><a href="#解决方案-13" class="headerlink" title="解决方案"></a>解决方案</h5><p>优秀的软件设计通常会将关注点进行分离，而这往往会导致软件的分层。最常见的例子：一层负责用户图像界面；另一层负责业务逻辑。GUI 层负责在屏幕上渲染美观的图形，捕获所有输入并显示用户和程序工作的结果。当需要完成一些重要内容时（比如计算月球轨道或撰写年度报告），GUI 层则会将工作委派给业务逻辑底层。<br>这在代码中看上去就像这样：一个 GUI 对象传递一些参数来调用一个业务逻辑对象。这个过程通常被描述为一个对象发送请求给另一个对象。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824135547.png" alt="img"></p><p>命令模式<strong>建议 GUI 对象不直接提交这些请求</strong>。你应该将<strong>请求的所有细节</strong> （例如调用的对象、 方法名称和参数列表） <strong>抽取出来组成命令类</strong>，该类中仅包含一个用于触发请求的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824135629.png" alt="img"></p><p>下一步是让<strong>所有命令实现相同的接口</strong>。该接口通常只有一个没有任何参数的执行方法，让你能在不和具体命令类耦合的情况下使用同一请求发送者执行不同命令。此外还有额外的好处，现在你能在运行时切换连接至发送者的命令对象，以此改变发送者的行为。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824135705.png" alt="img"></p><h5 id="命令模式结构"><a href="#命令模式结构" class="headerlink" title="命令模式结构"></a>命令模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824135728.png" alt="img"></p><p>1.<strong>发送者(Sender)——亦称 “触发者(Invok­er)”</strong> 类负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。发送者触发命令，而不向接收者直接发送请求。注意，发送者并不负责创建命令对象：它通常会通过构造函数从客户端处获得预先生成的命令。</p><p>2.<strong>命令(Com­mand)</strong> 接口通常仅声明一个执行命令的方法。</p><p>3.<strong>具体命令(Con­crete Com­mands)</strong> 会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象。但为了简化代码，这些类可以进行合并。<br>接收对象执行方法所需的参数可以声明为具体命令的成员变量。你可以将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化。</p><p>4.<strong>接收者(Receiv­er)</strong> 类包含部分业务逻辑。几乎任何对象都可以作为接收者。绝大部分命令只处理如何将请求传递到接收者的细节，接收者自己会完成实际的工作。</p><p>5.<strong>客户端(Client)</strong> 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个发送者相关联了。</p><h5 id="伪代码-13"><a href="#伪代码-13" class="headerlink" title="伪代码"></a>伪代码</h5><p>命令模式十分常见。大部分情况下，它被用于代替包含行为的参数化 UI 元素的回调函数，此外还被用于对任务进行排序和记录操作历史记录等。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824141646.png" alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Application app;</span><br><span class="line">    <span class="keyword">protected</span> Editor editor;</span><br><span class="line">    <span class="keyword">protected</span> text backup;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span>(<span class="params">Application app,editor Editor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.app = app;</span><br><span class="line">        <span class="keyword">this</span>.editor = editor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份编辑器状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBackup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        backup = editor.text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复编辑器状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        editor.text = backup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行方法被声明为抽象以强制所有具体命令提供自己的实现。该方法必须根</span></span><br><span class="line">    <span class="comment">// 据命令是否更改编辑器的状态返回 true 或 false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CopyCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 复制命令不会被保存到历史记录中，因为它没有改变编辑器的状态。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        app.clipboard = editor.getSelection();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CutCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 剪切命令改变了编辑器的状态，因此它必须被保存到历史记录中。只要方法</span></span><br><span class="line">    <span class="comment">// 返回 true，它就会被保存。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        saveBackup();</span><br><span class="line">        app.clipboard = editor.getSelection();</span><br><span class="line">        editor.deleteSelection();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CutCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//粘贴命令改变了编辑器的状态</span></span><br><span class="line">    <span class="comment">// 返回 true，它就会被保存。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        saveBackup();</span><br><span class="line">        editor.replaceSelection(app.clipboard);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UndoCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        app.undo();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局命令历史记录就是一个堆栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommandHistory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Command[] history;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="params">Command c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将命令压入历史记录数组的末尾。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Command <span class="title">pop</span>(<span class="params">Command c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从历史记录中取出最近的命令。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编辑器类包含实际的文本编辑操作。它会担任接收者的角色：最后所有命令都会</span></span><br><span class="line"><span class="comment">// 将执行工作委派给编辑器的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getSlection</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回选中的文字。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteSelction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 删除选中的文字。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceSelection</span>(<span class="params"><span class="built_in">string</span> text</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在当前位置插入剪贴板中的内容。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用程序类会设置对象之间的关系。它会担任发送者的角色：当需要完成某些工</span></span><br><span class="line"><span class="comment">// 作时，它会创建并执行一个命令对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> clipboard;</span><br><span class="line">    <span class="keyword">public</span> Editors[] editors;</span><br><span class="line">    <span class="keyword">public</span> Editor activeEditor;</span><br><span class="line">    <span class="keyword">public</span> CommandHistory histroy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分发UI的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUI</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//复制操作</span></span><br><span class="line">        copy = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> CopyCommand(<span class="keyword">this</span>, activeEditor)) &#125;;</span><br><span class="line">        copyButton.setCommand(copy);</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+C&quot;</span>, copy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剪切操作</span></span><br><span class="line">        cut = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> CutCommand(<span class="keyword">this</span>, activeEditor)) &#125;;</span><br><span class="line">        cutButton.setCommand(cut);</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+X&quot;</span>, cut);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//粘贴操作</span></span><br><span class="line">        paste = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> PasteCommand(<span class="keyword">this</span>, activeEditor)) &#125;;</span><br><span class="line">        pasteButton.setCommand(paste);</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+V&quot;</span>, paste);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撤销操作</span></span><br><span class="line">        undo = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> UndoCommand(<span class="keyword">this</span>, activeEditor)) &#125;;</span><br><span class="line">        undoButton.setCommand(undo);</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">&quot;Ctrl+Z&quot;</span>, undo);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一个命令并检查它是否需要被添加到历史记录中。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCommand</span>(<span class="params">Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(command.execute)</span><br><span class="line">        &#123;</span><br><span class="line">            history.push(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从历史记录中取出最近的命令并运行其 undo（撤销）方法。请注意，你并</span></span><br><span class="line">    <span class="comment">// 不知晓该命令所属的类。但是我们不需要知晓，因为命令自己知道如何撤销</span></span><br><span class="line">    <span class="comment">// 其动作。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Command command = history.pop();</span><br><span class="line">        <span class="keyword">if</span>(command != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            command.undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适合命令模式的地方"><a href="#适合命令模式的地方" class="headerlink" title="适合命令模式的地方"></a>适合命令模式的地方</h5><ul><li>如果你需要通过操作来参数化对象，可使用命令模式。</li><li>如果你想要将操作放入队列中、操作的执行或者远程执行操作，可使用命令模式。</li><li>如果你想要实现操作回滚功能，可使用命令模式。为了能够回滚操作，你需要实现已执行操作的历史记录功能。命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。这种方法有两个缺点。首先，程序状态的保存功能并不容易实现，因为部分状态可能是私有的。你可以使用<strong>备忘录模式</strong>来在一定程度上解决这个问题。其次，备份状态可能会占用大量内存。因此，有时你需要借助另一种实现方式：命令无需恢复原始状态，而是执行反向操作。反向操作也有代价：它可能会很难甚至是无法实现。</li></ul><h5 id="命令模式的优缺点"><a href="#命令模式的优缺点" class="headerlink" title="命令模式的优缺点"></a>命令模式的优缺点</h5><p><strong>优点</strong> :</p><ul><li>符合SRP</li><li>符合OCP</li><li>你可以实现撤销和恢复功能。</li><li>你可以实现操作的延迟执行。</li><li>你可以将一组简单命令组合成一个复杂命令。</li></ul><p><strong>缺点</strong> :</p><ul><li>代码可能会变得更加复杂，因为你在发送者和接收者之间增加了一个全新的层次。</li></ul><h4 id="Iterator-迭代器模式"><a href="#Iterator-迭代器模式" class="headerlink" title="Iterator(迭代器模式)"></a>Iterator(迭代器模式)</h4><p>迭代器模式是一种行为设计模式，让你能在不暴露集合底层表现形式（列表、 栈和树等）的情况下遍历集合中所有的元素。</p><h5 id="问题-14"><a href="#问题-14" class="headerlink" title="问题"></a>问题</h5><p>如果你的集合基于列表，那么这项工作听上去仿佛很简单。但如何遍历复杂数据结构（例如树）中的元素呢？例如，今天你需要使用深度优先算法来遍历树结构，明天可能会需要广度优先算法；下周则可能会需要其他方式 （比如随机存取树中的元素）。不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。此外， 有些算法可能是根据特定应用订制的，将其加入泛型集合类中会显得非常奇怪。<br>另一方面，使用多种集合的客户端代码可能并不关心存储数据的方式。不过由于集合提供不同的元素访问方式，你的代码将不得不与特定集合类进行耦合。</p><h5 id="解决方案-14"><a href="#解决方案-14" class="headerlink" title="解决方案"></a>解决方案</h5><p>迭代器模式的主要思想是将<strong>集合的遍历行为抽取为单独的迭代器对象</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824153321.png" alt="img"></p><p>除实现自身算法外，迭代器还封装了遍历操作的所有细节，例如当前位置和末尾剩余元素的数量。因此，多个迭代器可以在相互独立的情况下同时访问集合。<br>迭代器通常会提供一个获取集合元素的基本方法。客户端可不断调用该方法直至它不返回任何内容，这意味着迭代器已经遍历了所有元素。<br>所有迭代器必须实现相同的接口。这样一来，只要有合适的迭代器，客户端代码就能兼容任何类型的集合或遍历算法。如果你需要采用特殊方式来遍历集合，只需创建一个新的迭代器类即可，无需对集合或客户端进行修改。</p><h5 id="迭代器模式结构"><a href="#迭代器模式结构" class="headerlink" title="迭代器模式结构"></a>迭代器模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824153429.png" alt="img"></p><p>1.<strong>迭代器(Iter­a­tor)</strong> 接口声明了遍历集合所需的操作：获取下一个元素、获取当前位置和重新开始迭代等。</p><p>2.<strong>具体迭代器(Con­crete Iter­a­tors)</strong> 实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一集合。</p><p>3.<strong>集合(Col­lec­tion)</strong> 接口声明一个或多个方法来获取与集合兼容的迭代器。请注意，返回方法的类型必须被声明为迭代器接口，因此具体集合可以返回各种不同种类的迭代器。</p><p>4.<strong>具体集合(Con­crete Col­lec­tions)</strong> 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。你可能会琢磨，剩下的集合代码在什么地方呢？不用担心，它也会在同一个类中。只是这些细节对于实际模式来说并不重要，所以我们将其省略了而已。</p><p>5.<strong>客户端(Client)</strong> 通过集合和迭代器的接口与两者进行交互。这样一来客户端无需与具体类进行耦合，允许同一客户端代码使用各种不同的集合和迭代器。<br>客户端通常不会自行创建迭代器，而是会从集合中获取。但在特定情况下，客户端可以直接创建一个迭代器（例如当客户端需要自定义特殊迭代器时）。</p><h5 id="伪代码-14"><a href="#伪代码-14" class="headerlink" title="伪代码"></a>伪代码</h5><p>迭代器模式在c#中十分常见，基于IEnumerator和IEnumerable的使用，然后在foreach中就能很方便地实现。前者是计数器，后者是可计数的，也就相当于迭代器模式里的迭代器和集合</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器基类，实现IEnumerator接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Iterator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> IEnumerator.Current =&gt; Current();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前元素的键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">int</span> <span class="title">Key</span>()</span>;    </span><br><span class="line">    <span class="comment">// 返回当前元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">object</span> <span class="title">Current</span>()</span>;    </span><br><span class="line">    <span class="comment">// 移动到下一位元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;    </span><br><span class="line">    <span class="comment">// 重置当前指的位置到初始位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//集合基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">IteratorAggregate</span> : <span class="title">Ienumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//返回集合对应的迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IEnumerator <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体迭代器的遍历算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">AlphabeticalOrderIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> WordsCollection _collection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _reverse = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlphabeticalOrderIterator</span>(<span class="params">WordsCollection collection, <span class="built_in">bool</span> reverse = <span class="literal">false</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._collection = collection;</span><br><span class="line">        <span class="keyword">this</span>._reverse = reverse;</span><br><span class="line">        <span class="keyword">if</span> (reverse)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>._position = collection.getItems().Count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">Key</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Current</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._collection.getItems()[_position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> updatedPosition = <span class="keyword">this</span>._position + (<span class="keyword">this</span>._reverse ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(updatedPosition &gt;= <span class="number">0</span> &amp;&amp; updatedPosition &lt; <span class="keyword">this</span>._collection.getItems())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>._position = updatePosition;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._position = <span class="keyword">this</span>._reverse ? <span class="keyword">this</span>._collection.getItems().Count - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体集合类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">WordsCollection</span> : <span class="title">IteratorAggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; _collection = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//决定是否反转</span></span><br><span class="line">    <span class="built_in">bool</span> _direction = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReverseDirection</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _direction = !_direction;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">getItems</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _collection;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._collection.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AlphabeticalOrderIterator(<span class="keyword">this</span>, _direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> WordsCollection();</span><br><span class="line">collection.AddItem(<span class="string">&quot;First&quot;</span>);        collection.AddItem(<span class="string">&quot;Second&quot;</span>);        collection.AddItem(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Straight traversal:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> element <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\nReverse traversal:&quot;</span>);</span><br><span class="line"></span><br><span class="line">collection.ReverseDirection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> element <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Straight traversal:</span></span><br><span class="line"><span class="comment">First</span></span><br><span class="line"><span class="comment">Second</span></span><br><span class="line"><span class="comment">Third</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Reverse traversal:</span></span><br><span class="line"><span class="comment">Third</span></span><br><span class="line"><span class="comment">Second</span></span><br><span class="line"><span class="comment">First</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合迭代器模式的地方"><a href="#适合迭代器模式的地方" class="headerlink" title="适合迭代器模式的地方"></a>适合迭代器模式的地方</h5><ul><li>当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器模式。</li><li>使用该模式可以减少程序中重复的遍历代码。</li><li>如果你希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器模式。</li></ul><h5 id="迭代器模式的优缺点"><a href="#迭代器模式的优缺点" class="headerlink" title="迭代器模式的优缺点"></a>迭代器模式的优缺点</h5><p><strong>优点</strong> :</p><ul><li>符合SRP</li><li>符合OCP</li><li>你可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态。</li><li>相似的，你可以暂停遍历并在需要时继续。</li></ul><p><strong>缺点</strong> :</p><ul><li>如果你的程序只与简单的集合进行交互，应用该模式可能会矫枉过正。</li><li>对于某些特殊集合，使用迭代器可能比直接遍历的效率低。</li></ul><h4 id="Mediator-中介者模式"><a href="#Mediator-中介者模式" class="headerlink" title="Mediator(中介者模式)"></a>Mediator(中介者模式)</h4><p>中介者模式是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。</p><h5 id="问题-15"><a href="#问题-15" class="headerlink" title="问题"></a>问题</h5><p>假如你有一个创建和修改客户资料的对话框，它由各种控件组成，例如文本框（Text­Field）、复选框 （Check­box）和按钮（But­ton）等。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824213630.png" alt="img"></p><p>如果直接在表单元素代码中实现业务逻辑，你将很难在程序其他表单中复用这些元素类。例如，由于复选框类与狗狗的文本框相耦合，所以将无法在其他表单中使用它。你要么使用渲染资料表单时用到的所有类，要么一个都不用。</p><h5 id="解决方案-15"><a href="#解决方案-15" class="headerlink" title="解决方案"></a>解决方案</h5><p>中介者模式建议你<strong>停止组件之间的直接交流并使其相互独立</strong>。这些组件必须调用特殊的中介者对象，通过中介者对象重定向调用行为，以间接的方式进行合作。最终，<strong>组件仅依赖于一个中介者类，无需与多个其他组件相耦合</strong>。<br>你还可以为所有类型的对话框抽取通用接口，进一步削弱其依赖性。接口中将声明一个所有表单元素都能使用的通知方法，可用于将元素中发生的事件通知给对话框。这样一来，所有实现了该接口的对话框都能使用这个提交按钮了。<br>采用这种方式，中介者模式让你能在单个中介者对象中封装多个对象间的复杂关系网。类所拥有的依赖关系越少，就越易于修改、扩展或复用。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824213818.png" alt="img"></p><p>飞行器驾驶员们在靠近或离开空中管制区域时不会直接相互交流。但他们会与飞机跑道附近，塔台中的空管员通话。如果没有空管员，驾驶员就需要留意机场附近的所有飞机，并与数十位飞行员组成的委员会讨论降落顺序。那恐怕会让飞机坠毁的统计数据一飞冲天吧。</p><p>塔台无需管制飞行全程，只需在航站区加强管控即可，因为该区域的决策参与者数量对于飞行员来说实在太多了。</p><h5 id="中介者模式结构"><a href="#中介者模式结构" class="headerlink" title="中介者模式结构"></a>中介者模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220824213846.png" alt="img"></p><p>1.<strong>组件(Com­po­nent)</strong> 是各种包含业务逻辑的类。每个组件都有一个指向中介者的引用，该引用被声明为中介者接口类型。组件不知道中介者实际所属的类，因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</p><p>2.<strong>中介者(Medi­a­tor)</strong> 接口声明了与组件交流的方法，但通常仅包括一个通知方法。组件可将任意上下文（包括自己的对象）作为该方法的参数，只有这样接收组件和发送者类之间才不会耦合。</p><p>3.<strong>具体中介者(Con­crete Medi­a­tor)</strong> 封装了多种组件间的关系。具体中介者通常会保存所有组件的引用并对其进行管理，甚至有时会对其生命周期进行管理。</p><p>4.组件并不知道其他组件的情况。如果组件内发生了重要事件，它只能通知中介者。中介者收到通知后能轻易地确定发送者，这或许已足以判断接下来需要触发的组件了。<br>对于组件来说，中介者看上去完全就是一个黑箱。发送者不知道最终会由谁来处理自己的请求，接收者也不知道最初是谁发出了请求。</p><h5 id="伪代码-15"><a href="#伪代码-15" class="headerlink" title="伪代码"></a>伪代码</h5><p>中介者模式在 C# 代码中最常用于帮助程序 GUI 组件之间的通信。在 MVC 模式中，控制器是中介者的同义词。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中介者接口声明各种元素通过活动相互通知的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="built_in">object</span> sender,<span class="built_in">string</span> ev</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> : <span class="title">IMediator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Component1 _component1;</span><br><span class="line">    <span class="keyword">private</span> Component2 _component2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span>(<span class="params">Component1 component1, Component2 component2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._component1 = component1;</span><br><span class="line">        <span class="keyword">this</span>._component1.SetMediator(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>._component2 = component2;</span><br><span class="line">        <span class="keyword">this</span>._component2.SetMediator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="built_in">object</span> sender,<span class="built_in">string</span> ev</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev == <span class="string">&quot;A&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Mediator reacts on A and triggers folowing operations:&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>._component2.DoC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ev == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Mediator reacts on D and triggers following operations:&quot;</span>);                </span><br><span class="line">            <span class="keyword">this</span>._component1.DoB();</span><br><span class="line">            <span class="keyword">this</span>._component2.DoC();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本组件类提供存储对应的引用的中介者的功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">BaseComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> IMediator _mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseComponent</span>(<span class="params">IMediator mediator =<span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMediator</span>(<span class="params">IMediator mediator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体组件实现具体功能，不同的具体组件虽然</span></span><br><span class="line"><span class="comment">//会相互用到，但并不会直接用到，只会通过</span></span><br><span class="line"><span class="comment">//中介者来引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Component1</span> : <span class="title">BaseComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoA</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Component 1 does A.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._mediator.Notify(<span class="keyword">this</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoB</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Component 1 does B.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._mediator.Notify(<span class="keyword">this</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Component2</span> : <span class="title">BaseComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoC</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Component 2 does C.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._mediator.Notify(<span class="keyword">this</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoD</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Component 2 does D.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._mediator.Notify(<span class="keyword">this</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line">Component1 component1 = <span class="keyword">new</span> Component1();</span><br><span class="line">Component2 component2 = <span class="keyword">new</span> Component2();</span><br><span class="line"><span class="keyword">new</span> ConcreteMediator(component1, component2);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Client triggets operation A.&quot;</span>);</span><br><span class="line">component1.DoA();</span><br><span class="line"></span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Client triggers operation D.&quot;</span>);</span><br><span class="line">component2.DoD();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Client triggers operation A.</span></span><br><span class="line"><span class="comment">Component 1 does A.</span></span><br><span class="line"><span class="comment">Mediator reacts on A and triggers following operations:</span></span><br><span class="line"><span class="comment">Component 2 does C.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client triggers operation D.</span></span><br><span class="line"><span class="comment">Component 2 does D.</span></span><br><span class="line"><span class="comment">Mediator reacts on D and triggers following operations:</span></span><br><span class="line"><span class="comment">Component 1 does B.</span></span><br><span class="line"><span class="comment">Component 2 does C.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合中介者模式的地方"><a href="#适合中介者模式的地方" class="headerlink" title="适合中介者模式的地方"></a>适合中介者模式的地方</h5><ul><li>当一些对象和其他对象紧密耦合以致难以对其进行修改时，可使用中介者模式。</li><li>当组件因过于依赖其他组件而无法在不同应用中复用时，可使用中介者模式。</li><li>如果为了能在不同情景下复用一些基本行为，导致你需要被迫创建大量组件子类时，可使用中介者模式。</li></ul><h5 id="中介者模式的优缺点"><a href="#中介者模式的优缺点" class="headerlink" title="中介者模式的优缺点"></a>中介者模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>符合SRP</li><li>符合OCP</li><li>你可以减轻应用中多个组件间的耦合情况。</li><li>你可以更方便地复用各个组件。</li></ul><p><strong>缺点</strong> ：</p><ul><li>一段时间后，中介者可能会演化成为上帝对象。</li></ul><h4 id="Memento-备忘录模式"><a href="#Memento-备忘录模式" class="headerlink" title="Memento(备忘录模式)"></a>Memento(备忘录模式)</h4><p>备忘录模式是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><h5 id="问题-16"><a href="#问题-16" class="headerlink" title="问题"></a>问题</h5><p>假如你正在开发一款文字编辑器应用程序。除了简单的文字编辑功能外，编辑器中还要有设置文本格式和插入内嵌图片等功能。<br>后来，你决定让用户能撤销施加在文本上的任何操作。这项功能在过去几年里变得十分普遍，因此用户期待任何程序都有这项功能。你选择采用直接的方式来实现该功能：程序在执行任何操作前会记录所有的对象状态，并将其保存下来。当用户此后需要撤销某个操作时，程序将从历史记录中获取最近的快照，然后使用它来恢复所有对象的状态。<br>让我们来思考一下这些状态快照。首先，到底该如何生成一个快照呢？很可能你会需要遍历对象的所有成员变量并将其数值复制保存。但只有当对象对其内容没有严格访问权限限制的情况下，你才能使用该方式。不过很遗憾，绝大部分对象会使用私有成员变量来存储重要数据，这样别人就无法轻易查看其中的内容。<br>现在我们暂时忽略这个问题，假设对象都像嬉皮士一样：喜欢开放式的关系并会公开其所有状态。尽管这种方式能够解决当前问题，让你可随时生成对象的状态快照，但这种方式仍存在一些严重问题。未来你可能会添加或删除一些成员变量。这听上去很简单，但需要对负责复制受影响对象状态的类进行更改。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220825143929.png" alt="img"></p><p>还有更多问题。让我们来考虑编辑器 （Edi­tor）状态的实际 “快照”，它需要包含哪些数据？至少必须包含实际的文本、光标坐标和当前滚动条位置等。你需要收集这些数据并将其放入特定容器中，才能生成快照。<br>你很可能会将大量的容器对象存储在历史记录列表中。这样一来，容器最终大概率会成为同一个类的对象。这个类中几乎没有任何方法，但有许多与编辑器状态一一对应的成员变量。为了让其他对象能保存或读取快照，你很可能需要将快照的成员变量设为公有。无论这些状态是否私有，其都将暴露一切编辑器状态。其他类会对快照类的每个小改动产生依赖，除非这些改动仅存在于私有成员变量或方法中，而不会影响外部类。<br>我们似乎走进了一条死胡同：<strong>要么会暴露类的所有内部细节而使其过于脆弱；要么会限制对其状态的访问权限而无法生成快照</strong>。那么，我们还有其他方式来实现 “撤销” 功能吗？</p><h5 id="解决方案-16"><a href="#解决方案-16" class="headerlink" title="解决方案"></a>解决方案</h5><p>我们刚才遇到的所有问题都是封装 “破损” 造成的。 一些对象试图超出其职责范围的工作。由于在执行某些行为时需要获取数据，所以它们侵入了其他对象的私有空间，而不是让这些对象来完成实际的工作。</p><p>备忘录模式将创建状态快照（Snap­shot）的工作委派给实际状态的拥有者原发器 （Orig­i­na­tor） 对象。这样其他对象就不再需要从 “外部” 复制编辑器状态了，编辑器类拥有其状态的完全访问权，因此可以自行生成快照。</p><p>模式建议将对象状态的副本存储在一个名为备忘录 （Memen­to）的特殊对象中。除了创建备忘录的对象外，任何对象都不能访问备忘录的内容。其他对象必须使用受限接口与备忘录进行交互，它们可以获取快照的元数据 （创建时间和操作名称等），但不能获取快照中原始对象的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220825144342.png" alt="img"></p><p>这种限制策略允许你将备忘录保存在通常被称为负责人（Care­tak­ers）的对象中。由于负责人仅通过受限接口与备忘录互动，故其无法修改存储在备忘录内部的状态。同时，原发器拥有对备忘录所有成员的访问权限，从而能随时恢复其以前的状态。</p><p>在文字编辑器的示例中，我们可以创建一个独立的历史 （His­to­ry） 类作为负责人。编辑器每次执行操作前，存储在负责人中的备忘录栈都会生长。你甚至可以在应用的 UI 中渲染该栈，为用户显示之前的操作历史。</p><p>当用户触发撤销操作时，历史类将从栈中取回最近的备忘录，并将其传递给编辑器以请求进行回滚。由于编辑器拥有对备忘录的完全访问权限，因此它可以使用从备忘录中获取的数值来替换自身的状态。</p><h5 id="备忘录模式结构"><a href="#备忘录模式结构" class="headerlink" title="备忘录模式结构"></a>备忘录模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220825144517.png" alt="img"></p><p>1.<strong>原发器(Orig­i­na­tor)</strong> 类可以生成自身状态的快照，也可以在需要时通过快照恢复自身状态。</p><p>2.<strong>备忘录(Memen­to)</strong> 是原发器状态快照的值对象(value object)。通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。</p><p>3.<strong>负责人(Care­tak­er)</strong> 仅知道 “何时” 和 “为何” 捕捉原发器的状态，以及何时恢复状态。<br>负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时，负责人将从栈中获取最顶部的备忘录，并将其传递给原发器的恢复 (restora­tion)方法。</p><p>4.在该实现方法中，备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法，即使这些方法被声明为私有。另一方面，负责人对于备忘录的成员变量和方法的访问权限非常有限：它们只能在栈中保存备忘录，而不能修改其状态。</p><h5 id="伪代码-16"><a href="#伪代码-16" class="headerlink" title="伪代码"></a>伪代码</h5><p>备忘录的基本功能可用序列化来实现，这在 C# 语言中很常见。尽管备忘录不是生成对象状态快照的唯一或最有效的方法，但它能在保护原始对象的结构不暴露给其他对象的情况下保存对象状态的备份。在游戏中，比如地平线的回退，PBUG的死亡回放等等都可能是用到了备忘录模式。<br>这个模式还是有点复杂的，仅仅通过结构不太能区分Originator和Caretaker，通过代码来简单了解一下。</p><p>简单谈一下之后的伪代码，这次的结构比较复杂，所以建议最好运行一遍然后看懂代码，简单来说就是Caretaker负责做，通过Caretaker类来使Originator创建一次Memento然后存储到Caretaker里的list。如果是撤回之前的状态，同样用Caretaker的Undo来触发Originator的Restore函数。也就是说，Caretaker是发起者，Originator是Memento的创造者，Memento只是用来存储一次的状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Originator类会存储一些重要的可能会随时间改变的状态。同时也定义了保存和存储状态的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Originator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在伪代码中尽量简单，这里只用了string类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Originator</span>(<span class="params"><span class="built_in">string</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._state = state;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Originator: My initial state is: &quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Originator: I&#x27;m doing something important.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>._state = <span class="keyword">this</span>.GenerateRandomString(<span class="number">30</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Originator: and my state has changed to: <span class="subst">&#123;_state&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过时间生成随机的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GenerateRandomString</span>(<span class="params"><span class="built_in">int</span> length = <span class="number">10</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> allowedSymbols = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result += allowedSymbols[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, allowedSymbols.Length)];</span><br><span class="line"></span><br><span class="line">            Thread.Sleep(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存现在的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMemento <span class="title">Save</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteMemento(<span class="keyword">this</span>._state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复之前的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Restore</span>(<span class="params">IMemento memento</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(memento <span class="keyword">is</span> ConcreteMemento))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unknown memento class &quot;</span> + memento.ToString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._state = memento.GetState();</span><br><span class="line">        Console.Write(<span class="string">$&quot;Originator: My state has changed to: <span class="subst">&#123;_state&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//备忘录接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMemento</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetState</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DateTime <span class="title">GetDate</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteMemento</span> : <span class="title">IMemento</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DateTime _date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteMemento</span>(<span class="params"><span class="built_in">string</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._state = state;</span><br><span class="line">        <span class="keyword">this</span>._date = DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;<span class="keyword">this</span>._date&#125;</span> / (<span class="subst">&#123;<span class="keyword">this</span>._state.Substring(<span class="number">0</span>, <span class="number">9</span>)&#125;</span>)...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTime <span class="title">GetDate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Caretaker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IMemento&gt; _mementos = <span class="keyword">new</span> List&lt;IMemento&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Originator _originator = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Caretaker</span>(<span class="params">Originator originator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._originator = originator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Backup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nCaretaker: Saving Originator&#x27;s state...&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>._mementos.Add(<span class="keyword">this</span>._originator.Save());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//撤销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._mementos.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> memento = <span class="keyword">this</span>._mementos.Last();</span><br><span class="line">        <span class="keyword">this</span>._mementos.Remove(memento);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Caretaker: Restoring state to: &quot;</span> + memento.GetName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>._originator.Restore(memento);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowHistory</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Caretaker: Here&#x27;s the list of mementos:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> memento <span class="keyword">in</span> <span class="keyword">this</span>._mementos)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(memento.GetName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line">Originator originator = <span class="keyword">new</span> Originator(<span class="string">&quot;Super-duper-super-puper-super.&quot;</span>);</span><br><span class="line">Caretaker caretaker = <span class="keyword">new</span> Caretaker(originator);</span><br><span class="line"></span><br><span class="line">caretaker.Backup();</span><br><span class="line">originator.DoSomething();</span><br><span class="line"></span><br><span class="line">caretaker.Backup();</span><br><span class="line">originator.DoSomething();</span><br><span class="line"></span><br><span class="line">caretaker.Backup();</span><br><span class="line">originator.DoSomething();</span><br><span class="line"></span><br><span class="line">Console.WriteLine();</span><br><span class="line">caretaker.ShowHistory();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\nClient: Now, let&#x27;s rollback!\n&quot;</span>);</span><br><span class="line">caretaker.Undo();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n\nClient: Once more!\n&quot;</span>);</span><br><span class="line">caretaker.Undo();</span><br><span class="line"></span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果,根据当前时间有所变化</span></span><br><span class="line"><span class="comment">可以更改客户端代码来体会更深</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Originator: My initial state is: Super-duper-super-puper-super.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Caretaker: Saving Originator&#x27;s state...</span></span><br><span class="line"><span class="comment">Originator: I&#x27;m doing something important.</span></span><br><span class="line"><span class="comment">Originator: and my state has changed to: oGyQIIatlDDWNgYYqJATTmdwnnGZQj</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Caretaker: Saving Originator&#x27;s state...</span></span><br><span class="line"><span class="comment">Originator: I&#x27;m doing something important.</span></span><br><span class="line"><span class="comment">Originator: and my state has changed to: jBtMDDWogzzRJbTTmEwOOhZrjjBULe</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Caretaker: Saving Originator&#x27;s state...</span></span><br><span class="line"><span class="comment">Originator: I&#x27;m doing something important.</span></span><br><span class="line"><span class="comment">Originator: and my state has changed to: exoHyyRkbuuNEXOhhArKccUmexPPHZ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Caretaker: Here&#x27;s the list of mementos:</span></span><br><span class="line"><span class="comment">12.06.2018 15:52:45 / (Super-dup...)</span></span><br><span class="line"><span class="comment">12.06.2018 15:52:46 / (oGyQIIatl...)</span></span><br><span class="line"><span class="comment">12.06.2018 15:52:46 / (jBtMDDWog...)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Now, let&#x27;s rollback!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Caretaker: Restoring state to: 12.06.2018 15:52:46 / (jBtMDDWog...)</span></span><br><span class="line"><span class="comment">Originator: My state has changed to: jBtMDDWogzzRJbTTmEwOOhZrjjBULe</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Once more!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Caretaker: Restoring state to: 12.06.2018 15:52:46 / (oGyQIIatl...)</span></span><br><span class="line"><span class="comment">Originator: My state has changed to: oGyQIIatlDDWNgYYqJATTmdwnnGZQj</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合备忘录模式的地方"><a href="#适合备忘录模式的地方" class="headerlink" title="适合备忘录模式的地方"></a>适合备忘录模式的地方</h5><ul><li>当你需要创建对象状态快照来恢复其之前的状态时，可以使用备忘录模式。</li><li>当直接访问对象的成员变量、获取器或设置器将导致封装被突破时，可以使用该模式。</li></ul><h5 id="备忘录模式的优缺点"><a href="#备忘录模式的优缺点" class="headerlink" title="备忘录模式的优缺点"></a>备忘录模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以在不破坏对象封装情况的前提下创建对象状态快照。</li><li>你可以通过让负责人维护原发器状态历史记录来简化原发器代码。</li></ul><p><strong>缺点</strong> ：</p><ul><li>如果客户端过于频繁地创建备忘录，程序将消耗大量内存。</li><li>负责人必须完整跟踪原发器的生命周期，这样才能销毁弃用的备忘录。</li><li>绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改（与c#关系不大）。</li></ul><h4 id="Observer-观察者模式"><a href="#Observer-观察者模式" class="headerlink" title="Observer(观察者模式)"></a>Observer(观察者模式)</h4><p>观察者模式是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><h5 id="问题-17"><a href="#问题-17" class="headerlink" title="问题"></a>问题</h5><p>假如你有两种类型的对象：​顾客和 商店 。顾客对某个特定品牌的产品非常感兴趣（例如最新型号的 iPhone 手机），而该产品很快将会在商店里出售。<br>顾客可以每天来商店看看产品是否到货。但如果商品尚未到货时，绝大多数来到商店的顾客都会空手而归。另一方面，每次新产品到货时，商店可以向所有顾客发送邮件（可能会被视为垃圾邮件）。这样，部分顾客就无需反复前往商店了，但也可能会惹恼对新产品没有兴趣的其他顾客。<br>我们似乎遇到了一个矛盾：要么让顾客浪费时间检查产品是否到货，要么让商店浪费资源去通知没有需求的顾客。</p><h5 id="解决方案-17"><a href="#解决方案-17" class="headerlink" title="解决方案"></a>解决方案</h5><p>拥有一些值得关注的状态的对象通常被称为目标，由于它要<strong>将自身的状态改变通知给其他对象</strong>，我们也将其称为发布者(pub­lish­er)。所有<strong>希望关注发布者状态变化的其他对象</strong>被称为订阅者(sub­scribers)。</p><p>观察者模式建议你为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。不要害怕！这并不像听上去那么复杂。实际上，该机制包括 <strong>1)</strong> 一个用于存储订阅者对象引用的列表成员变量；<strong>2)</strong> 几个用于添加或删除该列表中订阅者的公有方法。</p><p>如果你的应用中有多个不同类型的发布者，且希望订阅者可兼容所有发布者，那么你甚至可以进一步让所有发布者遵循同样的接口。该接口仅需描述几个订阅方法即可。这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。</p><h5 id="观察者模式结构"><a href="#观察者模式结构" class="headerlink" title="观察者模式结构"></a>观察者模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220825160617.png" alt="img"></p><p>1.<strong>发布者(Pub­lish­er)</strong> 会向其他对象发送值得关注的事件。事件会在发布者自身状态改变或执行特定行为后发生。发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</p><p>2.当新事件发生时，发送者会遍历订阅列表并调用每个订阅者对象的通知方法。该方法是在订阅者接口中声明的。</p><p>3.<strong>订阅者(Sub­scriber)</strong> 接口声明了通知接口。在绝大多数情况下，该接口仅包含一个 update更新方法。该方法可以拥有多个参数，使发布者能在更新时传递事件的详细信息。</p><p>4.<strong>具体订阅者(Con­crete Sub­scribers)</strong> 可以执行一些操作来回应发布者的通知。所有具体订阅者类都实现了同样的接口，因此发布者不需要与具体类相耦合。</p><p>5.订阅者通常需要一些上下文信息来正确地处理更新。因此，发布者通常会将一些上下文数据作为通知方法的参数进行传递。发布者也可将自身作为参数进行传递，使订阅者直接获取所需的数据。</p><p>6.<strong>客户端(Client)</strong> 会分别创建发布者和订阅者对象，然后为订阅者注册发布者更新。</p><h5 id="伪代码-17"><a href="#伪代码-17" class="headerlink" title="伪代码"></a>伪代码</h5><p>观察者模式在 C# 代码中很常见，特别是在 GUI 组件中。它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。只要是一对多的广播模式的需求，观察者模式基本上可以用到。而且代码结构十分容易理解</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供订阅者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加Observer，也就是接受信息的人</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去掉Observer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Detach</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Notify</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发布者拥有自身状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span> : <span class="title">ISubscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当发布器状态发生改变的时候可能要进行推送</span></span><br><span class="line">    <span class="comment">//伪代码这里简化了状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> State &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125; = <span class="number">-0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅发布器的队列</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;IObserver&gt; _observers = <span class="keyword">new</span> List&lt;IObserver&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">IObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber: Attached an obseerver.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>._observers.Add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span>(<span class="params">IObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._observers.Remove(observer);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber: Detached an observer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber: Notifying observers...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> observer <span class="keyword">in</span> _observers)</span><br><span class="line">        &#123;</span><br><span class="line">            observer.Update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeBusinessLogic</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nsubscriber: I&#x27;m doing something important.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.State = <span class="keyword">new</span> Random().Next(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;subscriber: My state has just changed to: &quot;</span> + <span class="keyword">this</span>.State);</span><br><span class="line">        <span class="keyword">this</span>.Notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubscriber subscriber</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteObserverA</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubscriber subscriber</span>)</span></span><br><span class="line">    &#123;            </span><br><span class="line">        <span class="keyword">if</span> ((subscriber <span class="keyword">as</span> Subscriber).State &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ConcreteObserverA: Reacted to the event.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteObserverB</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubscriber subscriber</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((subscriber <span class="keyword">as</span> Subscriber).State == <span class="number">0</span> || (subscriber <span class="keyword">as</span> Subscriber).State &gt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ConcreteObserverB: Reacted to the event.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observerA = <span class="keyword">new</span> ConcreteObserverA();</span><br><span class="line">subscriber.Attach(observerA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observerB = <span class="keyword">new</span> ConcreteObserverB();</span><br><span class="line">subscriber.Attach(observerB);</span><br><span class="line"></span><br><span class="line">subscriber.SomeBusinessLogic();</span><br><span class="line">subscriber.SomeBusinessLogic();</span><br><span class="line"></span><br><span class="line">subscriber.Detach(observerB);</span><br><span class="line"></span><br><span class="line">subscriber.SomeBusinessLogic();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Subscriber: Attached an observer.</span></span><br><span class="line"><span class="comment">Subscriber: Attached an observer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Subscriber: I&#x27;m doing something important.</span></span><br><span class="line"><span class="comment">Subscriber: My state has just changed to: 2</span></span><br><span class="line"><span class="comment">Subscriber: Notifying observers...</span></span><br><span class="line"><span class="comment">ConcreteObserverA: Reacted to the event.</span></span><br><span class="line"><span class="comment">ConcreteObserverB: Reacted to the event.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Subscriber: I&#x27;m doing something important.</span></span><br><span class="line"><span class="comment">Subscriber: My state has just changed to: 1</span></span><br><span class="line"><span class="comment">Subscriber: Notifying observers...</span></span><br><span class="line"><span class="comment">ConcreteObserverA: Reacted to the event.</span></span><br><span class="line"><span class="comment">Subscriber: Detached an observer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Subscriber: I&#x27;m doing something important.</span></span><br><span class="line"><span class="comment">Subscriber: My state has just changed to: 5</span></span><br><span class="line"><span class="comment">Subscriber: Notifying observers...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合观察者模式的地方"><a href="#适合观察者模式的地方" class="headerlink" title="适合观察者模式的地方"></a>适合观察者模式的地方</h5><ul><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时，可使用观察者模式。</li><li>当应用中的一些对象必须观察其他对象时，可使用该模式。但仅能在有限时间内或特定情况下使用。</li></ul><h5 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>符合OCP</li><li>你可以在运行时建立对象之间的联系。</li></ul><p><strong>缺点</strong> ：</p><ul><li>订阅者的通知顺序是随机的。</li></ul><h4 id="State-状态模式"><a href="#State-状态模式" class="headerlink" title="State(状态模式)"></a>State(状态模式)</h4><p>状态模式是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。</p><h5 id="问题-18"><a href="#问题-18" class="headerlink" title="问题"></a>问题</h5><p>状态模式与有限状态机的概念紧密相关。<br>其主要思想是程序在任意时刻仅可处于几种<strong>有限的状态</strong>中。在任何一个特定状态中，程序的行为都不相同，且可瞬间从一个状态切换到另一个状态。不过，根据当前状态，程序可能会切换到另外一种状态，也可能会保持当前状态不变。这些数量有限且预先定义的状态切换规则被称为转移。</p><p>状态机通常由众多条件运算符 （ if或 switch ） 实现，可根据对象的当前状态选择相应的行为。 ​“状态” 通常只是对象中的一组成员变量值。即使你之前从未听说过有限状态机，你也很可能已经实现过状态模式。下面的代码应该能帮助你回忆起来。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Document</span> <span class="title">is</span></span><br><span class="line">    <span class="title">field</span> <span class="title">state</span>: <span class="title">string</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title">method</span> <span class="title">publish</span>() <span class="title">is</span></span><br><span class="line">        <span class="title">switch</span> (<span class="title">state</span>)</span><br><span class="line">            &quot;<span class="title">draft</span>&quot;:</span><br><span class="line">                <span class="title">state</span> = <span class="string">&quot;moderation&quot;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="string">&quot;moderation&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> (currentUser.role == <span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                    state = <span class="string">&quot;published&quot;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="string">&quot;published&quot;</span>:</span><br><span class="line">                <span class="comment">// 什么也不做。</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>当我们逐步在文档类中添加更多状态和依赖于状态的行为后，基于条件语句的状态机就会暴露其最大的弱点。为了能根据当前状态选择完成相应行为的方法，绝大部分方法中会包含复杂的条件语句。修改其转换逻辑可能会涉及到修改所有方法中的状态条件语句，导致代码的维护工作非常艰难。</p><h5 id="解决方案-18"><a href="#解决方案-18" class="headerlink" title="解决方案"></a>解决方案</h5><p>状态模式建议为对象的所有可能状态新建一个类，然后将所有状态的对应行为抽取到这些类中。</p><p>原始对象被称为上下文(con­text)，它并不会自行实现所有行为，而是会保存一个指向表示当前状态的状态对象的引用，且将所有与状态相关的工作委派给该对象。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220825164123.png" alt="img"></p><p>如需将上下文转换为另外一种状态，则需将当前活动的状态对象替换为另外一个代表新状态的对象。采用这种方式是有前提的：所有状态类都必须遵循同样的接口，而且上下文必须仅通过接口与这些对象进行交互。</p><p>这个结构可能看上去与策略模式相似，但有一个关键性的不同—— 在状态模式中，特<strong>定状态知道其他所有状态的存在，且能触发从一个状态到另一个状态的转换</strong>；策略则<strong>几乎完全不知道其他策略的存在</strong>。</p><h5 id="状态模式结构"><a href="#状态模式结构" class="headerlink" title="状态模式结构"></a>状态模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220825164235.png" alt="img"></p><p>1.<strong>上下文(Con­text)</strong> 保存了对于一个具体状态对象的引用，并会将所有与该状态相关的工作委派给它。上下文通过状态接口与状态对象交互，且会提供一个设置器用于传递新的状态对象。</p><p>2.<strong>状态(State)</strong> 接口会声明特定于状态的方法。这些方法应能被其他所有具体状态所理解，因为你不希望某些状态所拥有的方法永远不会被调用。</p><p>3.<strong>具体状态(Con­crete States)</strong> 会自行实现特定于状态的方法。为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类。<br>状态对象可存储对于上下文对象的反向引用。状态可以通过该引用从上下文处获取所需信息，并且能触发状态转移。</p><p>4.上下文和具体状态都可以设置上下文的下个状态，并可通过替换连接到上下文的状态对象来完成实际的状态转换。</p><h5 id="伪代码-18"><a href="#伪代码-18" class="headerlink" title="伪代码"></a>伪代码</h5><p>状态模式在游戏中还是十分常见的，比如人物动画状态的变化，但是比较多的还是AI中，不过是简单游戏里的（大型游戏的方案可能不太一样）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Context类就是要进行状态变化的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> State _state = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">State state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ChangeState(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params">State state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Context: Transition to <span class="subst">&#123;state.GetType().Name&#125;</span>.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>._state = state;</span><br><span class="line">        <span class="keyword">this</span>._state.SetContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._state.Handle1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._state.Handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//状态基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Context _context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetContext</span>(<span class="params">Context context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle1</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle2</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">&quot;ConcreteStateA handles request1.&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ConcreteStateA wants to change the state of the context.&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>._context.ChangeState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">&quot;ConcreteStateA handles request2.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;ConcreteStateB handles request1.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ConcreteStateB handles request2.&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ConcreteStateB wants to change the state of the context.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>._context.ChangeState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">context.Request1();</span><br><span class="line">context.Request2();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Context: Transition to ConcreteStateA.</span></span><br><span class="line"><span class="comment">ConcreteStateA handles request1.</span></span><br><span class="line"><span class="comment">ConcreteStateA wants to change the state of the context.</span></span><br><span class="line"><span class="comment">Context: Transition to ConcreteStateB.</span></span><br><span class="line"><span class="comment">ConcreteStateB handles request2.</span></span><br><span class="line"><span class="comment">ConcreteStateB wants to change the state of the context.</span></span><br><span class="line"><span class="comment">Context: Transition to ConcreteStateA.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合状态模式的地方"><a href="#适合状态模式的地方" class="headerlink" title="适合状态模式的地方"></a>适合状态模式的地方</h5><ul><li>如果对象需要根据自身当前状态进行不同行为，同时状态的数量非常多且与状态相关的代码会频繁变更的话，可使用状态模式。</li><li>如果某个类需要根据成员变量的当前值改变自身行为，从而需要使用大量的条件语句时，可使用该模式。</li><li>当相似状态和基于条件的状态机转换中存在许多重复代码时，可使用状态模式。</li></ul><h5 id="状态模式的优缺点"><a href="#状态模式的优缺点" class="headerlink" title="状态模式的优缺点"></a>状态模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>符合SRP</li><li>符合OCP</li><li>通过消除臃肿的状态机条件语句简化上下文代码。</li></ul><p><strong>缺点</strong> ：</p><ul><li>如果状态机只有很少的几个状态，或者很少发生改变，那么应用该模式可能会显得小题大作。</li></ul><h4 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy(策略模式)"></a>Strategy(策略模式)</h4><p>策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。</p><h5 id="问题-19"><a href="#问题-19" class="headerlink" title="问题"></a>问题</h5><p>一天，你打算为游客们创建一款导游程序。该程序的核心功能是提供美观的地图， 以帮助用户在任何城市中快速定位。用户期待的程序新功能是自动路线规划：他们希望输入地址后就能在地图上看到前往目的地的最快路线。程序的首个版本只能规划公路路线。驾车旅行的人们对此非常满意。但很显然，并非所有人都会在度假时开车。因此你在下次更新时添加了规划步行路线的功能。此后，你又添加了规划公共交通路线的功能。而这只是个开始。不久后，你又要为骑行者规划路线。又过了一段时间，你又要为游览城市中的所有景点规划路线。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826203722.png" alt="img"></p><h5 id="解决方案-19"><a href="#解决方案-19" class="headerlink" title="解决方案"></a>解决方案</h5><p>策略模式建议<strong>找出负责用许多不同方式完成特定任务的类，然后将其中的算法抽取到一组</strong>被称为策略的独立类中。名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用。上下文并不执行任务，而是将工作委派给已连接的策略对象。上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。实际上，上下文并不十分了解策略，它会通过同样的通用接口与所有策略进行交互，而该接口只需暴露一个方法来触发所选策略中封装的算法即可。（上下文其实就是主角）</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826205036.png" alt="img"></p><h5 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826205148.png" alt="img"></p><p>1.<strong>上下文(Con­text)</strong> 维护指向具体策略的引用，且仅通过策略接口与该对象进行交流。</p><p>2.<strong>策略(Strat­e­gy)</strong> 接口是所有具体策略的通用接口，它声明了一个上下文用于执行策略的方法。</p><p>3.<strong>具体策略(Con­crete Strate­gies)</strong> 实现了上下文所用算法的各种不同变体。</p><p>4.当上下文需要运行算法时，它会在其已连接的策略对象上调用执行方法。上下文不清楚其所涉及的策略类型与算法的执行方式。</p><p>5.<strong>客户端(Client)</strong> 会创建一个特定策略对象并将其传递给上下文。上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</p><h5 id="伪代码-19"><a href="#伪代码-19" class="headerlink" title="伪代码"></a>伪代码</h5><p>由于跟状态模式很相近，还是很容易理解的，注意一下不同就可以。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Context主体类，其实可以是Player类，相当于主题做操作的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用的策略</span></span><br><span class="line">    <span class="keyword">private</span> IStrategy _strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">IStrategy strategy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetStrategy</span>(<span class="params">IStrategy strategy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据策略进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomeBusinessLogic</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Context: Sorting data using the strategy (not sure how it&#x27;ll do it)&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">this</span>._strategy.DoAlgorithm(<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> resultStr = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> element <span class="keyword">in</span> result <span class="keyword">as</span> List&lt;<span class="built_in">string</span>&gt;)</span><br><span class="line">        &#123;</span><br><span class="line">            resultStr += element + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(resultStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Strategy接口声明方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">DoAlgorithm</span>(<span class="params"><span class="built_in">object</span> data</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> : <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">DoAlgorithm</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> list = data <span class="keyword">as</span> List&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">        list.Sort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> : <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">DoAlgorithm</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> list = data <span class="keyword">as</span> List&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">        list.Sort();</span><br><span class="line">        list.Reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Client: Strategy is set to normal sorting.&quot;</span>);</span><br><span class="line">context.SetStrategy(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">context.DoSomeBusinessLogic();</span><br><span class="line">            </span><br><span class="line">Console.WriteLine();</span><br><span class="line">            </span><br><span class="line">Console.WriteLine(<span class="string">&quot;Client: Strategy is set to reverse sorting.&quot;</span>);</span><br><span class="line">context.SetStrategy(<span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">context.DoSomeBusinessLogic();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">Client: Strategy is set to normal sorting.</span></span><br><span class="line"><span class="comment">Context: Sorting data using the strategy (not sure how it&#x27;ll do it)</span></span><br><span class="line"><span class="comment">a,b,c,d,e</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Strategy is set to reverse sorting.</span></span><br><span class="line"><span class="comment">Context: Sorting data using the strategy (not sure how it&#x27;ll do it)</span></span><br><span class="line"><span class="comment">e,d,c,b,a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合策略模式的地方"><a href="#适合策略模式的地方" class="headerlink" title="适合策略模式的地方"></a>适合策略模式的地方</h5><ul><li>当你想使用对象中各种不同的算法变体，并希望能在运行时切换算法时，可使用策略模式。</li><li>当你有许多仅在执行某些行为时略有不同的相似类时，可使用策略模式。</li><li>如果算法在上下文的逻辑中不是特别重要，使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</li><li>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时，可使用该模式。</li></ul><h5 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可以在运行时切换对象内的算法。</li><li>你可以将算法的实现和使用算法的代码隔离开来。</li><li>你可以使用组合来代替继承。</li><li>符合OCP</li></ul><p><strong>缺点</strong> ：</p><ul><li>如果你的算法极少发生改变，那么没有任何理由引入新的类和接口。使用该模式只会让程序过于复杂。</li><li>客户端必须知晓策略间的不同——它需要选择合适的策略。</li><li>许多现代编程语言支持函数类型功能，允许你在一组匿名函数中实现不同版本的算法。这样，你使用这些函数的方式就和使用策略对象时完全相同，无需借助额外的类和接口来保持代码简洁。</li></ul><h4 id="Template-Method-模板方法模式"><a href="#Template-Method-模板方法模式" class="headerlink" title="Template Method(模板方法模式)"></a>Template Method(模板方法模式)</h4><p>模板方法模式是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。</p><h5 id="问题-20"><a href="#问题-20" class="headerlink" title="问题"></a>问题</h5><p>假如你正在开发一款分析公司文档的数据挖掘程序。 用户需要向程序输入各种格式 （PDF、 DOC 或 CSV） 的文档，程序则会试图从这些文件中抽取有意义的数据，并以统一的格式将其返回给用户。</p><p>该程序的首个版本仅支持 DOC 文件。在接下来的一个版本中，程序能够支持 CSV 文件。一个月后，你 “教会” 了程序从 PDF 文件中抽取数据。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826213247.png" alt="img"></p><p>一段时间后，你发现这三个类中包含许多相似代码。 尽管这些类处理不同数据格式的代码完全不同，但数据处理和分析的代码却几乎完全一样。如果能在保持算法结构完整的情况下去除重复代码，这难道不是一件很棒的事情吗？</p><p>还有另一个与使用这些类的客户端代码相关的问题：客户端代码中包含许多条件语句，以根据不同的处理对象类型选择合适的处理过程。如果所有处理数据的类都拥有相同的接口或基类，那么你就可以去除客户端代码中的条件语句，转而使用多态机制来在处理对象上调用函数。</p><h5 id="解决方案-20"><a href="#解决方案-20" class="headerlink" title="解决方案"></a>解决方案</h5><p>模板方法模式建议将算法分解为一系列步骤，然后将这些步骤改写为方法，最后在 “模板方法” 中依次调用这些方法。步骤可以是抽象的，也可以有一些默认的实现。为了能够使用算法，客户端需要自行提供子类并实现所有的抽象步骤。如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826213427.png" alt="img"></p><p>首先， 我们将所有步骤声明为 抽象类型， 强制要求子类自行实现这些方法。 在我们的例子中， 子类中已有所有必要的实现， 因此我们只需调整这些方法的签名， 使之与超类的方法匹配即可。</p><p>现在，让我们看看如何去除重复代码。对于不同的数据格式，打开和关闭文件以及抽取和解析数据的代码都不同，因此无需修改这些方法。但分析原始数据和生成报告等其他步骤的实现方式非常相似，因此可将其提取到基类中，以让子类共享这些代码。</p><p>正如你所看到的那样，我们有两种类型的步骤：</p><ul><li>抽象步骤必须由各个子类来实现</li><li>可选步骤已有一些默认实现，但仍可在需要时进行重写</li></ul><p>还有另一种名为钩子的步骤。钩子是内容为空的可选步骤。即使不重写钩子，模板方法也能工作。钩子通常放置在算法重要步骤的前后，为子类提供额外的算法扩展点。</p><h5 id="模板方法模式结构"><a href="#模板方法模式结构" class="headerlink" title="模板方法模式结构"></a>模板方法模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826214113.png" alt="img"></p><p>1.<strong>抽象类(Abstract­Class)</strong> 会声明作为算法步骤的方法，以及依次调用它们的实际模板方法。算法步骤可以被声明为 抽象类型，也可以提供一些默认实现。</p><p>2.<strong>具体类(Con­crete­Class)</strong> 可以重写所有步骤，但不能重写模板方法自身。</p><h5 id="伪代码-20"><a href="#伪代码-20" class="headerlink" title="伪代码"></a>伪代码</h5><p>本例中的模板方法模式为一款简单策略游戏中人工智能的不同分支提供 “框架”。游戏中所有的种族都有几乎同类的单位和建筑。因此你可以在不同的种族上复用相同的 AI 结构，同时还需要具备重写一些细节的能力。通过这种方式，你可以重写半兽人的 AI 使其更富攻击性，也可以让人类侧重防守，还可以禁止怪物建造建筑。在游戏中新增种族需要创建新的 AI 子类，还需要重写 AI 基类中所声明的默认方法。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826214223.png" alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这下真的是伪代码了</span></span><br><span class="line"><span class="comment">// 抽象类定义了一个模板方法，其中通常会包含某个由抽象原语操作调用组成的算</span></span><br><span class="line"><span class="comment">// 法框架。具体子类会实现这些操作，但是不会对模板方法做出修改。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">GameAI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//某些步骤可以在基类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turn</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        collectResources();</span><br><span class="line">        buildStructures();</span><br><span class="line">        buildUnits();</span><br><span class="line">        attack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectResources</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> s <span class="keyword">in</span> <span class="keyword">this</span>.builtStructures)</span><br><span class="line">        &#123;</span><br><span class="line">            s.collect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildStructures</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildUnits</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> enemy = cloestEnemy();</span><br><span class="line">        <span class="keyword">if</span>(enemy == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sendScouts(map.center);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            sendWarriors(enemy.position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendScouts</span>(<span class="params">position</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendWarriors</span>(<span class="params">position</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">OrcsAI</span> : <span class="title">GameAI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">buildStructures</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (there are some resources) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 建造农场，接着是谷仓，然后是要塞。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">buildUnits</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (there are plenty of resources) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (there are no scouts)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建造苦工，将其加入侦查编组。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建造兽族步兵，将其加入战士编组。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">sendScouts</span>(<span class="params">position</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(scouts.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将侦查编组送到指定位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">sendWarriors</span>(<span class="params">position</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(warriors.length &gt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将战斗编组送到指定位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MonstersAI</span> : <span class="title">GameAI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">collectResources</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 怪物不会采集资源。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">buildStructures</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 怪物不会建造建筑。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">buildUnits</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 怪物不会建造单位。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适合模板方法模式的地方"><a href="#适合模板方法模式的地方" class="headerlink" title="适合模板方法模式的地方"></a>适合模板方法模式的地方</h5><ul><li>当你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式。</li><li>当多个类的算法除一些细微不同之外几乎完全一样时，你可使用该模式。但其后果就是，只要算法发生变化，你就可能需要修改所有的类。</li></ul><h5 id="模板方法的优缺点"><a href="#模板方法的优缺点" class="headerlink" title="模板方法的优缺点"></a>模板方法的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>你可仅允许客户端重写一个大型算法中的特定部分，使得算法其他部分修改对其所造成的影响减小。</li><li>你可将重复代码提取到一个超类中。</li></ul><p><strong>缺点</strong> ：</p><ul><li>部分客户端可能会受到算法框架的限制。</li><li>通过子类抑制默认步骤实现可能会导致违反里氏替换原则(Liskov)。</li><li>模板方法中的步骤越多， 其维护工作就可能会越困难。</li></ul><h4 id="Visitor-访问者模式"><a href="#Visitor-访问者模式" class="headerlink" title="Visitor(访问者模式)"></a>Visitor(访问者模式)</h4><p>访问者模式是一种行为设计模式，它能将算法与其所作用的对象隔离开来。</p><h5 id="问题-21"><a href="#问题-21" class="headerlink" title="问题"></a>问题</h5><p>假如你的团队开发了一款能够使用巨型图像中地理信息的应用程序。图像中的每个节点既能代表复杂实体 （例如一座城市），也能代表更精细的对象 （例如工业区和旅游景点等）。如果节点代表的真实对象之间存在公路，那么这些节点就会相互连接。在程序内部，每个节点的类型都由其所属的类来表示，每个特定的节点则是一个对象。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826224114.png" alt="img"></p><p>一段时间后，你接到了实现将图像导出到 XML 文件中的任务。这些工作最初看上去非常简单。你计划为每个节点类添加导出函数，然后递归执行图像中每个节点的导出函数。解决方案简单且优雅：使用多态机制可以让导出方法的调用代码不会和具体的节点类相耦合。</p><p>但你不太走运，系统架构师拒绝批准对已有节点类进行修改。他认为这些代码已经是产品了，不想冒险对其进行修改，因为修改可能会引入潜在的缺陷。</p><p>此外，他还质疑在节点类中包含导出 XML 文件的代码是否有意义。这些类的主要工作是处理地理数据。导出 XML 文件的代码放在这里并不合适。</p><p>还有另一个原因，那就是在此项任务完成后，营销部门很有可能会要求程序提供导出其他类型文件的功能，或者提出其他奇怪的要求。这样你很可能会被迫再次修改这些重要但脆弱的类。</p><h5 id="解决方案-21"><a href="#解决方案-21" class="headerlink" title="解决方案"></a>解决方案</h5><p>访问者模式建议将<strong>新行为放入一个名为访问者的独立类中，而不是试图将其整合到已有类中</strong>。现在，需要执行操作的原始对象将作为参数被传递给访问者中的方法，让方法能访问对象所包含的一切必要数据。</p><h5 id="访问者模式结构"><a href="#访问者模式结构" class="headerlink" title="访问者模式结构"></a>访问者模式结构</h5><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/DesignPatternsRuMen/20220826230156.png" alt="img"></p><p>1.<strong>访问者(Vis­i­tor)</strong> 接口声明了一系列以对象结构的具体元素为参数的访问者方法。如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的。</p><p>2.<strong>具体访问者(Con­crete Vis­i­tor)</strong> 会为不同的具体元素类实现相同行为的几个不同版本。</p><p>3.<strong>元素(Ele­ment)</strong> 接口声明了一个方法来 “接收” 访问者。该方法必须有一个参数被声明为访问者接口类型。</p><p>4.<strong>具体元素(Con­crete Ele­ment)</strong> 必须实现接收方法。该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。请注意，即使元素基类实现了该方法，所有子类都必须对其进行重写并调用访问者对象中的合适方法。</p><p>5.<strong>客户端(Client)</strong> 通常会作为集合或其他复杂对象（例如一个组合树）的代表。客户端通常不知晓所有的具体元素类，因为它们会通过抽象接口与集合中的对象进行交互。</p><h5 id="伪代码-21"><a href="#伪代码-21" class="headerlink" title="伪代码"></a>伪代码</h5><p>访问者不是常用的设计模式，因为它不仅复杂，应用范围也比较狭窄。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Component接口声明一个accept方法来使用visitor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">IVisitor visitor</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体Component类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteComponentA</span> : <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">IVisitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        visitor.VisitCOncreteComponentA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体Component类中一些自己的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ExclusiveMethodOfConcreteComponentA</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteComponentB</span> : <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">IVisitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        visitor.VisitCOncreteComponentB(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体Component类中一些自己的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ExclusiveMethodOfConcreteComponentB</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Visitor接口声明一系列访问Component的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VisitConcreteComponentA</span>(<span class="params">ConcreteComponentA element</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VisitConcreteComponentB</span>(<span class="params">ConcreteComponentB element</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteVisitor1</span> : <span class="title">IVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitConcreteComponentA</span>(<span class="params">ConcreteComponentA element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(element.ExclusiveMethodOfConcreteComponentA() + <span class="string">&quot; + ConcreteVisitor1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitConcreteComponentB</span>(<span class="params">ConcreteComponentB element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(element.SpecialMethodOfConcreteComponentB() + <span class="string">&quot; + ConcreteVisitor1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteVisitor2</span> : <span class="title">IVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitConcreteComponentA</span>(<span class="params">ConcreteComponentA element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(element.ExclusiveMethodOfConcreteComponentA() + <span class="string">&quot; + ConcreteVisitor2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VisitConcreteComponentB</span>(<span class="params">ConcreteComponentB element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(element.SpecialMethodOfConcreteComponentB() + <span class="string">&quot; + ConcreteVisitor2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClientCode</span>(<span class="params">List&lt;IComponent&gt; components, IVisitor visitor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> component <span class="keyword">in</span> components)</span><br><span class="line">        &#123;</span><br><span class="line">            component.Accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line">List&lt;IComponent&gt; components = <span class="keyword">new</span> List&lt;IComponent&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> ConcreteComponentA(),</span><br><span class="line">    <span class="keyword">new</span> ConcreteComponentB()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The client code works with all visitors via the base Visitor interface:&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> visitor1 = <span class="keyword">new</span> ConcreteVisitor1();</span><br><span class="line">Client.ClientCode(components,visitor1);</span><br><span class="line"></span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;It allows the same client code to work with different types of visitors:&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> visitor2 = <span class="keyword">new</span> ConcreteVisitor2();</span><br><span class="line">Client.ClientCode(components, visitor2);</span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">The client code works with all visitors via the base Visitor interface:</span></span><br><span class="line"><span class="comment">A + ConcreteVisitor1</span></span><br><span class="line"><span class="comment">B + ConcreteVisitor1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">It allows the same client code to work with different types of visitors:</span></span><br><span class="line"><span class="comment">A + ConcreteVisitor2</span></span><br><span class="line"><span class="comment">B + ConcreteVisitor2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="适合访问者模式的地方"><a href="#适合访问者模式的地方" class="headerlink" title="适合访问者模式的地方"></a>适合访问者模式的地方</h5><ul><li>如果你需要对一个复杂对象结构（例如对象树）中的所有元素执行某些操作，可使用访问者模式。</li><li>可使用访问者模式来清理辅助行为的业务逻辑。</li><li>当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时，可使用该模式。</li></ul><h5 id="访问者模式的优缺点"><a href="#访问者模式的优缺点" class="headerlink" title="访问者模式的优缺点"></a>访问者模式的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>符合OCP</li><li>符合SRP</li><li>访问者对象可以在与各种对象交互时收集一些有用的信息。当你想要遍历一些复杂的对象结构（例如对象树），并在结构中的每个对象上应用访问者时，这些信息可能会有所帮助。</li></ul><p><strong>缺点</strong> ：</p><ul><li>每次在元素层次结构中添加或移除一个类时，你都要更新所有的访问者。</li><li>在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。</li></ul><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这次花了差不多20天的时间来写这一个博客记录一下关于设计模式的学习，其实看书的时间不算长，主要花时间的是写出让人容易懂的博客。学习了初步的设计模式的知识，以前看过的但是不是很懂的知识突然就明白了一些。当然，由于自身还没写过上万行的代码，后面肯定还会在复习一下设计模式，不过看的书应该是讲解地更深入的书籍。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《敏捷软件设计开发》</li><li><a href="https://refactoring.guru/design-patterns(%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%9C%B0%E8%AE%B2%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E5%A4%A7%E9%83%A8%E5%88%86%E4%BE%8B%E5%AD%90%E6%98%AF%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84)">https://refactoring.guru/design-patterns(通俗易懂地讲解设计模式的网站，大部分例子是引用它的)</a></li><li><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html(%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BE%8B%E5%AD%90%E6%9D%A5%E5%AD%A6%E4%B9%A0)">https://www.runoob.com/design-pattern/design-pattern-tutorial.html(菜鸟教程中的设计模式，提供更多的例子来学习)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近花了点读了《敏捷软件开发》这本书，关于这本书，我基本上是随便看看，了解有什么知识，也就在代码部分（具体示例方面）花了些功夫。尽管知道了解</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021 广州核聚变</title>
    <link href="http://example.com/2021/11/28/2021-%E5%B9%BF%E5%B7%9E%E6%A0%B8%E8%81%9A%E5%8F%98/"/>
    <id>http://example.com/2021/11/28/2021-%E5%B9%BF%E5%B7%9E%E6%A0%B8%E8%81%9A%E5%8F%98/</id>
    <published>2021-11-28T04:03:23.000Z</published>
    <updated>2024-01-07T07:44:17.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识机核"><a href="#认识机核" class="headerlink" title="认识机核"></a>认识机核</h3><p>说起核聚变，就不得不说是如何知道机核的。如果不知道机核的话，基本上是不知道有这个活动的。当时明日方舟二周年活动——覆潮之下，特别克苏鲁，当时就打算了解一下克苏鲁，PV评论下有介绍故事背景，便搜索了印斯茅斯的阴霾，便接触了b站的机核网。到了暑假，实在是无聊，便打算听听电台，于是便打开了机核网页版，开始听各种各样的电台，听一堆大叔胡逼吹牛讲故事还挺有意思。</p><h3 id="去核聚变之前的准备"><a href="#去核聚变之前的准备" class="headerlink" title="去核聚变之前的准备"></a>去核聚变之前的准备</h3><p>准备在机核听电台的时候看到新的一次核聚变要来广州举办，想着我也没去参观过游戏展，于是便打算去了。那段时间ddl还特别多，11.20、11.21我两天都想去，于是我把ddl提前打算提前做完，那3周是真的一直肝作业，早上下午上课，晚上肝作业。约上2个朋友陪我参加第一天的核聚变，第二天打算自己一个人去玩，认为体验会有所不一样，事实也是，确实是个有意思的经历。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/1.png" alt="img"></p><p>不幸的是，我在决定好了之后我们院的院运会安排在11.21，撞了日期很是糟糕，而且还必须参加开幕式🤕，班级选的入场表演我觉得不太好，于是参加彩旗队，一开始以为彩旗队会像大一原来的电信学院一样轻松，就开幕式举着旗子走过去，没想到现在这个学院要做好多动作，大概排练了六七次，每次半个钟😂。不过还是没参加任何一个项目，决定开幕式结束就准备溜。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/2.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/3.png" alt="img"></p><h3 id="核聚变第一天"><a href="#核聚变第一天" class="headerlink" title="核聚变第一天"></a>核聚变第一天</h3><p>从大学城南到达琶洲，只用坐3个地铁站，二十分钟左右就到了，还是蛮近的。当天有三个展览，一个广交会，一个车展，一个核聚变，我像个铸币一样跟着人流到了核聚变展馆的对面。到门口的时候发现不对劲，赶紧穿过地铁站到达保利世贸博览馆，还记得去年国庆去漫展也是到的这里。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/4.png" alt="img"></p><p>等候同学，没想到他忘带身份证了，还好支付宝有电子身份证，虽然也没用到，最后也只是登记就过了😂。没想到的是广州公安借此冲业绩（ 下载国家反诈APP），虽然学校已经强制要求我们下载了，但是参加这个展览主要还是社会人士，于是因此排了很久。身份证验证的时候我反而比我忘带身份证的同学慢，人脸识别的机器对我来说太矮了，我一开始蹲下一直没检测到，看着其他列的别人先过去，还是十分尴尬的。</p><p>扫码正式进入场馆，领了一个蓝色day01手环，一个taptap集印章的手册，和一个核聚变展览手册。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/5.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/6.png" alt="img"></p><p>是跟两个同学一起来，但是还有一个人没有到，于是我们打算大致逛一下。看了一会发现有很多好玩的，于是打算等那个同学来了之后再一起玩。于是到了独立游戏区，在去核聚变之前，我有在看机核发布的独立游戏展示的直播录像。在众多独立游戏之中，我决定先看看双相，是一个不错的平台跳跃游戏，游戏难度适中，解谜也挺不错的。玩到第七关卡在那了（总共有八关），此时已经十一点多了，另一个同学也来了，让他带了份麦当劳。我们准备在中午休息时吃完然后开始玩。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/7.png" alt="img"><br>从12点多开始，我们现在taptap区游荡，一开始玩透视和深沉之火，都是非常有意思的游戏。不过深沉之火太多人玩了，根本排不到队伍，但是有缘跟开发者聊关于游戏开发的一些边边角角。为了集20个章，去得一个taptap的画册（事后有点后悔，感觉质量一般，不过毕竟不是买的，也不是那种很贵的画册）。除了前面的游戏，其中比较有意思的游戏，霓虹深渊，像素类横板跳跃rougelike弹幕游戏，运气比较欧，打三个boss，第一个打完就拿到了最好的激光枪，在那站撸，2分钟就完成了任务，获得了个马克杯，还算不错，接着断断续续的玩到3点多，终于集齐二十个章，便跑去核聚变的主场馆玩游戏。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/8.png" alt="img"></p><p>首先是剑玉，一个挺好玩的玩具，还可以集印章，每个人有三次挑战机会，我在第三次的时候挑战成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/9.png" alt="img"></p><p>接着到旁边去玩了鬼灭之刃的火神雪风谭，可以说就是3d的拳皇，十分有意思，（第二天我也去玩了，也就是这个游戏，让我有了一个奇妙的经历），同样也没有拍照留念😇。双人成行和地平线5排队的人太多了，于是到任天堂大乱斗区玩，2v2，任天堂的游戏就是好玩。此时已经四点了，去看看主舞台的最后活动。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/10.png" alt="img"></p><p>今日核聚变结束，晚到的同学不在广州读大学，这次来是为了顺便找女朋友，于是剩下的两个单身狗到旁边的商城吃饭，港式茶餐厅，甜腻的要死，有个鸡脆骨都没吃多少。写的时候才发现自己并没有拍照(;´༎ຶД༎ຶ&#96;)，虽然过于甜腻，但是卖相还是不错的（大众点评找到的图。 报菜名：滑蛋牛肉饭（看着分量少，一开始以为不够吃，没想到糖加了好多，太腻歪了），鸡脆骨（好吃，但是最后吃不下了），小食拼盘（香肠、猪肠粉、鱼蛋、鸡翼尖），西多士（无敌好吃😋，12块钱9个，全场最值的）</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/11.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/12.png" alt="img"></p><p>晚上回到宿舍已经是七点多了，收拾下东西洗个澡发现自己忘记做限时答题了，好在周日还有得答题，定下闹钟。</p><h3 id="核聚变第二天"><a href="#核聚变第二天" class="headerlink" title="核聚变第二天"></a>核聚变第二天</h3><p>周日院运会开完已经是10点半了比官方手册预计的时间还延迟了半个钟（😂100米 10点开跑），在站的时候还收到消息说我的大作业建模的模型不能用于3d打印，只好找淘宝修复并打印，花了150大洋😭😭。一结束，在小卖部买了两个面包来应付中午吃的东西，坐上地铁11点10分就进入场馆了（前面并没有排队，估计是太晚了）。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/13.png" alt="img"></p><p>一开始先想着把章给收集了，然后再玩个痛快，先去玩了暖雪，挺容易上手的。然后专门排了40分钟玩地平线5，手柄+大屏幕真是爽爆了，不过没去排有方向盘的队伍😢（很可惜，而且我还没挑战成功，第一次用手柄玩赛车游戏）。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/14.png" alt="img"></p><p>然后去玩帝国时代IV，还是不错的游戏，以前挺喜欢玩的游戏类型，现在更喜欢动作类和解谜类游戏了。又排了一下队玩完异星求生，决定再玩一个游戏，鬼灭之刃，这个是我认识那位陌生人的契机。原本只打了一把5局三胜的没有聊起来，但是看到工作人员没有过来，我们便再开了一把，于是便开始聊起来了，谈论自己平常玩什么游戏。然后带他去集章，他是周六上班，周日过来的（只有单休，打工人命苦啊），从北方一个人过来来广州一个外贸公司当设计(特别有勇气，敬佩)。带他去玩双人冰壶，任天堂，还有霓虹深渊，可惜的是霓虹深渊今天翻车了，没能成功再次拿到礼品🤣。</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/15.png" alt="img"></p><p>在闭幕前终于玩到深沉之火了，玩完后我们便离开场馆，我成功突破社恐的第一步，邀请他一起吃饭，仍然是到旁边的六元素吃饭，不过这次是大师兄（陕西面）。又没拍照🤐（没有拍吃的饭的习惯）。他请了我一个肉夹馍，原本想要全请我的，但是毕竟他是第一年上班，他全请还是不太好。</p><p>在地铁站分道扬镳，他与我是相反的路线，他住白云区，我住番禺区。</p><h3 id="结束后"><a href="#结束后" class="headerlink" title="结束后"></a>结束后</h3><p>抽奖抽了两个c奖（帆布袋和桌布），虽然很眼馋S奖（Xbox series x），但是自己是非酋。</p><p>第一次写那么长的博客，有点像流水账了（其实就是了），赶大作业去了——润~<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/16.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/17.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/18.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/19.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/20.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/21.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021HeJuBian/22.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;认识机核&quot;&gt;&lt;a href=&quot;#认识机核&quot; class=&quot;headerlink&quot; title=&quot;认识机核&quot;&gt;&lt;/a&gt;认识机核&lt;/h3&gt;&lt;p&gt;说起核聚变，就不得不说是如何知道机核的。如果不知道机核的话，基本上是不知道有这个活动的。当时明日方舟二周年活动——覆潮之下，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>这些时候我都在忙些什么(同时作为2021总结）</title>
    <link href="http://example.com/2021/10/08/%E8%BF%99%E4%BA%9B%E6%97%B6%E5%80%99%E6%88%91%E9%83%BD%E5%9C%A8%E5%BF%99%E4%BA%9B%E4%BB%80%E4%B9%88-%E5%90%8C%E6%97%B6%E4%BD%9C%E4%B8%BA2021%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>http://example.com/2021/10/08/%E8%BF%99%E4%BA%9B%E6%97%B6%E5%80%99%E6%88%91%E9%83%BD%E5%9C%A8%E5%BF%99%E4%BA%9B%E4%BB%80%E4%B9%88-%E5%90%8C%E6%97%B6%E4%BD%9C%E4%B8%BA2021%E6%80%BB%E7%BB%93%EF%BC%89/</id>
    <published>2021-10-08T13:31:21.000Z</published>
    <updated>2024-01-07T07:45:43.714Z</updated>
    
    <content type="html"><![CDATA[<p>太忙了，先把这段时间要做的事情放出来（加油）😂<br>10.8 循环设计QA<br>10.10 建模小作业DDL<br>10.15 循环设计实物报告<br>10.19 马原pre<br>10.20 循环设计海报pre<br>10.27 平面构成<br>色彩构成<br>构成海报<br>11.5 绘画打卡<br>11.8 家族史论文<br>11月中旬 游戏demo<br>建模大作业<br>12月 logbook 、速写、工概考试、交互导论汇报</p><p>当做完一些我会挑一些自己说说自己干了些什么🤯<br>——2021.10.8</p><p>现在才开始写这篇推文，属于是大拖更了，虽然忙了一阵子，但是忙完后会颓废上几天，什么事都不想干，稍微画了点画才调整好状态，属于我的经典状态了。<br>——2022.1.7</p><p>完成后才发现没什么可以讲的，即使完成的时候很耗时间，但是回过头来看才发现原来就这么点东西。可能最值得讲的是我的速写作业？</p><p><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021ZongJie/1.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021ZongJie/2.png" alt="img"></p><p>速写，我是一直在寻找有效练习，可以说我有一半的画作是有效练习的就不错了。看到朋友圈的同学发的画的比我好未免心生嫉妒，同时也会去查找原因。因为有些人本身就是在工设读的，我作为一个理工科学生，毕竟在绘画方面学的相比他们要少很多。可能我在我们班的绘画水平中是中间水平吧，但是在这个领域不比差，只比谁更强，所以有时候会emo😫。</p><p>作业既然没什么说的，做之前还会觉得很困难，可以说很多，做完后才发现只是个小事（建模再也不可能用alias了，太辣鸡了）。接下来说说我的2021吧。</p><p>2021刚开始就是军训+放假，可以说我的2021是在下学期开学之后才算开始。课业也多了很多，从第一学期的三门考试变到了七门考试（在电信的时候），学的那叫一个痛苦。不过翘课频率也增加了，主要还是翘数据结构，毕竟对我来说很简单。我花了2周时间对着视频教程做了小狐狸，当时生活巨不节律，喝奶茶健身加熬夜早起写代码，翘了很多课，搞得内分泌失调，长了好多痘痘😭（直到现在还有些没有消去），不过算是对unity有了些基本认知。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021ZongJie/3.png" alt="img"><br>同时，多亏与wtw一次聊天，想去查一下转计算机学院的要求，突然发现已经开始转交互专业的time了，根据我查的资料，发现是早了一整个月的，才发现前两年是有疫情所以是线上的，差点错过（错过了宣讲会，不过根据现在的同学说，当时只有三个人去，七个老师给三个学生宣讲，🤣），于是准备了一个月，各种补知识，在排名比较中间的地方转专业成功了。<br><img src="https://cdn.jsdelivr.net/gh/talentstream/PictureCDN/2021ZongJie/4.png" alt="img"><br>当时同时考7科，天天喝咖啡从早复习到晚上，就怕挂科。不过最终还是没挂科，最难的电路67险过（没想到在班里还可以排十几名，班里四十多个人😂），成功地转到了设计学院。</p><p>暑假稍微对做网站有点兴趣，于是花了一周时间简单学了三件套，加上不断地练习，练习到开学后十几天，搭好网站后就变成懒狗了（bushi），但是应付下学期的课程绰绰有余了。</p><p>到了中期，大作业不断接踵而至，有段时间每天2点睡觉8点起床去上课，那段时间真的是要累死，emo率也很高。学习了素描与色彩，对于绘画的初步认知不再是大一时的玩玩而已，也对下一步的绘画道路进行思考。</p><p>我的2021，简单来说，便是重新认识自我，确认目标，可能现在还不是特别清楚，因为时间不多了，我又有两条道路可以选择（游戏与设计），所以还不能坚定地立下来。</p><p>总的来说，还是学到很多，但是还不够，2022，唔，由不得不卷的理由了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;太忙了，先把这段时间要做的事情放出来（加油）😂&lt;br&gt;10.8 循环设计QA&lt;br&gt;10.10 建模小作业DDL&lt;br&gt;10.15 循环设计实物报告&lt;br&gt;10.19 马原pre&lt;br&gt;10.20 循环设计海报pre&lt;br&gt;10.27 平面构成&lt;br&gt;色彩构成&lt;br&gt;构成</summary>
      
    
    
    
    
  </entry>
  
</feed>
